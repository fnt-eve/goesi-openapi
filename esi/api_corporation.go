/*
EVE Stable Infrastructure (ESI) - tranquility

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2020-01-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package esi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type CorporationAPI interface {

	/*
	GetCorporationsCorporationId Get corporation information

	Public information about a corporation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdRequest
	*/
	GetCorporationsCorporationId(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdRequest

	// GetCorporationsCorporationIdExecute executes the request
	//  @return CorporationsCorporationIdGet
	GetCorporationsCorporationIdExecute(r ApiGetCorporationsCorporationIdRequest) (*CorporationsCorporationIdGet, *http.Response, error)

	/*
	GetCorporationsCorporationIdAlliancehistory Get alliance history

	Get a list of all the alliances a corporation has been a member of

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdAlliancehistoryRequest
	*/
	GetCorporationsCorporationIdAlliancehistory(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdAlliancehistoryRequest

	// GetCorporationsCorporationIdAlliancehistoryExecute executes the request
	//  @return []CorporationsCorporationIdAlliancehistoryGetInner
	GetCorporationsCorporationIdAlliancehistoryExecute(r ApiGetCorporationsCorporationIdAlliancehistoryRequest) ([]CorporationsCorporationIdAlliancehistoryGetInner, *http.Response, error)

	/*
	GetCorporationsCorporationIdBlueprints Get corporation blueprints

	Returns a list of blueprints the corporation owns

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdBlueprintsRequest
	*/
	GetCorporationsCorporationIdBlueprints(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdBlueprintsRequest

	// GetCorporationsCorporationIdBlueprintsExecute executes the request
	//  @return []CorporationsCorporationIdBlueprintsGetInner
	GetCorporationsCorporationIdBlueprintsExecute(r ApiGetCorporationsCorporationIdBlueprintsRequest) ([]CorporationsCorporationIdBlueprintsGetInner, *http.Response, error)

	/*
	GetCorporationsCorporationIdContainersLogs Get all corporation ALSC logs

	Returns logs recorded in the past seven days from all audit log secure containers (ALSC) owned by a given corporation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdContainersLogsRequest
	*/
	GetCorporationsCorporationIdContainersLogs(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdContainersLogsRequest

	// GetCorporationsCorporationIdContainersLogsExecute executes the request
	//  @return []CorporationsCorporationIdContainersLogsGetInner
	GetCorporationsCorporationIdContainersLogsExecute(r ApiGetCorporationsCorporationIdContainersLogsRequest) ([]CorporationsCorporationIdContainersLogsGetInner, *http.Response, error)

	/*
	GetCorporationsCorporationIdDivisions Get corporation divisions

	Return corporation hangar and wallet division names, only show if a division is not using the default name

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdDivisionsRequest
	*/
	GetCorporationsCorporationIdDivisions(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdDivisionsRequest

	// GetCorporationsCorporationIdDivisionsExecute executes the request
	//  @return CorporationsCorporationIdDivisionsGet
	GetCorporationsCorporationIdDivisionsExecute(r ApiGetCorporationsCorporationIdDivisionsRequest) (*CorporationsCorporationIdDivisionsGet, *http.Response, error)

	/*
	GetCorporationsCorporationIdFacilities Get corporation facilities

	Return a corporation's facilities

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdFacilitiesRequest
	*/
	GetCorporationsCorporationIdFacilities(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdFacilitiesRequest

	// GetCorporationsCorporationIdFacilitiesExecute executes the request
	//  @return []CorporationsCorporationIdFacilitiesGetInner
	GetCorporationsCorporationIdFacilitiesExecute(r ApiGetCorporationsCorporationIdFacilitiesRequest) ([]CorporationsCorporationIdFacilitiesGetInner, *http.Response, error)

	/*
	GetCorporationsCorporationIdIcons Get corporation icon

	Get the icon urls for a corporation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdIconsRequest
	*/
	GetCorporationsCorporationIdIcons(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdIconsRequest

	// GetCorporationsCorporationIdIconsExecute executes the request
	//  @return CorporationsCorporationIdIconsGet
	GetCorporationsCorporationIdIconsExecute(r ApiGetCorporationsCorporationIdIconsRequest) (*CorporationsCorporationIdIconsGet, *http.Response, error)

	/*
	GetCorporationsCorporationIdMedals Get corporation medals

	Returns a corporation's medals

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdMedalsRequest
	*/
	GetCorporationsCorporationIdMedals(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdMedalsRequest

	// GetCorporationsCorporationIdMedalsExecute executes the request
	//  @return []CorporationsCorporationIdMedalsGetInner
	GetCorporationsCorporationIdMedalsExecute(r ApiGetCorporationsCorporationIdMedalsRequest) ([]CorporationsCorporationIdMedalsGetInner, *http.Response, error)

	/*
	GetCorporationsCorporationIdMedalsIssued Get corporation issued medals

	Returns medals issued by a corporation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdMedalsIssuedRequest
	*/
	GetCorporationsCorporationIdMedalsIssued(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdMedalsIssuedRequest

	// GetCorporationsCorporationIdMedalsIssuedExecute executes the request
	//  @return []CorporationsCorporationIdMedalsIssuedGetInner
	GetCorporationsCorporationIdMedalsIssuedExecute(r ApiGetCorporationsCorporationIdMedalsIssuedRequest) ([]CorporationsCorporationIdMedalsIssuedGetInner, *http.Response, error)

	/*
	GetCorporationsCorporationIdMembers Get corporation members

	Return the current member list of a corporation, the token's character need to be a member of the corporation.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdMembersRequest
	*/
	GetCorporationsCorporationIdMembers(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdMembersRequest

	// GetCorporationsCorporationIdMembersExecute executes the request
	//  @return []int64
	GetCorporationsCorporationIdMembersExecute(r ApiGetCorporationsCorporationIdMembersRequest) ([]int64, *http.Response, error)

	/*
	GetCorporationsCorporationIdMembersLimit Get corporation member limit

	Return a corporation's member limit, not including CEO himself

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdMembersLimitRequest
	*/
	GetCorporationsCorporationIdMembersLimit(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdMembersLimitRequest

	// GetCorporationsCorporationIdMembersLimitExecute executes the request
	//  @return int64
	GetCorporationsCorporationIdMembersLimitExecute(r ApiGetCorporationsCorporationIdMembersLimitRequest) (int64, *http.Response, error)

	/*
	GetCorporationsCorporationIdMembersTitles Get corporation's members' titles

	Returns a corporation's members' titles

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdMembersTitlesRequest
	*/
	GetCorporationsCorporationIdMembersTitles(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdMembersTitlesRequest

	// GetCorporationsCorporationIdMembersTitlesExecute executes the request
	//  @return []CorporationsCorporationIdMembersTitlesGetInner
	GetCorporationsCorporationIdMembersTitlesExecute(r ApiGetCorporationsCorporationIdMembersTitlesRequest) ([]CorporationsCorporationIdMembersTitlesGetInner, *http.Response, error)

	/*
	GetCorporationsCorporationIdMembertracking Track corporation members

	Returns additional information about a corporation's members which helps tracking their activities

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdMembertrackingRequest
	*/
	GetCorporationsCorporationIdMembertracking(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdMembertrackingRequest

	// GetCorporationsCorporationIdMembertrackingExecute executes the request
	//  @return []CorporationsCorporationIdMembertrackingGetInner
	GetCorporationsCorporationIdMembertrackingExecute(r ApiGetCorporationsCorporationIdMembertrackingRequest) ([]CorporationsCorporationIdMembertrackingGetInner, *http.Response, error)

	/*
	GetCorporationsCorporationIdRoles Get corporation member roles

	Return the roles of all members if the character has the personnel manager role or any grantable role.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdRolesRequest
	*/
	GetCorporationsCorporationIdRoles(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdRolesRequest

	// GetCorporationsCorporationIdRolesExecute executes the request
	//  @return []CorporationsCorporationIdRolesGetInner
	GetCorporationsCorporationIdRolesExecute(r ApiGetCorporationsCorporationIdRolesRequest) ([]CorporationsCorporationIdRolesGetInner, *http.Response, error)

	/*
	GetCorporationsCorporationIdRolesHistory Get corporation member roles history

	Return how roles have changed for a coporation's members, up to a month

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdRolesHistoryRequest
	*/
	GetCorporationsCorporationIdRolesHistory(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdRolesHistoryRequest

	// GetCorporationsCorporationIdRolesHistoryExecute executes the request
	//  @return []CorporationsCorporationIdRolesHistoryGetInner
	GetCorporationsCorporationIdRolesHistoryExecute(r ApiGetCorporationsCorporationIdRolesHistoryRequest) ([]CorporationsCorporationIdRolesHistoryGetInner, *http.Response, error)

	/*
	GetCorporationsCorporationIdShareholders Get corporation shareholders

	Return the current shareholders of a corporation.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdShareholdersRequest
	*/
	GetCorporationsCorporationIdShareholders(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdShareholdersRequest

	// GetCorporationsCorporationIdShareholdersExecute executes the request
	//  @return []CorporationsCorporationIdShareholdersGetInner
	GetCorporationsCorporationIdShareholdersExecute(r ApiGetCorporationsCorporationIdShareholdersRequest) ([]CorporationsCorporationIdShareholdersGetInner, *http.Response, error)

	/*
	GetCorporationsCorporationIdStandings Get corporation standings

	Return corporation standings from agents, NPC corporations, and factions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdStandingsRequest
	*/
	GetCorporationsCorporationIdStandings(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdStandingsRequest

	// GetCorporationsCorporationIdStandingsExecute executes the request
	//  @return []CharactersCharacterIdStandingsGetInner
	GetCorporationsCorporationIdStandingsExecute(r ApiGetCorporationsCorporationIdStandingsRequest) ([]CharactersCharacterIdStandingsGetInner, *http.Response, error)

	/*
	GetCorporationsCorporationIdStarbases Get corporation starbases (POSes)

	Returns list of corporation starbases (POSes)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdStarbasesRequest
	*/
	GetCorporationsCorporationIdStarbases(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdStarbasesRequest

	// GetCorporationsCorporationIdStarbasesExecute executes the request
	//  @return []CorporationsCorporationIdStarbasesGetInner
	GetCorporationsCorporationIdStarbasesExecute(r ApiGetCorporationsCorporationIdStarbasesRequest) ([]CorporationsCorporationIdStarbasesGetInner, *http.Response, error)

	/*
	GetCorporationsCorporationIdStarbasesStarbaseId Get starbase (POS) detail

	Returns various settings and fuels of a starbase (POS)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@param starbaseId
	@return ApiGetCorporationsCorporationIdStarbasesStarbaseIdRequest
	*/
	GetCorporationsCorporationIdStarbasesStarbaseId(ctx context.Context, corporationId int64, starbaseId int64) ApiGetCorporationsCorporationIdStarbasesStarbaseIdRequest

	// GetCorporationsCorporationIdStarbasesStarbaseIdExecute executes the request
	//  @return CorporationsCorporationIdStarbasesStarbaseIdGet
	GetCorporationsCorporationIdStarbasesStarbaseIdExecute(r ApiGetCorporationsCorporationIdStarbasesStarbaseIdRequest) (*CorporationsCorporationIdStarbasesStarbaseIdGet, *http.Response, error)

	/*
	GetCorporationsCorporationIdStructures Get corporation structures

	Get a list of corporation structures. This route's version includes the changes to structures detailed in this blog: https://www.eveonline.com/article/upwell-2.0-structures-changes-coming-on-february-13th

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdStructuresRequest
	*/
	GetCorporationsCorporationIdStructures(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdStructuresRequest

	// GetCorporationsCorporationIdStructuresExecute executes the request
	//  @return []CorporationsCorporationIdStructuresGetInner
	GetCorporationsCorporationIdStructuresExecute(r ApiGetCorporationsCorporationIdStructuresRequest) ([]CorporationsCorporationIdStructuresGetInner, *http.Response, error)

	/*
	GetCorporationsCorporationIdTitles Get corporation titles

	Returns a corporation's titles

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdTitlesRequest
	*/
	GetCorporationsCorporationIdTitles(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdTitlesRequest

	// GetCorporationsCorporationIdTitlesExecute executes the request
	//  @return []CorporationsCorporationIdTitlesGetInner
	GetCorporationsCorporationIdTitlesExecute(r ApiGetCorporationsCorporationIdTitlesRequest) ([]CorporationsCorporationIdTitlesGetInner, *http.Response, error)

	/*
	GetCorporationsNpccorps Get npc corporations

	Get a list of npc corporations

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetCorporationsNpccorpsRequest
	*/
	GetCorporationsNpccorps(ctx context.Context) ApiGetCorporationsNpccorpsRequest

	// GetCorporationsNpccorpsExecute executes the request
	//  @return []int64
	GetCorporationsNpccorpsExecute(r ApiGetCorporationsNpccorpsRequest) ([]int64, *http.Response, error)
}

// CorporationAPIService CorporationAPI service
type CorporationAPIService service

type ApiGetCorporationsCorporationIdRequest struct {
	ctx context.Context
	ApiService CorporationAPI
	corporationId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdRequest) Execute() (*CorporationsCorporationIdGet, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdExecute(r)
}

/*
GetCorporationsCorporationId Get corporation information

Public information about a corporation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdRequest
*/
func (a *CorporationAPIService) GetCorporationsCorporationId(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdRequest {
	return ApiGetCorporationsCorporationIdRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return CorporationsCorporationIdGet
func (a *CorporationAPIService) GetCorporationsCorporationIdExecute(r ApiGetCorporationsCorporationIdRequest) (*CorporationsCorporationIdGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CorporationsCorporationIdGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationAPIService.GetCorporationsCorporationId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdAlliancehistoryRequest struct {
	ctx context.Context
	ApiService CorporationAPI
	corporationId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdAlliancehistoryRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdAlliancehistoryRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdAlliancehistoryRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdAlliancehistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdAlliancehistoryRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdAlliancehistoryRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdAlliancehistoryRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdAlliancehistoryRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdAlliancehistoryRequest) Execute() ([]CorporationsCorporationIdAlliancehistoryGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdAlliancehistoryExecute(r)
}

/*
GetCorporationsCorporationIdAlliancehistory Get alliance history

Get a list of all the alliances a corporation has been a member of

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdAlliancehistoryRequest
*/
func (a *CorporationAPIService) GetCorporationsCorporationIdAlliancehistory(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdAlliancehistoryRequest {
	return ApiGetCorporationsCorporationIdAlliancehistoryRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CorporationsCorporationIdAlliancehistoryGetInner
func (a *CorporationAPIService) GetCorporationsCorporationIdAlliancehistoryExecute(r ApiGetCorporationsCorporationIdAlliancehistoryRequest) ([]CorporationsCorporationIdAlliancehistoryGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CorporationsCorporationIdAlliancehistoryGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationAPIService.GetCorporationsCorporationIdAlliancehistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/alliancehistory"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdBlueprintsRequest struct {
	ctx context.Context
	ApiService CorporationAPI
	corporationId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdBlueprintsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdBlueprintsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCorporationsCorporationIdBlueprintsRequest) Page(page int32) ApiGetCorporationsCorporationIdBlueprintsRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdBlueprintsRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdBlueprintsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdBlueprintsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdBlueprintsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdBlueprintsRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdBlueprintsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdBlueprintsRequest) Execute() ([]CorporationsCorporationIdBlueprintsGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdBlueprintsExecute(r)
}

/*
GetCorporationsCorporationIdBlueprints Get corporation blueprints

Returns a list of blueprints the corporation owns

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdBlueprintsRequest
*/
func (a *CorporationAPIService) GetCorporationsCorporationIdBlueprints(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdBlueprintsRequest {
	return ApiGetCorporationsCorporationIdBlueprintsRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CorporationsCorporationIdBlueprintsGetInner
func (a *CorporationAPIService) GetCorporationsCorporationIdBlueprintsExecute(r ApiGetCorporationsCorporationIdBlueprintsRequest) ([]CorporationsCorporationIdBlueprintsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CorporationsCorporationIdBlueprintsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationAPIService.GetCorporationsCorporationIdBlueprints")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/blueprints"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdContainersLogsRequest struct {
	ctx context.Context
	ApiService CorporationAPI
	corporationId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdContainersLogsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdContainersLogsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCorporationsCorporationIdContainersLogsRequest) Page(page int32) ApiGetCorporationsCorporationIdContainersLogsRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdContainersLogsRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdContainersLogsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdContainersLogsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdContainersLogsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdContainersLogsRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdContainersLogsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdContainersLogsRequest) Execute() ([]CorporationsCorporationIdContainersLogsGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdContainersLogsExecute(r)
}

/*
GetCorporationsCorporationIdContainersLogs Get all corporation ALSC logs

Returns logs recorded in the past seven days from all audit log secure containers (ALSC) owned by a given corporation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdContainersLogsRequest
*/
func (a *CorporationAPIService) GetCorporationsCorporationIdContainersLogs(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdContainersLogsRequest {
	return ApiGetCorporationsCorporationIdContainersLogsRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CorporationsCorporationIdContainersLogsGetInner
func (a *CorporationAPIService) GetCorporationsCorporationIdContainersLogsExecute(r ApiGetCorporationsCorporationIdContainersLogsRequest) ([]CorporationsCorporationIdContainersLogsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CorporationsCorporationIdContainersLogsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationAPIService.GetCorporationsCorporationIdContainersLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/containers/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdDivisionsRequest struct {
	ctx context.Context
	ApiService CorporationAPI
	corporationId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdDivisionsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdDivisionsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdDivisionsRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdDivisionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdDivisionsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdDivisionsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdDivisionsRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdDivisionsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdDivisionsRequest) Execute() (*CorporationsCorporationIdDivisionsGet, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdDivisionsExecute(r)
}

/*
GetCorporationsCorporationIdDivisions Get corporation divisions

Return corporation hangar and wallet division names, only show if a division is not using the default name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdDivisionsRequest
*/
func (a *CorporationAPIService) GetCorporationsCorporationIdDivisions(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdDivisionsRequest {
	return ApiGetCorporationsCorporationIdDivisionsRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return CorporationsCorporationIdDivisionsGet
func (a *CorporationAPIService) GetCorporationsCorporationIdDivisionsExecute(r ApiGetCorporationsCorporationIdDivisionsRequest) (*CorporationsCorporationIdDivisionsGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CorporationsCorporationIdDivisionsGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationAPIService.GetCorporationsCorporationIdDivisions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/divisions"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdFacilitiesRequest struct {
	ctx context.Context
	ApiService CorporationAPI
	corporationId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdFacilitiesRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdFacilitiesRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdFacilitiesRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdFacilitiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdFacilitiesRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdFacilitiesRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdFacilitiesRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdFacilitiesRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdFacilitiesRequest) Execute() ([]CorporationsCorporationIdFacilitiesGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdFacilitiesExecute(r)
}

/*
GetCorporationsCorporationIdFacilities Get corporation facilities

Return a corporation's facilities

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdFacilitiesRequest
*/
func (a *CorporationAPIService) GetCorporationsCorporationIdFacilities(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdFacilitiesRequest {
	return ApiGetCorporationsCorporationIdFacilitiesRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CorporationsCorporationIdFacilitiesGetInner
func (a *CorporationAPIService) GetCorporationsCorporationIdFacilitiesExecute(r ApiGetCorporationsCorporationIdFacilitiesRequest) ([]CorporationsCorporationIdFacilitiesGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CorporationsCorporationIdFacilitiesGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationAPIService.GetCorporationsCorporationIdFacilities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/facilities"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdIconsRequest struct {
	ctx context.Context
	ApiService CorporationAPI
	corporationId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdIconsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdIconsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdIconsRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdIconsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdIconsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdIconsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdIconsRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdIconsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdIconsRequest) Execute() (*CorporationsCorporationIdIconsGet, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdIconsExecute(r)
}

/*
GetCorporationsCorporationIdIcons Get corporation icon

Get the icon urls for a corporation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdIconsRequest
*/
func (a *CorporationAPIService) GetCorporationsCorporationIdIcons(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdIconsRequest {
	return ApiGetCorporationsCorporationIdIconsRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return CorporationsCorporationIdIconsGet
func (a *CorporationAPIService) GetCorporationsCorporationIdIconsExecute(r ApiGetCorporationsCorporationIdIconsRequest) (*CorporationsCorporationIdIconsGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CorporationsCorporationIdIconsGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationAPIService.GetCorporationsCorporationIdIcons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/icons"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdMedalsRequest struct {
	ctx context.Context
	ApiService CorporationAPI
	corporationId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdMedalsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdMedalsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCorporationsCorporationIdMedalsRequest) Page(page int32) ApiGetCorporationsCorporationIdMedalsRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdMedalsRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdMedalsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdMedalsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdMedalsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdMedalsRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdMedalsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdMedalsRequest) Execute() ([]CorporationsCorporationIdMedalsGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdMedalsExecute(r)
}

/*
GetCorporationsCorporationIdMedals Get corporation medals

Returns a corporation's medals

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdMedalsRequest
*/
func (a *CorporationAPIService) GetCorporationsCorporationIdMedals(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdMedalsRequest {
	return ApiGetCorporationsCorporationIdMedalsRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CorporationsCorporationIdMedalsGetInner
func (a *CorporationAPIService) GetCorporationsCorporationIdMedalsExecute(r ApiGetCorporationsCorporationIdMedalsRequest) ([]CorporationsCorporationIdMedalsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CorporationsCorporationIdMedalsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationAPIService.GetCorporationsCorporationIdMedals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/medals"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdMedalsIssuedRequest struct {
	ctx context.Context
	ApiService CorporationAPI
	corporationId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdMedalsIssuedRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdMedalsIssuedRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCorporationsCorporationIdMedalsIssuedRequest) Page(page int32) ApiGetCorporationsCorporationIdMedalsIssuedRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdMedalsIssuedRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdMedalsIssuedRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdMedalsIssuedRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdMedalsIssuedRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdMedalsIssuedRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdMedalsIssuedRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdMedalsIssuedRequest) Execute() ([]CorporationsCorporationIdMedalsIssuedGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdMedalsIssuedExecute(r)
}

/*
GetCorporationsCorporationIdMedalsIssued Get corporation issued medals

Returns medals issued by a corporation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdMedalsIssuedRequest
*/
func (a *CorporationAPIService) GetCorporationsCorporationIdMedalsIssued(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdMedalsIssuedRequest {
	return ApiGetCorporationsCorporationIdMedalsIssuedRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CorporationsCorporationIdMedalsIssuedGetInner
func (a *CorporationAPIService) GetCorporationsCorporationIdMedalsIssuedExecute(r ApiGetCorporationsCorporationIdMedalsIssuedRequest) ([]CorporationsCorporationIdMedalsIssuedGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CorporationsCorporationIdMedalsIssuedGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationAPIService.GetCorporationsCorporationIdMedalsIssued")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/medals/issued"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdMembersRequest struct {
	ctx context.Context
	ApiService CorporationAPI
	corporationId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdMembersRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdMembersRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdMembersRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdMembersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdMembersRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdMembersRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdMembersRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdMembersRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdMembersRequest) Execute() ([]int64, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdMembersExecute(r)
}

/*
GetCorporationsCorporationIdMembers Get corporation members

Return the current member list of a corporation, the token's character need to be a member of the corporation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdMembersRequest
*/
func (a *CorporationAPIService) GetCorporationsCorporationIdMembers(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdMembersRequest {
	return ApiGetCorporationsCorporationIdMembersRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []int64
func (a *CorporationAPIService) GetCorporationsCorporationIdMembersExecute(r ApiGetCorporationsCorporationIdMembersRequest) ([]int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationAPIService.GetCorporationsCorporationIdMembers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdMembersLimitRequest struct {
	ctx context.Context
	ApiService CorporationAPI
	corporationId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdMembersLimitRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdMembersLimitRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdMembersLimitRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdMembersLimitRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdMembersLimitRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdMembersLimitRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdMembersLimitRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdMembersLimitRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdMembersLimitRequest) Execute() (int64, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdMembersLimitExecute(r)
}

/*
GetCorporationsCorporationIdMembersLimit Get corporation member limit

Return a corporation's member limit, not including CEO himself

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdMembersLimitRequest
*/
func (a *CorporationAPIService) GetCorporationsCorporationIdMembersLimit(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdMembersLimitRequest {
	return ApiGetCorporationsCorporationIdMembersLimitRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return int64
func (a *CorporationAPIService) GetCorporationsCorporationIdMembersLimitExecute(r ApiGetCorporationsCorporationIdMembersLimitRequest) (int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationAPIService.GetCorporationsCorporationIdMembersLimit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/members/limit"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdMembersTitlesRequest struct {
	ctx context.Context
	ApiService CorporationAPI
	corporationId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdMembersTitlesRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdMembersTitlesRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdMembersTitlesRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdMembersTitlesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdMembersTitlesRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdMembersTitlesRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdMembersTitlesRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdMembersTitlesRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdMembersTitlesRequest) Execute() ([]CorporationsCorporationIdMembersTitlesGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdMembersTitlesExecute(r)
}

/*
GetCorporationsCorporationIdMembersTitles Get corporation's members' titles

Returns a corporation's members' titles

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdMembersTitlesRequest
*/
func (a *CorporationAPIService) GetCorporationsCorporationIdMembersTitles(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdMembersTitlesRequest {
	return ApiGetCorporationsCorporationIdMembersTitlesRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CorporationsCorporationIdMembersTitlesGetInner
func (a *CorporationAPIService) GetCorporationsCorporationIdMembersTitlesExecute(r ApiGetCorporationsCorporationIdMembersTitlesRequest) ([]CorporationsCorporationIdMembersTitlesGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CorporationsCorporationIdMembersTitlesGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationAPIService.GetCorporationsCorporationIdMembersTitles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/members/titles"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdMembertrackingRequest struct {
	ctx context.Context
	ApiService CorporationAPI
	corporationId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdMembertrackingRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdMembertrackingRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdMembertrackingRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdMembertrackingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdMembertrackingRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdMembertrackingRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdMembertrackingRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdMembertrackingRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdMembertrackingRequest) Execute() ([]CorporationsCorporationIdMembertrackingGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdMembertrackingExecute(r)
}

/*
GetCorporationsCorporationIdMembertracking Track corporation members

Returns additional information about a corporation's members which helps tracking their activities

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdMembertrackingRequest
*/
func (a *CorporationAPIService) GetCorporationsCorporationIdMembertracking(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdMembertrackingRequest {
	return ApiGetCorporationsCorporationIdMembertrackingRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CorporationsCorporationIdMembertrackingGetInner
func (a *CorporationAPIService) GetCorporationsCorporationIdMembertrackingExecute(r ApiGetCorporationsCorporationIdMembertrackingRequest) ([]CorporationsCorporationIdMembertrackingGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CorporationsCorporationIdMembertrackingGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationAPIService.GetCorporationsCorporationIdMembertracking")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/membertracking"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdRolesRequest struct {
	ctx context.Context
	ApiService CorporationAPI
	corporationId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdRolesRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdRolesRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdRolesRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdRolesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdRolesRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdRolesRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdRolesRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdRolesRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdRolesRequest) Execute() ([]CorporationsCorporationIdRolesGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdRolesExecute(r)
}

/*
GetCorporationsCorporationIdRoles Get corporation member roles

Return the roles of all members if the character has the personnel manager role or any grantable role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdRolesRequest
*/
func (a *CorporationAPIService) GetCorporationsCorporationIdRoles(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdRolesRequest {
	return ApiGetCorporationsCorporationIdRolesRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CorporationsCorporationIdRolesGetInner
func (a *CorporationAPIService) GetCorporationsCorporationIdRolesExecute(r ApiGetCorporationsCorporationIdRolesRequest) ([]CorporationsCorporationIdRolesGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CorporationsCorporationIdRolesGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationAPIService.GetCorporationsCorporationIdRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdRolesHistoryRequest struct {
	ctx context.Context
	ApiService CorporationAPI
	corporationId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdRolesHistoryRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdRolesHistoryRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCorporationsCorporationIdRolesHistoryRequest) Page(page int32) ApiGetCorporationsCorporationIdRolesHistoryRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdRolesHistoryRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdRolesHistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdRolesHistoryRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdRolesHistoryRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdRolesHistoryRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdRolesHistoryRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdRolesHistoryRequest) Execute() ([]CorporationsCorporationIdRolesHistoryGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdRolesHistoryExecute(r)
}

/*
GetCorporationsCorporationIdRolesHistory Get corporation member roles history

Return how roles have changed for a coporation's members, up to a month

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdRolesHistoryRequest
*/
func (a *CorporationAPIService) GetCorporationsCorporationIdRolesHistory(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdRolesHistoryRequest {
	return ApiGetCorporationsCorporationIdRolesHistoryRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CorporationsCorporationIdRolesHistoryGetInner
func (a *CorporationAPIService) GetCorporationsCorporationIdRolesHistoryExecute(r ApiGetCorporationsCorporationIdRolesHistoryRequest) ([]CorporationsCorporationIdRolesHistoryGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CorporationsCorporationIdRolesHistoryGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationAPIService.GetCorporationsCorporationIdRolesHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/roles/history"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdShareholdersRequest struct {
	ctx context.Context
	ApiService CorporationAPI
	corporationId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdShareholdersRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdShareholdersRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCorporationsCorporationIdShareholdersRequest) Page(page int32) ApiGetCorporationsCorporationIdShareholdersRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdShareholdersRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdShareholdersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdShareholdersRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdShareholdersRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdShareholdersRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdShareholdersRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdShareholdersRequest) Execute() ([]CorporationsCorporationIdShareholdersGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdShareholdersExecute(r)
}

/*
GetCorporationsCorporationIdShareholders Get corporation shareholders

Return the current shareholders of a corporation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdShareholdersRequest
*/
func (a *CorporationAPIService) GetCorporationsCorporationIdShareholders(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdShareholdersRequest {
	return ApiGetCorporationsCorporationIdShareholdersRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CorporationsCorporationIdShareholdersGetInner
func (a *CorporationAPIService) GetCorporationsCorporationIdShareholdersExecute(r ApiGetCorporationsCorporationIdShareholdersRequest) ([]CorporationsCorporationIdShareholdersGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CorporationsCorporationIdShareholdersGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationAPIService.GetCorporationsCorporationIdShareholders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/shareholders"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdStandingsRequest struct {
	ctx context.Context
	ApiService CorporationAPI
	corporationId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdStandingsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdStandingsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCorporationsCorporationIdStandingsRequest) Page(page int32) ApiGetCorporationsCorporationIdStandingsRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdStandingsRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdStandingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdStandingsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdStandingsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdStandingsRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdStandingsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdStandingsRequest) Execute() ([]CharactersCharacterIdStandingsGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdStandingsExecute(r)
}

/*
GetCorporationsCorporationIdStandings Get corporation standings

Return corporation standings from agents, NPC corporations, and factions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdStandingsRequest
*/
func (a *CorporationAPIService) GetCorporationsCorporationIdStandings(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdStandingsRequest {
	return ApiGetCorporationsCorporationIdStandingsRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CharactersCharacterIdStandingsGetInner
func (a *CorporationAPIService) GetCorporationsCorporationIdStandingsExecute(r ApiGetCorporationsCorporationIdStandingsRequest) ([]CharactersCharacterIdStandingsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharactersCharacterIdStandingsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationAPIService.GetCorporationsCorporationIdStandings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/standings"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdStarbasesRequest struct {
	ctx context.Context
	ApiService CorporationAPI
	corporationId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdStarbasesRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdStarbasesRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCorporationsCorporationIdStarbasesRequest) Page(page int32) ApiGetCorporationsCorporationIdStarbasesRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdStarbasesRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdStarbasesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdStarbasesRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdStarbasesRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdStarbasesRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdStarbasesRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdStarbasesRequest) Execute() ([]CorporationsCorporationIdStarbasesGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdStarbasesExecute(r)
}

/*
GetCorporationsCorporationIdStarbases Get corporation starbases (POSes)

Returns list of corporation starbases (POSes)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdStarbasesRequest
*/
func (a *CorporationAPIService) GetCorporationsCorporationIdStarbases(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdStarbasesRequest {
	return ApiGetCorporationsCorporationIdStarbasesRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CorporationsCorporationIdStarbasesGetInner
func (a *CorporationAPIService) GetCorporationsCorporationIdStarbasesExecute(r ApiGetCorporationsCorporationIdStarbasesRequest) ([]CorporationsCorporationIdStarbasesGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CorporationsCorporationIdStarbasesGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationAPIService.GetCorporationsCorporationIdStarbases")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/starbases"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdStarbasesStarbaseIdRequest struct {
	ctx context.Context
	ApiService CorporationAPI
	corporationId int64
	starbaseId int64
	systemId *int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

func (r ApiGetCorporationsCorporationIdStarbasesStarbaseIdRequest) SystemId(systemId int64) ApiGetCorporationsCorporationIdStarbasesStarbaseIdRequest {
	r.systemId = &systemId
	return r
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdStarbasesStarbaseIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdStarbasesStarbaseIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdStarbasesStarbaseIdRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdStarbasesStarbaseIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdStarbasesStarbaseIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdStarbasesStarbaseIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdStarbasesStarbaseIdRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdStarbasesStarbaseIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdStarbasesStarbaseIdRequest) Execute() (*CorporationsCorporationIdStarbasesStarbaseIdGet, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdStarbasesStarbaseIdExecute(r)
}

/*
GetCorporationsCorporationIdStarbasesStarbaseId Get starbase (POS) detail

Returns various settings and fuels of a starbase (POS)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @param starbaseId
 @return ApiGetCorporationsCorporationIdStarbasesStarbaseIdRequest
*/
func (a *CorporationAPIService) GetCorporationsCorporationIdStarbasesStarbaseId(ctx context.Context, corporationId int64, starbaseId int64) ApiGetCorporationsCorporationIdStarbasesStarbaseIdRequest {
	return ApiGetCorporationsCorporationIdStarbasesStarbaseIdRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
		starbaseId: starbaseId,
	}
}

// Execute executes the request
//  @return CorporationsCorporationIdStarbasesStarbaseIdGet
func (a *CorporationAPIService) GetCorporationsCorporationIdStarbasesStarbaseIdExecute(r ApiGetCorporationsCorporationIdStarbasesStarbaseIdRequest) (*CorporationsCorporationIdStarbasesStarbaseIdGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CorporationsCorporationIdStarbasesStarbaseIdGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationAPIService.GetCorporationsCorporationIdStarbasesStarbaseId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/starbases/{starbase_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"starbase_id"+"}", url.PathEscape(parameterValueToString(r.starbaseId, "starbaseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.systemId == nil {
		return localVarReturnValue, nil, reportError("systemId is required and must be specified")
	}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "system_id", r.systemId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdStructuresRequest struct {
	ctx context.Context
	ApiService CorporationAPI
	corporationId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdStructuresRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdStructuresRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCorporationsCorporationIdStructuresRequest) Page(page int32) ApiGetCorporationsCorporationIdStructuresRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdStructuresRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdStructuresRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdStructuresRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdStructuresRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdStructuresRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdStructuresRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdStructuresRequest) Execute() ([]CorporationsCorporationIdStructuresGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdStructuresExecute(r)
}

/*
GetCorporationsCorporationIdStructures Get corporation structures

Get a list of corporation structures. This route's version includes the changes to structures detailed in this blog: https://www.eveonline.com/article/upwell-2.0-structures-changes-coming-on-february-13th

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdStructuresRequest
*/
func (a *CorporationAPIService) GetCorporationsCorporationIdStructures(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdStructuresRequest {
	return ApiGetCorporationsCorporationIdStructuresRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CorporationsCorporationIdStructuresGetInner
func (a *CorporationAPIService) GetCorporationsCorporationIdStructuresExecute(r ApiGetCorporationsCorporationIdStructuresRequest) ([]CorporationsCorporationIdStructuresGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CorporationsCorporationIdStructuresGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationAPIService.GetCorporationsCorporationIdStructures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/structures"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdTitlesRequest struct {
	ctx context.Context
	ApiService CorporationAPI
	corporationId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdTitlesRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdTitlesRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdTitlesRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdTitlesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdTitlesRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdTitlesRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdTitlesRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdTitlesRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdTitlesRequest) Execute() ([]CorporationsCorporationIdTitlesGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdTitlesExecute(r)
}

/*
GetCorporationsCorporationIdTitles Get corporation titles

Returns a corporation's titles

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdTitlesRequest
*/
func (a *CorporationAPIService) GetCorporationsCorporationIdTitles(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdTitlesRequest {
	return ApiGetCorporationsCorporationIdTitlesRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CorporationsCorporationIdTitlesGetInner
func (a *CorporationAPIService) GetCorporationsCorporationIdTitlesExecute(r ApiGetCorporationsCorporationIdTitlesRequest) ([]CorporationsCorporationIdTitlesGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CorporationsCorporationIdTitlesGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationAPIService.GetCorporationsCorporationIdTitles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/titles"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsNpccorpsRequest struct {
	ctx context.Context
	ApiService CorporationAPI
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsNpccorpsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsNpccorpsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsNpccorpsRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsNpccorpsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsNpccorpsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsNpccorpsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsNpccorpsRequest) XTenant(xTenant string) ApiGetCorporationsNpccorpsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsNpccorpsRequest) Execute() ([]int64, *http.Response, error) {
	return r.ApiService.GetCorporationsNpccorpsExecute(r)
}

/*
GetCorporationsNpccorps Get npc corporations

Get a list of npc corporations

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCorporationsNpccorpsRequest
*/
func (a *CorporationAPIService) GetCorporationsNpccorps(ctx context.Context) ApiGetCorporationsNpccorpsRequest {
	return ApiGetCorporationsNpccorpsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []int64
func (a *CorporationAPIService) GetCorporationsNpccorpsExecute(r ApiGetCorporationsNpccorpsRequest) ([]int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationAPIService.GetCorporationsNpccorps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/npccorps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
