/*
EVE Stable Infrastructure (ESI) - tranquility

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2025-12-16
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package esi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type FreelanceJobsAPI interface {

	/*
	GetCharactersFreelanceJobsListing List character freelance jobs

	Listing of all freelance jobs you are actively participating in.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersFreelanceJobsListingRequest
	*/
	GetCharactersFreelanceJobsListing(ctx context.Context, characterId int64) ApiGetCharactersFreelanceJobsListingRequest

	// GetCharactersFreelanceJobsListingExecute executes the request
	//  @return CharactersFreelanceJobsListing
	GetCharactersFreelanceJobsListingExecute(r ApiGetCharactersFreelanceJobsListingRequest) (*CharactersFreelanceJobsListing, *http.Response, error)

	/*
	GetCharactersFreelanceJobsParticipation Get character freelance job participation

	Show your participation in a freelance job.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@param jobId The ID of the freelance job
	@return ApiGetCharactersFreelanceJobsParticipationRequest
	*/
	GetCharactersFreelanceJobsParticipation(ctx context.Context, characterId int64, jobId string) ApiGetCharactersFreelanceJobsParticipationRequest

	// GetCharactersFreelanceJobsParticipationExecute executes the request
	//  @return CharactersFreelanceJobsParticipation
	GetCharactersFreelanceJobsParticipationExecute(r ApiGetCharactersFreelanceJobsParticipationRequest) (*CharactersFreelanceJobsParticipation, *http.Response, error)

	/*
	GetCorporationsFreelanceJobsListing List corporation freelance jobs

	Listing of all freelance jobs for your corporation.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsFreelanceJobsListingRequest
	*/
	GetCorporationsFreelanceJobsListing(ctx context.Context, corporationId int64) ApiGetCorporationsFreelanceJobsListingRequest

	// GetCorporationsFreelanceJobsListingExecute executes the request
	//  @return CorporationsFreelanceJobsListing
	GetCorporationsFreelanceJobsListingExecute(r ApiGetCorporationsFreelanceJobsListingRequest) (*CorporationsFreelanceJobsListing, *http.Response, error)

	/*
	GetCorporationsFreelanceJobsParticipants List participants of a freelance job

	Listing of all participants of a freelance job.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@param jobId The ID of the job
	@return ApiGetCorporationsFreelanceJobsParticipantsRequest
	*/
	GetCorporationsFreelanceJobsParticipants(ctx context.Context, corporationId int64, jobId string) ApiGetCorporationsFreelanceJobsParticipantsRequest

	// GetCorporationsFreelanceJobsParticipantsExecute executes the request
	//  @return CorporationsFreelanceJobsParticipants
	GetCorporationsFreelanceJobsParticipantsExecute(r ApiGetCorporationsFreelanceJobsParticipantsRequest) (*CorporationsFreelanceJobsParticipants, *http.Response, error)

	/*
	GetFreelanceJobsDetail Get freelance job details

	Get the details of a freelance job.

Jobs without an ACL (public jobs) does not require authentication.

Jobs with an ACL requires authentication, and requires that the character is:
- An active participant of the job, or
- A freelance job manager for the corporation that owns the job.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobId The ID of the freelance job
	@return ApiGetFreelanceJobsDetailRequest
	*/
	GetFreelanceJobsDetail(ctx context.Context, jobId string) ApiGetFreelanceJobsDetailRequest

	// GetFreelanceJobsDetailExecute executes the request
	//  @return FreelanceJobsDetail
	GetFreelanceJobsDetailExecute(r ApiGetFreelanceJobsDetailRequest) (*FreelanceJobsDetail, *http.Response, error)

	/*
	GetFreelanceJobsListing List freelance jobs

	Listing of all public freelance jobs.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetFreelanceJobsListingRequest
	*/
	GetFreelanceJobsListing(ctx context.Context) ApiGetFreelanceJobsListingRequest

	// GetFreelanceJobsListingExecute executes the request
	//  @return FreelanceJobsListing
	GetFreelanceJobsListingExecute(r ApiGetFreelanceJobsListingRequest) (*FreelanceJobsListing, *http.Response, error)
}

// FreelanceJobsAPIService FreelanceJobsAPI service
type FreelanceJobsAPIService service

type ApiGetCharactersFreelanceJobsListingRequest struct {
	ctx context.Context
	ApiService FreelanceJobsAPI
	characterId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
	ifModifiedSince *string
}

// The compatibility date for the request.
func (r ApiGetCharactersFreelanceJobsListingRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersFreelanceJobsListingRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCharactersFreelanceJobsListingRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersFreelanceJobsListingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersFreelanceJobsListingRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersFreelanceJobsListingRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersFreelanceJobsListingRequest) XTenant(xTenant string) ApiGetCharactersFreelanceJobsListingRequest {
	r.xTenant = &xTenant
	return r
}

// The date the resource was last modified. A 304 will be returned if the resource has not been modified since this date.
func (r ApiGetCharactersFreelanceJobsListingRequest) IfModifiedSince(ifModifiedSince string) ApiGetCharactersFreelanceJobsListingRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

func (r ApiGetCharactersFreelanceJobsListingRequest) Execute() (*CharactersFreelanceJobsListing, *http.Response, error) {
	return r.ApiService.GetCharactersFreelanceJobsListingExecute(r)
}

/*
GetCharactersFreelanceJobsListing List character freelance jobs

Listing of all freelance jobs you are actively participating in.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersFreelanceJobsListingRequest
*/
func (a *FreelanceJobsAPIService) GetCharactersFreelanceJobsListing(ctx context.Context, characterId int64) ApiGetCharactersFreelanceJobsListingRequest {
	return ApiGetCharactersFreelanceJobsListingRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return CharactersFreelanceJobsListing
func (a *FreelanceJobsAPIService) GetCharactersFreelanceJobsListingExecute(r ApiGetCharactersFreelanceJobsListingRequest) (*CharactersFreelanceJobsListing, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CharactersFreelanceJobsListing
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreelanceJobsAPIService.GetCharactersFreelanceJobsListing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/freelance-jobs"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCharactersFreelanceJobsParticipationRequest struct {
	ctx context.Context
	ApiService FreelanceJobsAPI
	characterId int64
	jobId string
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
	ifModifiedSince *string
}

// The compatibility date for the request.
func (r ApiGetCharactersFreelanceJobsParticipationRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersFreelanceJobsParticipationRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCharactersFreelanceJobsParticipationRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersFreelanceJobsParticipationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersFreelanceJobsParticipationRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersFreelanceJobsParticipationRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersFreelanceJobsParticipationRequest) XTenant(xTenant string) ApiGetCharactersFreelanceJobsParticipationRequest {
	r.xTenant = &xTenant
	return r
}

// The date the resource was last modified. A 304 will be returned if the resource has not been modified since this date.
func (r ApiGetCharactersFreelanceJobsParticipationRequest) IfModifiedSince(ifModifiedSince string) ApiGetCharactersFreelanceJobsParticipationRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

func (r ApiGetCharactersFreelanceJobsParticipationRequest) Execute() (*CharactersFreelanceJobsParticipation, *http.Response, error) {
	return r.ApiService.GetCharactersFreelanceJobsParticipationExecute(r)
}

/*
GetCharactersFreelanceJobsParticipation Get character freelance job participation

Show your participation in a freelance job.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @param jobId The ID of the freelance job
 @return ApiGetCharactersFreelanceJobsParticipationRequest
*/
func (a *FreelanceJobsAPIService) GetCharactersFreelanceJobsParticipation(ctx context.Context, characterId int64, jobId string) ApiGetCharactersFreelanceJobsParticipationRequest {
	return ApiGetCharactersFreelanceJobsParticipationRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return CharactersFreelanceJobsParticipation
func (a *FreelanceJobsAPIService) GetCharactersFreelanceJobsParticipationExecute(r ApiGetCharactersFreelanceJobsParticipationRequest) (*CharactersFreelanceJobsParticipation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CharactersFreelanceJobsParticipation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreelanceJobsAPIService.GetCharactersFreelanceJobsParticipation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/freelance-jobs/{job_id}/participation"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsFreelanceJobsListingRequest struct {
	ctx context.Context
	ApiService FreelanceJobsAPI
	corporationId int64
	xCompatibilityDate *string
	after *string
	before *string
	limit *int64
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
	ifModifiedSince *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsFreelanceJobsListingRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsFreelanceJobsListingRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// Return records from after this cursor (mutual exclusive with &#39;before&#39;). &#39;0&#39; to start from the beginning.
func (r ApiGetCorporationsFreelanceJobsListingRequest) After(after string) ApiGetCorporationsFreelanceJobsListingRequest {
	r.after = &after
	return r
}

// Return records from before this cursor (mutual exclusive with &#39;after&#39;). &#39;0&#39; to start from the end.
func (r ApiGetCorporationsFreelanceJobsListingRequest) Before(before string) ApiGetCorporationsFreelanceJobsListingRequest {
	r.before = &before
	return r
}

// The amount of records to retrieve per request.
func (r ApiGetCorporationsFreelanceJobsListingRequest) Limit(limit int64) ApiGetCorporationsFreelanceJobsListingRequest {
	r.limit = &limit
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsFreelanceJobsListingRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsFreelanceJobsListingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsFreelanceJobsListingRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsFreelanceJobsListingRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsFreelanceJobsListingRequest) XTenant(xTenant string) ApiGetCorporationsFreelanceJobsListingRequest {
	r.xTenant = &xTenant
	return r
}

// The date the resource was last modified. A 304 will be returned if the resource has not been modified since this date.
func (r ApiGetCorporationsFreelanceJobsListingRequest) IfModifiedSince(ifModifiedSince string) ApiGetCorporationsFreelanceJobsListingRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

func (r ApiGetCorporationsFreelanceJobsListingRequest) Execute() (*CorporationsFreelanceJobsListing, *http.Response, error) {
	return r.ApiService.GetCorporationsFreelanceJobsListingExecute(r)
}

/*
GetCorporationsFreelanceJobsListing List corporation freelance jobs

Listing of all freelance jobs for your corporation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsFreelanceJobsListingRequest
*/
func (a *FreelanceJobsAPIService) GetCorporationsFreelanceJobsListing(ctx context.Context, corporationId int64) ApiGetCorporationsFreelanceJobsListingRequest {
	return ApiGetCorporationsFreelanceJobsListingRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return CorporationsFreelanceJobsListing
func (a *FreelanceJobsAPIService) GetCorporationsFreelanceJobsListingExecute(r ApiGetCorporationsFreelanceJobsListingRequest) (*CorporationsFreelanceJobsListing, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CorporationsFreelanceJobsListing
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreelanceJobsAPIService.GetCorporationsFreelanceJobsListing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/freelance-jobs"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int64 = 10
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsFreelanceJobsParticipantsRequest struct {
	ctx context.Context
	ApiService FreelanceJobsAPI
	corporationId int64
	jobId string
	xCompatibilityDate *string
	after *string
	before *string
	limit *int64
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
	ifModifiedSince *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsFreelanceJobsParticipantsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsFreelanceJobsParticipantsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// Return records from after this cursor (mutual exclusive with &#39;before&#39;). &#39;0&#39; to start from the beginning.
func (r ApiGetCorporationsFreelanceJobsParticipantsRequest) After(after string) ApiGetCorporationsFreelanceJobsParticipantsRequest {
	r.after = &after
	return r
}

// Return records from before this cursor (mutual exclusive with &#39;after&#39;). &#39;0&#39; to start from the end.
func (r ApiGetCorporationsFreelanceJobsParticipantsRequest) Before(before string) ApiGetCorporationsFreelanceJobsParticipantsRequest {
	r.before = &before
	return r
}

// The amount of records to retrieve per request.
func (r ApiGetCorporationsFreelanceJobsParticipantsRequest) Limit(limit int64) ApiGetCorporationsFreelanceJobsParticipantsRequest {
	r.limit = &limit
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsFreelanceJobsParticipantsRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsFreelanceJobsParticipantsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsFreelanceJobsParticipantsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsFreelanceJobsParticipantsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsFreelanceJobsParticipantsRequest) XTenant(xTenant string) ApiGetCorporationsFreelanceJobsParticipantsRequest {
	r.xTenant = &xTenant
	return r
}

// The date the resource was last modified. A 304 will be returned if the resource has not been modified since this date.
func (r ApiGetCorporationsFreelanceJobsParticipantsRequest) IfModifiedSince(ifModifiedSince string) ApiGetCorporationsFreelanceJobsParticipantsRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

func (r ApiGetCorporationsFreelanceJobsParticipantsRequest) Execute() (*CorporationsFreelanceJobsParticipants, *http.Response, error) {
	return r.ApiService.GetCorporationsFreelanceJobsParticipantsExecute(r)
}

/*
GetCorporationsFreelanceJobsParticipants List participants of a freelance job

Listing of all participants of a freelance job.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @param jobId The ID of the job
 @return ApiGetCorporationsFreelanceJobsParticipantsRequest
*/
func (a *FreelanceJobsAPIService) GetCorporationsFreelanceJobsParticipants(ctx context.Context, corporationId int64, jobId string) ApiGetCorporationsFreelanceJobsParticipantsRequest {
	return ApiGetCorporationsFreelanceJobsParticipantsRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return CorporationsFreelanceJobsParticipants
func (a *FreelanceJobsAPIService) GetCorporationsFreelanceJobsParticipantsExecute(r ApiGetCorporationsFreelanceJobsParticipantsRequest) (*CorporationsFreelanceJobsParticipants, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CorporationsFreelanceJobsParticipants
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreelanceJobsAPIService.GetCorporationsFreelanceJobsParticipants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/freelance-jobs/{job_id}/participants"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int64 = 10
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFreelanceJobsDetailRequest struct {
	ctx context.Context
	ApiService FreelanceJobsAPI
	jobId string
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
	ifModifiedSince *string
}

// The compatibility date for the request.
func (r ApiGetFreelanceJobsDetailRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetFreelanceJobsDetailRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetFreelanceJobsDetailRequest) AcceptLanguage(acceptLanguage string) ApiGetFreelanceJobsDetailRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetFreelanceJobsDetailRequest) IfNoneMatch(ifNoneMatch string) ApiGetFreelanceJobsDetailRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetFreelanceJobsDetailRequest) XTenant(xTenant string) ApiGetFreelanceJobsDetailRequest {
	r.xTenant = &xTenant
	return r
}

// The date the resource was last modified. A 304 will be returned if the resource has not been modified since this date.
func (r ApiGetFreelanceJobsDetailRequest) IfModifiedSince(ifModifiedSince string) ApiGetFreelanceJobsDetailRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

func (r ApiGetFreelanceJobsDetailRequest) Execute() (*FreelanceJobsDetail, *http.Response, error) {
	return r.ApiService.GetFreelanceJobsDetailExecute(r)
}

/*
GetFreelanceJobsDetail Get freelance job details

Get the details of a freelance job.

Jobs without an ACL (public jobs) does not require authentication.

Jobs with an ACL requires authentication, and requires that the character is:
- An active participant of the job, or
- A freelance job manager for the corporation that owns the job.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId The ID of the freelance job
 @return ApiGetFreelanceJobsDetailRequest
*/
func (a *FreelanceJobsAPIService) GetFreelanceJobsDetail(ctx context.Context, jobId string) ApiGetFreelanceJobsDetailRequest {
	return ApiGetFreelanceJobsDetailRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return FreelanceJobsDetail
func (a *FreelanceJobsAPIService) GetFreelanceJobsDetailExecute(r ApiGetFreelanceJobsDetailRequest) (*FreelanceJobsDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FreelanceJobsDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreelanceJobsAPIService.GetFreelanceJobsDetail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/freelance-jobs/{job_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFreelanceJobsListingRequest struct {
	ctx context.Context
	ApiService FreelanceJobsAPI
	xCompatibilityDate *string
	after *string
	before *string
	limit *int64
	corporationId *int64
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
	ifModifiedSince *string
}

// The compatibility date for the request.
func (r ApiGetFreelanceJobsListingRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetFreelanceJobsListingRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// Return records from after this cursor (mutual exclusive with &#39;before&#39;). &#39;0&#39; to start from the beginning.
func (r ApiGetFreelanceJobsListingRequest) After(after string) ApiGetFreelanceJobsListingRequest {
	r.after = &after
	return r
}

// Return records from before this cursor (mutual exclusive with &#39;after&#39;). &#39;0&#39; to start from the end.
func (r ApiGetFreelanceJobsListingRequest) Before(before string) ApiGetFreelanceJobsListingRequest {
	r.before = &before
	return r
}

// The amount of records to retrieve per request.
func (r ApiGetFreelanceJobsListingRequest) Limit(limit int64) ApiGetFreelanceJobsListingRequest {
	r.limit = &limit
	return r
}

// Filter on corporation ID
func (r ApiGetFreelanceJobsListingRequest) CorporationId(corporationId int64) ApiGetFreelanceJobsListingRequest {
	r.corporationId = &corporationId
	return r
}

// The language to use for the response.
func (r ApiGetFreelanceJobsListingRequest) AcceptLanguage(acceptLanguage string) ApiGetFreelanceJobsListingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetFreelanceJobsListingRequest) IfNoneMatch(ifNoneMatch string) ApiGetFreelanceJobsListingRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetFreelanceJobsListingRequest) XTenant(xTenant string) ApiGetFreelanceJobsListingRequest {
	r.xTenant = &xTenant
	return r
}

// The date the resource was last modified. A 304 will be returned if the resource has not been modified since this date.
func (r ApiGetFreelanceJobsListingRequest) IfModifiedSince(ifModifiedSince string) ApiGetFreelanceJobsListingRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

func (r ApiGetFreelanceJobsListingRequest) Execute() (*FreelanceJobsListing, *http.Response, error) {
	return r.ApiService.GetFreelanceJobsListingExecute(r)
}

/*
GetFreelanceJobsListing List freelance jobs

Listing of all public freelance jobs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFreelanceJobsListingRequest
*/
func (a *FreelanceJobsAPIService) GetFreelanceJobsListing(ctx context.Context) ApiGetFreelanceJobsListingRequest {
	return ApiGetFreelanceJobsListingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FreelanceJobsListing
func (a *FreelanceJobsAPIService) GetFreelanceJobsListingExecute(r ApiGetFreelanceJobsListingRequest) (*FreelanceJobsListing, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FreelanceJobsListing
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FreelanceJobsAPIService.GetFreelanceJobsListing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/freelance-jobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int64 = 10
		r.limit = &defaultValue
	}
	if r.corporationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "corporation_id", r.corporationId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
