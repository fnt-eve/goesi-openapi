/*
EVE Stable Infrastructure (ESI) - tranquility

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2025-09-30
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package esi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type UniverseAPI interface {

	/*
	GetUniverseAncestries Get ancestries

	Get all character ancestries

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUniverseAncestriesRequest
	*/
	GetUniverseAncestries(ctx context.Context) ApiGetUniverseAncestriesRequest

	// GetUniverseAncestriesExecute executes the request
	//  @return []UniverseAncestriesGetInner
	GetUniverseAncestriesExecute(r ApiGetUniverseAncestriesRequest) ([]UniverseAncestriesGetInner, *http.Response, error)

	/*
	GetUniverseAsteroidBeltsAsteroidBeltId Get asteroid belt information

	Get information on an asteroid belt

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param asteroidBeltId
	@return ApiGetUniverseAsteroidBeltsAsteroidBeltIdRequest
	*/
	GetUniverseAsteroidBeltsAsteroidBeltId(ctx context.Context, asteroidBeltId int64) ApiGetUniverseAsteroidBeltsAsteroidBeltIdRequest

	// GetUniverseAsteroidBeltsAsteroidBeltIdExecute executes the request
	//  @return UniverseAsteroidBeltsAsteroidBeltIdGet
	GetUniverseAsteroidBeltsAsteroidBeltIdExecute(r ApiGetUniverseAsteroidBeltsAsteroidBeltIdRequest) (*UniverseAsteroidBeltsAsteroidBeltIdGet, *http.Response, error)

	/*
	GetUniverseBloodlines Get bloodlines

	Get a list of bloodlines

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUniverseBloodlinesRequest
	*/
	GetUniverseBloodlines(ctx context.Context) ApiGetUniverseBloodlinesRequest

	// GetUniverseBloodlinesExecute executes the request
	//  @return []UniverseBloodlinesGetInner
	GetUniverseBloodlinesExecute(r ApiGetUniverseBloodlinesRequest) ([]UniverseBloodlinesGetInner, *http.Response, error)

	/*
	GetUniverseCategories Get item categories

	Get a list of item categories

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUniverseCategoriesRequest
	*/
	GetUniverseCategories(ctx context.Context) ApiGetUniverseCategoriesRequest

	// GetUniverseCategoriesExecute executes the request
	//  @return []int64
	GetUniverseCategoriesExecute(r ApiGetUniverseCategoriesRequest) ([]int64, *http.Response, error)

	/*
	GetUniverseCategoriesCategoryId Get item category information

	Get information of an item category

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param categoryId
	@return ApiGetUniverseCategoriesCategoryIdRequest
	*/
	GetUniverseCategoriesCategoryId(ctx context.Context, categoryId int64) ApiGetUniverseCategoriesCategoryIdRequest

	// GetUniverseCategoriesCategoryIdExecute executes the request
	//  @return UniverseCategoriesCategoryIdGet
	GetUniverseCategoriesCategoryIdExecute(r ApiGetUniverseCategoriesCategoryIdRequest) (*UniverseCategoriesCategoryIdGet, *http.Response, error)

	/*
	GetUniverseConstellations Get constellations

	Get a list of constellations

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUniverseConstellationsRequest
	*/
	GetUniverseConstellations(ctx context.Context) ApiGetUniverseConstellationsRequest

	// GetUniverseConstellationsExecute executes the request
	//  @return []int64
	GetUniverseConstellationsExecute(r ApiGetUniverseConstellationsRequest) ([]int64, *http.Response, error)

	/*
	GetUniverseConstellationsConstellationId Get constellation information

	Get information on a constellation

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param constellationId
	@return ApiGetUniverseConstellationsConstellationIdRequest
	*/
	GetUniverseConstellationsConstellationId(ctx context.Context, constellationId int64) ApiGetUniverseConstellationsConstellationIdRequest

	// GetUniverseConstellationsConstellationIdExecute executes the request
	//  @return UniverseConstellationsConstellationIdGet
	GetUniverseConstellationsConstellationIdExecute(r ApiGetUniverseConstellationsConstellationIdRequest) (*UniverseConstellationsConstellationIdGet, *http.Response, error)

	/*
	GetUniverseFactions Get factions

	Get a list of factions

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUniverseFactionsRequest
	*/
	GetUniverseFactions(ctx context.Context) ApiGetUniverseFactionsRequest

	// GetUniverseFactionsExecute executes the request
	//  @return []UniverseFactionsGetInner
	GetUniverseFactionsExecute(r ApiGetUniverseFactionsRequest) ([]UniverseFactionsGetInner, *http.Response, error)

	/*
	GetUniverseGraphics Get graphics

	Get a list of graphics

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUniverseGraphicsRequest
	*/
	GetUniverseGraphics(ctx context.Context) ApiGetUniverseGraphicsRequest

	// GetUniverseGraphicsExecute executes the request
	//  @return []int64
	GetUniverseGraphicsExecute(r ApiGetUniverseGraphicsRequest) ([]int64, *http.Response, error)

	/*
	GetUniverseGraphicsGraphicId Get graphic information

	Get information on a graphic

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param graphicId
	@return ApiGetUniverseGraphicsGraphicIdRequest
	*/
	GetUniverseGraphicsGraphicId(ctx context.Context, graphicId int64) ApiGetUniverseGraphicsGraphicIdRequest

	// GetUniverseGraphicsGraphicIdExecute executes the request
	//  @return UniverseGraphicsGraphicIdGet
	GetUniverseGraphicsGraphicIdExecute(r ApiGetUniverseGraphicsGraphicIdRequest) (*UniverseGraphicsGraphicIdGet, *http.Response, error)

	/*
	GetUniverseGroups Get item groups

	Get a list of item groups

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUniverseGroupsRequest
	*/
	GetUniverseGroups(ctx context.Context) ApiGetUniverseGroupsRequest

	// GetUniverseGroupsExecute executes the request
	//  @return []int64
	GetUniverseGroupsExecute(r ApiGetUniverseGroupsRequest) ([]int64, *http.Response, error)

	/*
	GetUniverseGroupsGroupId Get item group information

	Get information on an item group

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId
	@return ApiGetUniverseGroupsGroupIdRequest
	*/
	GetUniverseGroupsGroupId(ctx context.Context, groupId int64) ApiGetUniverseGroupsGroupIdRequest

	// GetUniverseGroupsGroupIdExecute executes the request
	//  @return UniverseGroupsGroupIdGet
	GetUniverseGroupsGroupIdExecute(r ApiGetUniverseGroupsGroupIdRequest) (*UniverseGroupsGroupIdGet, *http.Response, error)

	/*
	GetUniverseMoonsMoonId Get moon information

	Get information on a moon

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param moonId
	@return ApiGetUniverseMoonsMoonIdRequest
	*/
	GetUniverseMoonsMoonId(ctx context.Context, moonId int64) ApiGetUniverseMoonsMoonIdRequest

	// GetUniverseMoonsMoonIdExecute executes the request
	//  @return UniverseMoonsMoonIdGet
	GetUniverseMoonsMoonIdExecute(r ApiGetUniverseMoonsMoonIdRequest) (*UniverseMoonsMoonIdGet, *http.Response, error)

	/*
	GetUniversePlanetsPlanetId Get planet information

	Get information on a planet

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param planetId
	@return ApiGetUniversePlanetsPlanetIdRequest
	*/
	GetUniversePlanetsPlanetId(ctx context.Context, planetId int64) ApiGetUniversePlanetsPlanetIdRequest

	// GetUniversePlanetsPlanetIdExecute executes the request
	//  @return UniversePlanetsPlanetIdGet
	GetUniversePlanetsPlanetIdExecute(r ApiGetUniversePlanetsPlanetIdRequest) (*UniversePlanetsPlanetIdGet, *http.Response, error)

	/*
	GetUniverseRaces Get character races

	Get a list of character races

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUniverseRacesRequest
	*/
	GetUniverseRaces(ctx context.Context) ApiGetUniverseRacesRequest

	// GetUniverseRacesExecute executes the request
	//  @return []UniverseRacesGetInner
	GetUniverseRacesExecute(r ApiGetUniverseRacesRequest) ([]UniverseRacesGetInner, *http.Response, error)

	/*
	GetUniverseRegions Get regions

	Get a list of regions

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUniverseRegionsRequest
	*/
	GetUniverseRegions(ctx context.Context) ApiGetUniverseRegionsRequest

	// GetUniverseRegionsExecute executes the request
	//  @return []int64
	GetUniverseRegionsExecute(r ApiGetUniverseRegionsRequest) ([]int64, *http.Response, error)

	/*
	GetUniverseRegionsRegionId Get region information

	Get information on a region

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param regionId
	@return ApiGetUniverseRegionsRegionIdRequest
	*/
	GetUniverseRegionsRegionId(ctx context.Context, regionId int64) ApiGetUniverseRegionsRegionIdRequest

	// GetUniverseRegionsRegionIdExecute executes the request
	//  @return UniverseRegionsRegionIdGet
	GetUniverseRegionsRegionIdExecute(r ApiGetUniverseRegionsRegionIdRequest) (*UniverseRegionsRegionIdGet, *http.Response, error)

	/*
	GetUniverseStargatesStargateId Get stargate information

	Get information on a stargate

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stargateId
	@return ApiGetUniverseStargatesStargateIdRequest
	*/
	GetUniverseStargatesStargateId(ctx context.Context, stargateId int64) ApiGetUniverseStargatesStargateIdRequest

	// GetUniverseStargatesStargateIdExecute executes the request
	//  @return UniverseStargatesStargateIdGet
	GetUniverseStargatesStargateIdExecute(r ApiGetUniverseStargatesStargateIdRequest) (*UniverseStargatesStargateIdGet, *http.Response, error)

	/*
	GetUniverseStarsStarId Get star information

	Get information on a star

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param starId
	@return ApiGetUniverseStarsStarIdRequest
	*/
	GetUniverseStarsStarId(ctx context.Context, starId int64) ApiGetUniverseStarsStarIdRequest

	// GetUniverseStarsStarIdExecute executes the request
	//  @return UniverseStarsStarIdGet
	GetUniverseStarsStarIdExecute(r ApiGetUniverseStarsStarIdRequest) (*UniverseStarsStarIdGet, *http.Response, error)

	/*
	GetUniverseStationsStationId Get station information

	Get information on a station

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stationId
	@return ApiGetUniverseStationsStationIdRequest
	*/
	GetUniverseStationsStationId(ctx context.Context, stationId int64) ApiGetUniverseStationsStationIdRequest

	// GetUniverseStationsStationIdExecute executes the request
	//  @return UniverseStationsStationIdGet
	GetUniverseStationsStationIdExecute(r ApiGetUniverseStationsStationIdRequest) (*UniverseStationsStationIdGet, *http.Response, error)

	/*
	GetUniverseStructures List all public structures

	List all public structures

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUniverseStructuresRequest
	*/
	GetUniverseStructures(ctx context.Context) ApiGetUniverseStructuresRequest

	// GetUniverseStructuresExecute executes the request
	//  @return []int64
	GetUniverseStructuresExecute(r ApiGetUniverseStructuresRequest) ([]int64, *http.Response, error)

	/*
	GetUniverseStructuresStructureId Get structure information

	Returns information on requested structure if you are on the ACL. Otherwise, returns "Forbidden" for all inputs.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param structureId
	@return ApiGetUniverseStructuresStructureIdRequest
	*/
	GetUniverseStructuresStructureId(ctx context.Context, structureId int64) ApiGetUniverseStructuresStructureIdRequest

	// GetUniverseStructuresStructureIdExecute executes the request
	//  @return UniverseStructuresStructureIdGet
	GetUniverseStructuresStructureIdExecute(r ApiGetUniverseStructuresStructureIdRequest) (*UniverseStructuresStructureIdGet, *http.Response, error)

	/*
	GetUniverseSystemJumps Get system jumps

	Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUniverseSystemJumpsRequest
	*/
	GetUniverseSystemJumps(ctx context.Context) ApiGetUniverseSystemJumpsRequest

	// GetUniverseSystemJumpsExecute executes the request
	//  @return []UniverseSystemJumpsGetInner
	GetUniverseSystemJumpsExecute(r ApiGetUniverseSystemJumpsRequest) ([]UniverseSystemJumpsGetInner, *http.Response, error)

	/*
	GetUniverseSystemKills Get system kills

	Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUniverseSystemKillsRequest
	*/
	GetUniverseSystemKills(ctx context.Context) ApiGetUniverseSystemKillsRequest

	// GetUniverseSystemKillsExecute executes the request
	//  @return []UniverseSystemKillsGetInner
	GetUniverseSystemKillsExecute(r ApiGetUniverseSystemKillsRequest) ([]UniverseSystemKillsGetInner, *http.Response, error)

	/*
	GetUniverseSystems Get solar systems

	Get a list of solar systems

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUniverseSystemsRequest
	*/
	GetUniverseSystems(ctx context.Context) ApiGetUniverseSystemsRequest

	// GetUniverseSystemsExecute executes the request
	//  @return []int64
	GetUniverseSystemsExecute(r ApiGetUniverseSystemsRequest) ([]int64, *http.Response, error)

	/*
	GetUniverseSystemsSystemId Get solar system information

	Get information on a solar system.

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiGetUniverseSystemsSystemIdRequest
	*/
	GetUniverseSystemsSystemId(ctx context.Context, systemId int64) ApiGetUniverseSystemsSystemIdRequest

	// GetUniverseSystemsSystemIdExecute executes the request
	//  @return UniverseSystemsSystemIdGet
	GetUniverseSystemsSystemIdExecute(r ApiGetUniverseSystemsSystemIdRequest) (*UniverseSystemsSystemIdGet, *http.Response, error)

	/*
	GetUniverseTypes Get types

	Get a list of type ids

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUniverseTypesRequest
	*/
	GetUniverseTypes(ctx context.Context) ApiGetUniverseTypesRequest

	// GetUniverseTypesExecute executes the request
	//  @return []int64
	GetUniverseTypesExecute(r ApiGetUniverseTypesRequest) ([]int64, *http.Response, error)

	/*
	GetUniverseTypesTypeId Get type information

	Get information on a type

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param typeId
	@return ApiGetUniverseTypesTypeIdRequest
	*/
	GetUniverseTypesTypeId(ctx context.Context, typeId int64) ApiGetUniverseTypesTypeIdRequest

	// GetUniverseTypesTypeIdExecute executes the request
	//  @return UniverseTypesTypeIdGet
	GetUniverseTypesTypeIdExecute(r ApiGetUniverseTypesTypeIdRequest) (*UniverseTypesTypeIdGet, *http.Response, error)

	/*
	PostUniverseIds Bulk names to IDs

	Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUniverseIdsRequest
	*/
	PostUniverseIds(ctx context.Context) ApiPostUniverseIdsRequest

	// PostUniverseIdsExecute executes the request
	//  @return UniverseIdsPost
	PostUniverseIdsExecute(r ApiPostUniverseIdsRequest) (*UniverseIdsPost, *http.Response, error)

	/*
	PostUniverseNames Get names and categories for a set of IDs

	Resolve a set of IDs to names and categories. Supported ID's for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types, Factions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUniverseNamesRequest
	*/
	PostUniverseNames(ctx context.Context) ApiPostUniverseNamesRequest

	// PostUniverseNamesExecute executes the request
	//  @return []UniverseNamesPostInner
	PostUniverseNamesExecute(r ApiPostUniverseNamesRequest) ([]UniverseNamesPostInner, *http.Response, error)
}

// UniverseAPIService UniverseAPI service
type UniverseAPIService service

type ApiGetUniverseAncestriesRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseAncestriesRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseAncestriesRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseAncestriesRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseAncestriesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseAncestriesRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseAncestriesRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseAncestriesRequest) XTenant(xTenant string) ApiGetUniverseAncestriesRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseAncestriesRequest) Execute() ([]UniverseAncestriesGetInner, *http.Response, error) {
	return r.ApiService.GetUniverseAncestriesExecute(r)
}

/*
GetUniverseAncestries Get ancestries

Get all character ancestries

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUniverseAncestriesRequest
*/
func (a *UniverseAPIService) GetUniverseAncestries(ctx context.Context) ApiGetUniverseAncestriesRequest {
	return ApiGetUniverseAncestriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniverseAncestriesGetInner
func (a *UniverseAPIService) GetUniverseAncestriesExecute(r ApiGetUniverseAncestriesRequest) ([]UniverseAncestriesGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniverseAncestriesGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseAncestries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/ancestries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseAsteroidBeltsAsteroidBeltIdRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	asteroidBeltId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseAsteroidBeltsAsteroidBeltIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseAsteroidBeltsAsteroidBeltIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseAsteroidBeltsAsteroidBeltIdRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseAsteroidBeltsAsteroidBeltIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseAsteroidBeltsAsteroidBeltIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseAsteroidBeltsAsteroidBeltIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseAsteroidBeltsAsteroidBeltIdRequest) XTenant(xTenant string) ApiGetUniverseAsteroidBeltsAsteroidBeltIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseAsteroidBeltsAsteroidBeltIdRequest) Execute() (*UniverseAsteroidBeltsAsteroidBeltIdGet, *http.Response, error) {
	return r.ApiService.GetUniverseAsteroidBeltsAsteroidBeltIdExecute(r)
}

/*
GetUniverseAsteroidBeltsAsteroidBeltId Get asteroid belt information

Get information on an asteroid belt

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param asteroidBeltId
 @return ApiGetUniverseAsteroidBeltsAsteroidBeltIdRequest
*/
func (a *UniverseAPIService) GetUniverseAsteroidBeltsAsteroidBeltId(ctx context.Context, asteroidBeltId int64) ApiGetUniverseAsteroidBeltsAsteroidBeltIdRequest {
	return ApiGetUniverseAsteroidBeltsAsteroidBeltIdRequest{
		ApiService: a,
		ctx: ctx,
		asteroidBeltId: asteroidBeltId,
	}
}

// Execute executes the request
//  @return UniverseAsteroidBeltsAsteroidBeltIdGet
func (a *UniverseAPIService) GetUniverseAsteroidBeltsAsteroidBeltIdExecute(r ApiGetUniverseAsteroidBeltsAsteroidBeltIdRequest) (*UniverseAsteroidBeltsAsteroidBeltIdGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UniverseAsteroidBeltsAsteroidBeltIdGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseAsteroidBeltsAsteroidBeltId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/asteroid_belts/{asteroid_belt_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"asteroid_belt_id"+"}", url.PathEscape(parameterValueToString(r.asteroidBeltId, "asteroidBeltId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseBloodlinesRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseBloodlinesRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseBloodlinesRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseBloodlinesRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseBloodlinesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseBloodlinesRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseBloodlinesRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseBloodlinesRequest) XTenant(xTenant string) ApiGetUniverseBloodlinesRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseBloodlinesRequest) Execute() ([]UniverseBloodlinesGetInner, *http.Response, error) {
	return r.ApiService.GetUniverseBloodlinesExecute(r)
}

/*
GetUniverseBloodlines Get bloodlines

Get a list of bloodlines

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUniverseBloodlinesRequest
*/
func (a *UniverseAPIService) GetUniverseBloodlines(ctx context.Context) ApiGetUniverseBloodlinesRequest {
	return ApiGetUniverseBloodlinesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniverseBloodlinesGetInner
func (a *UniverseAPIService) GetUniverseBloodlinesExecute(r ApiGetUniverseBloodlinesRequest) ([]UniverseBloodlinesGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniverseBloodlinesGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseBloodlines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/bloodlines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseCategoriesRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseCategoriesRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseCategoriesRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseCategoriesRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseCategoriesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseCategoriesRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseCategoriesRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseCategoriesRequest) XTenant(xTenant string) ApiGetUniverseCategoriesRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseCategoriesRequest) Execute() ([]int64, *http.Response, error) {
	return r.ApiService.GetUniverseCategoriesExecute(r)
}

/*
GetUniverseCategories Get item categories

Get a list of item categories

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUniverseCategoriesRequest
*/
func (a *UniverseAPIService) GetUniverseCategories(ctx context.Context) ApiGetUniverseCategoriesRequest {
	return ApiGetUniverseCategoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []int64
func (a *UniverseAPIService) GetUniverseCategoriesExecute(r ApiGetUniverseCategoriesRequest) ([]int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/categories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseCategoriesCategoryIdRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	categoryId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseCategoriesCategoryIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseCategoriesCategoryIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseCategoriesCategoryIdRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseCategoriesCategoryIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseCategoriesCategoryIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseCategoriesCategoryIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseCategoriesCategoryIdRequest) XTenant(xTenant string) ApiGetUniverseCategoriesCategoryIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseCategoriesCategoryIdRequest) Execute() (*UniverseCategoriesCategoryIdGet, *http.Response, error) {
	return r.ApiService.GetUniverseCategoriesCategoryIdExecute(r)
}

/*
GetUniverseCategoriesCategoryId Get item category information

Get information of an item category

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param categoryId
 @return ApiGetUniverseCategoriesCategoryIdRequest
*/
func (a *UniverseAPIService) GetUniverseCategoriesCategoryId(ctx context.Context, categoryId int64) ApiGetUniverseCategoriesCategoryIdRequest {
	return ApiGetUniverseCategoriesCategoryIdRequest{
		ApiService: a,
		ctx: ctx,
		categoryId: categoryId,
	}
}

// Execute executes the request
//  @return UniverseCategoriesCategoryIdGet
func (a *UniverseAPIService) GetUniverseCategoriesCategoryIdExecute(r ApiGetUniverseCategoriesCategoryIdRequest) (*UniverseCategoriesCategoryIdGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UniverseCategoriesCategoryIdGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseCategoriesCategoryId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/categories/{category_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"category_id"+"}", url.PathEscape(parameterValueToString(r.categoryId, "categoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseConstellationsRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseConstellationsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseConstellationsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseConstellationsRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseConstellationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseConstellationsRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseConstellationsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseConstellationsRequest) XTenant(xTenant string) ApiGetUniverseConstellationsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseConstellationsRequest) Execute() ([]int64, *http.Response, error) {
	return r.ApiService.GetUniverseConstellationsExecute(r)
}

/*
GetUniverseConstellations Get constellations

Get a list of constellations

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUniverseConstellationsRequest
*/
func (a *UniverseAPIService) GetUniverseConstellations(ctx context.Context) ApiGetUniverseConstellationsRequest {
	return ApiGetUniverseConstellationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []int64
func (a *UniverseAPIService) GetUniverseConstellationsExecute(r ApiGetUniverseConstellationsRequest) ([]int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseConstellations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/constellations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseConstellationsConstellationIdRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	constellationId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseConstellationsConstellationIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseConstellationsConstellationIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseConstellationsConstellationIdRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseConstellationsConstellationIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseConstellationsConstellationIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseConstellationsConstellationIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseConstellationsConstellationIdRequest) XTenant(xTenant string) ApiGetUniverseConstellationsConstellationIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseConstellationsConstellationIdRequest) Execute() (*UniverseConstellationsConstellationIdGet, *http.Response, error) {
	return r.ApiService.GetUniverseConstellationsConstellationIdExecute(r)
}

/*
GetUniverseConstellationsConstellationId Get constellation information

Get information on a constellation

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param constellationId
 @return ApiGetUniverseConstellationsConstellationIdRequest
*/
func (a *UniverseAPIService) GetUniverseConstellationsConstellationId(ctx context.Context, constellationId int64) ApiGetUniverseConstellationsConstellationIdRequest {
	return ApiGetUniverseConstellationsConstellationIdRequest{
		ApiService: a,
		ctx: ctx,
		constellationId: constellationId,
	}
}

// Execute executes the request
//  @return UniverseConstellationsConstellationIdGet
func (a *UniverseAPIService) GetUniverseConstellationsConstellationIdExecute(r ApiGetUniverseConstellationsConstellationIdRequest) (*UniverseConstellationsConstellationIdGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UniverseConstellationsConstellationIdGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseConstellationsConstellationId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/constellations/{constellation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"constellation_id"+"}", url.PathEscape(parameterValueToString(r.constellationId, "constellationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseFactionsRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseFactionsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseFactionsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseFactionsRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseFactionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseFactionsRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseFactionsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseFactionsRequest) XTenant(xTenant string) ApiGetUniverseFactionsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseFactionsRequest) Execute() ([]UniverseFactionsGetInner, *http.Response, error) {
	return r.ApiService.GetUniverseFactionsExecute(r)
}

/*
GetUniverseFactions Get factions

Get a list of factions

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUniverseFactionsRequest
*/
func (a *UniverseAPIService) GetUniverseFactions(ctx context.Context) ApiGetUniverseFactionsRequest {
	return ApiGetUniverseFactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniverseFactionsGetInner
func (a *UniverseAPIService) GetUniverseFactionsExecute(r ApiGetUniverseFactionsRequest) ([]UniverseFactionsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniverseFactionsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseFactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/factions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseGraphicsRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseGraphicsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseGraphicsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseGraphicsRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseGraphicsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseGraphicsRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseGraphicsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseGraphicsRequest) XTenant(xTenant string) ApiGetUniverseGraphicsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseGraphicsRequest) Execute() ([]int64, *http.Response, error) {
	return r.ApiService.GetUniverseGraphicsExecute(r)
}

/*
GetUniverseGraphics Get graphics

Get a list of graphics

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUniverseGraphicsRequest
*/
func (a *UniverseAPIService) GetUniverseGraphics(ctx context.Context) ApiGetUniverseGraphicsRequest {
	return ApiGetUniverseGraphicsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []int64
func (a *UniverseAPIService) GetUniverseGraphicsExecute(r ApiGetUniverseGraphicsRequest) ([]int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseGraphics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/graphics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseGraphicsGraphicIdRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	graphicId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseGraphicsGraphicIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseGraphicsGraphicIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseGraphicsGraphicIdRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseGraphicsGraphicIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseGraphicsGraphicIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseGraphicsGraphicIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseGraphicsGraphicIdRequest) XTenant(xTenant string) ApiGetUniverseGraphicsGraphicIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseGraphicsGraphicIdRequest) Execute() (*UniverseGraphicsGraphicIdGet, *http.Response, error) {
	return r.ApiService.GetUniverseGraphicsGraphicIdExecute(r)
}

/*
GetUniverseGraphicsGraphicId Get graphic information

Get information on a graphic

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param graphicId
 @return ApiGetUniverseGraphicsGraphicIdRequest
*/
func (a *UniverseAPIService) GetUniverseGraphicsGraphicId(ctx context.Context, graphicId int64) ApiGetUniverseGraphicsGraphicIdRequest {
	return ApiGetUniverseGraphicsGraphicIdRequest{
		ApiService: a,
		ctx: ctx,
		graphicId: graphicId,
	}
}

// Execute executes the request
//  @return UniverseGraphicsGraphicIdGet
func (a *UniverseAPIService) GetUniverseGraphicsGraphicIdExecute(r ApiGetUniverseGraphicsGraphicIdRequest) (*UniverseGraphicsGraphicIdGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UniverseGraphicsGraphicIdGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseGraphicsGraphicId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/graphics/{graphic_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"graphic_id"+"}", url.PathEscape(parameterValueToString(r.graphicId, "graphicId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseGroupsRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseGroupsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseGroupsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetUniverseGroupsRequest) Page(page int32) ApiGetUniverseGroupsRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetUniverseGroupsRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseGroupsRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseGroupsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseGroupsRequest) XTenant(xTenant string) ApiGetUniverseGroupsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseGroupsRequest) Execute() ([]int64, *http.Response, error) {
	return r.ApiService.GetUniverseGroupsExecute(r)
}

/*
GetUniverseGroups Get item groups

Get a list of item groups

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUniverseGroupsRequest
*/
func (a *UniverseAPIService) GetUniverseGroups(ctx context.Context) ApiGetUniverseGroupsRequest {
	return ApiGetUniverseGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []int64
func (a *UniverseAPIService) GetUniverseGroupsExecute(r ApiGetUniverseGroupsRequest) ([]int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseGroupsGroupIdRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	groupId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseGroupsGroupIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseGroupsGroupIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseGroupsGroupIdRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseGroupsGroupIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseGroupsGroupIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseGroupsGroupIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseGroupsGroupIdRequest) XTenant(xTenant string) ApiGetUniverseGroupsGroupIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseGroupsGroupIdRequest) Execute() (*UniverseGroupsGroupIdGet, *http.Response, error) {
	return r.ApiService.GetUniverseGroupsGroupIdExecute(r)
}

/*
GetUniverseGroupsGroupId Get item group information

Get information on an item group

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId
 @return ApiGetUniverseGroupsGroupIdRequest
*/
func (a *UniverseAPIService) GetUniverseGroupsGroupId(ctx context.Context, groupId int64) ApiGetUniverseGroupsGroupIdRequest {
	return ApiGetUniverseGroupsGroupIdRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return UniverseGroupsGroupIdGet
func (a *UniverseAPIService) GetUniverseGroupsGroupIdExecute(r ApiGetUniverseGroupsGroupIdRequest) (*UniverseGroupsGroupIdGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UniverseGroupsGroupIdGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseGroupsGroupId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/groups/{group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseMoonsMoonIdRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	moonId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseMoonsMoonIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseMoonsMoonIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseMoonsMoonIdRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseMoonsMoonIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseMoonsMoonIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseMoonsMoonIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseMoonsMoonIdRequest) XTenant(xTenant string) ApiGetUniverseMoonsMoonIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseMoonsMoonIdRequest) Execute() (*UniverseMoonsMoonIdGet, *http.Response, error) {
	return r.ApiService.GetUniverseMoonsMoonIdExecute(r)
}

/*
GetUniverseMoonsMoonId Get moon information

Get information on a moon

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param moonId
 @return ApiGetUniverseMoonsMoonIdRequest
*/
func (a *UniverseAPIService) GetUniverseMoonsMoonId(ctx context.Context, moonId int64) ApiGetUniverseMoonsMoonIdRequest {
	return ApiGetUniverseMoonsMoonIdRequest{
		ApiService: a,
		ctx: ctx,
		moonId: moonId,
	}
}

// Execute executes the request
//  @return UniverseMoonsMoonIdGet
func (a *UniverseAPIService) GetUniverseMoonsMoonIdExecute(r ApiGetUniverseMoonsMoonIdRequest) (*UniverseMoonsMoonIdGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UniverseMoonsMoonIdGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseMoonsMoonId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/moons/{moon_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"moon_id"+"}", url.PathEscape(parameterValueToString(r.moonId, "moonId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniversePlanetsPlanetIdRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	planetId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniversePlanetsPlanetIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniversePlanetsPlanetIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniversePlanetsPlanetIdRequest) AcceptLanguage(acceptLanguage string) ApiGetUniversePlanetsPlanetIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniversePlanetsPlanetIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniversePlanetsPlanetIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniversePlanetsPlanetIdRequest) XTenant(xTenant string) ApiGetUniversePlanetsPlanetIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniversePlanetsPlanetIdRequest) Execute() (*UniversePlanetsPlanetIdGet, *http.Response, error) {
	return r.ApiService.GetUniversePlanetsPlanetIdExecute(r)
}

/*
GetUniversePlanetsPlanetId Get planet information

Get information on a planet

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param planetId
 @return ApiGetUniversePlanetsPlanetIdRequest
*/
func (a *UniverseAPIService) GetUniversePlanetsPlanetId(ctx context.Context, planetId int64) ApiGetUniversePlanetsPlanetIdRequest {
	return ApiGetUniversePlanetsPlanetIdRequest{
		ApiService: a,
		ctx: ctx,
		planetId: planetId,
	}
}

// Execute executes the request
//  @return UniversePlanetsPlanetIdGet
func (a *UniverseAPIService) GetUniversePlanetsPlanetIdExecute(r ApiGetUniversePlanetsPlanetIdRequest) (*UniversePlanetsPlanetIdGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UniversePlanetsPlanetIdGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniversePlanetsPlanetId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/planets/{planet_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"planet_id"+"}", url.PathEscape(parameterValueToString(r.planetId, "planetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseRacesRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseRacesRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseRacesRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseRacesRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseRacesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseRacesRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseRacesRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseRacesRequest) XTenant(xTenant string) ApiGetUniverseRacesRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseRacesRequest) Execute() ([]UniverseRacesGetInner, *http.Response, error) {
	return r.ApiService.GetUniverseRacesExecute(r)
}

/*
GetUniverseRaces Get character races

Get a list of character races

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUniverseRacesRequest
*/
func (a *UniverseAPIService) GetUniverseRaces(ctx context.Context) ApiGetUniverseRacesRequest {
	return ApiGetUniverseRacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniverseRacesGetInner
func (a *UniverseAPIService) GetUniverseRacesExecute(r ApiGetUniverseRacesRequest) ([]UniverseRacesGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniverseRacesGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseRaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/races"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseRegionsRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseRegionsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseRegionsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseRegionsRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseRegionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseRegionsRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseRegionsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseRegionsRequest) XTenant(xTenant string) ApiGetUniverseRegionsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseRegionsRequest) Execute() ([]int64, *http.Response, error) {
	return r.ApiService.GetUniverseRegionsExecute(r)
}

/*
GetUniverseRegions Get regions

Get a list of regions

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUniverseRegionsRequest
*/
func (a *UniverseAPIService) GetUniverseRegions(ctx context.Context) ApiGetUniverseRegionsRequest {
	return ApiGetUniverseRegionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []int64
func (a *UniverseAPIService) GetUniverseRegionsExecute(r ApiGetUniverseRegionsRequest) ([]int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseRegions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/regions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseRegionsRegionIdRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	regionId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseRegionsRegionIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseRegionsRegionIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseRegionsRegionIdRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseRegionsRegionIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseRegionsRegionIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseRegionsRegionIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseRegionsRegionIdRequest) XTenant(xTenant string) ApiGetUniverseRegionsRegionIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseRegionsRegionIdRequest) Execute() (*UniverseRegionsRegionIdGet, *http.Response, error) {
	return r.ApiService.GetUniverseRegionsRegionIdExecute(r)
}

/*
GetUniverseRegionsRegionId Get region information

Get information on a region

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param regionId
 @return ApiGetUniverseRegionsRegionIdRequest
*/
func (a *UniverseAPIService) GetUniverseRegionsRegionId(ctx context.Context, regionId int64) ApiGetUniverseRegionsRegionIdRequest {
	return ApiGetUniverseRegionsRegionIdRequest{
		ApiService: a,
		ctx: ctx,
		regionId: regionId,
	}
}

// Execute executes the request
//  @return UniverseRegionsRegionIdGet
func (a *UniverseAPIService) GetUniverseRegionsRegionIdExecute(r ApiGetUniverseRegionsRegionIdRequest) (*UniverseRegionsRegionIdGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UniverseRegionsRegionIdGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseRegionsRegionId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/regions/{region_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"region_id"+"}", url.PathEscape(parameterValueToString(r.regionId, "regionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseStargatesStargateIdRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	stargateId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseStargatesStargateIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseStargatesStargateIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseStargatesStargateIdRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseStargatesStargateIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseStargatesStargateIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseStargatesStargateIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseStargatesStargateIdRequest) XTenant(xTenant string) ApiGetUniverseStargatesStargateIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseStargatesStargateIdRequest) Execute() (*UniverseStargatesStargateIdGet, *http.Response, error) {
	return r.ApiService.GetUniverseStargatesStargateIdExecute(r)
}

/*
GetUniverseStargatesStargateId Get stargate information

Get information on a stargate

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param stargateId
 @return ApiGetUniverseStargatesStargateIdRequest
*/
func (a *UniverseAPIService) GetUniverseStargatesStargateId(ctx context.Context, stargateId int64) ApiGetUniverseStargatesStargateIdRequest {
	return ApiGetUniverseStargatesStargateIdRequest{
		ApiService: a,
		ctx: ctx,
		stargateId: stargateId,
	}
}

// Execute executes the request
//  @return UniverseStargatesStargateIdGet
func (a *UniverseAPIService) GetUniverseStargatesStargateIdExecute(r ApiGetUniverseStargatesStargateIdRequest) (*UniverseStargatesStargateIdGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UniverseStargatesStargateIdGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseStargatesStargateId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/stargates/{stargate_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"stargate_id"+"}", url.PathEscape(parameterValueToString(r.stargateId, "stargateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseStarsStarIdRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	starId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseStarsStarIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseStarsStarIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseStarsStarIdRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseStarsStarIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseStarsStarIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseStarsStarIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseStarsStarIdRequest) XTenant(xTenant string) ApiGetUniverseStarsStarIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseStarsStarIdRequest) Execute() (*UniverseStarsStarIdGet, *http.Response, error) {
	return r.ApiService.GetUniverseStarsStarIdExecute(r)
}

/*
GetUniverseStarsStarId Get star information

Get information on a star

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param starId
 @return ApiGetUniverseStarsStarIdRequest
*/
func (a *UniverseAPIService) GetUniverseStarsStarId(ctx context.Context, starId int64) ApiGetUniverseStarsStarIdRequest {
	return ApiGetUniverseStarsStarIdRequest{
		ApiService: a,
		ctx: ctx,
		starId: starId,
	}
}

// Execute executes the request
//  @return UniverseStarsStarIdGet
func (a *UniverseAPIService) GetUniverseStarsStarIdExecute(r ApiGetUniverseStarsStarIdRequest) (*UniverseStarsStarIdGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UniverseStarsStarIdGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseStarsStarId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/stars/{star_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"star_id"+"}", url.PathEscape(parameterValueToString(r.starId, "starId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseStationsStationIdRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	stationId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseStationsStationIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseStationsStationIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseStationsStationIdRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseStationsStationIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseStationsStationIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseStationsStationIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseStationsStationIdRequest) XTenant(xTenant string) ApiGetUniverseStationsStationIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseStationsStationIdRequest) Execute() (*UniverseStationsStationIdGet, *http.Response, error) {
	return r.ApiService.GetUniverseStationsStationIdExecute(r)
}

/*
GetUniverseStationsStationId Get station information

Get information on a station

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param stationId
 @return ApiGetUniverseStationsStationIdRequest
*/
func (a *UniverseAPIService) GetUniverseStationsStationId(ctx context.Context, stationId int64) ApiGetUniverseStationsStationIdRequest {
	return ApiGetUniverseStationsStationIdRequest{
		ApiService: a,
		ctx: ctx,
		stationId: stationId,
	}
}

// Execute executes the request
//  @return UniverseStationsStationIdGet
func (a *UniverseAPIService) GetUniverseStationsStationIdExecute(r ApiGetUniverseStationsStationIdRequest) (*UniverseStationsStationIdGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UniverseStationsStationIdGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseStationsStationId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/stations/{station_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"station_id"+"}", url.PathEscape(parameterValueToString(r.stationId, "stationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseStructuresRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	xCompatibilityDate *string
	filter *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseStructuresRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseStructuresRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetUniverseStructuresRequest) Filter(filter string) ApiGetUniverseStructuresRequest {
	r.filter = &filter
	return r
}

// The language to use for the response.
func (r ApiGetUniverseStructuresRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseStructuresRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseStructuresRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseStructuresRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseStructuresRequest) XTenant(xTenant string) ApiGetUniverseStructuresRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseStructuresRequest) Execute() ([]int64, *http.Response, error) {
	return r.ApiService.GetUniverseStructuresExecute(r)
}

/*
GetUniverseStructures List all public structures

List all public structures

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUniverseStructuresRequest
*/
func (a *UniverseAPIService) GetUniverseStructures(ctx context.Context) ApiGetUniverseStructuresRequest {
	return ApiGetUniverseStructuresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []int64
func (a *UniverseAPIService) GetUniverseStructuresExecute(r ApiGetUniverseStructuresRequest) ([]int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseStructures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/structures"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseStructuresStructureIdRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	structureId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseStructuresStructureIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseStructuresStructureIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseStructuresStructureIdRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseStructuresStructureIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseStructuresStructureIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseStructuresStructureIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseStructuresStructureIdRequest) XTenant(xTenant string) ApiGetUniverseStructuresStructureIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseStructuresStructureIdRequest) Execute() (*UniverseStructuresStructureIdGet, *http.Response, error) {
	return r.ApiService.GetUniverseStructuresStructureIdExecute(r)
}

/*
GetUniverseStructuresStructureId Get structure information

Returns information on requested structure if you are on the ACL. Otherwise, returns "Forbidden" for all inputs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param structureId
 @return ApiGetUniverseStructuresStructureIdRequest
*/
func (a *UniverseAPIService) GetUniverseStructuresStructureId(ctx context.Context, structureId int64) ApiGetUniverseStructuresStructureIdRequest {
	return ApiGetUniverseStructuresStructureIdRequest{
		ApiService: a,
		ctx: ctx,
		structureId: structureId,
	}
}

// Execute executes the request
//  @return UniverseStructuresStructureIdGet
func (a *UniverseAPIService) GetUniverseStructuresStructureIdExecute(r ApiGetUniverseStructuresStructureIdRequest) (*UniverseStructuresStructureIdGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UniverseStructuresStructureIdGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseStructuresStructureId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/structures/{structure_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"structure_id"+"}", url.PathEscape(parameterValueToString(r.structureId, "structureId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseSystemJumpsRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseSystemJumpsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseSystemJumpsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseSystemJumpsRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseSystemJumpsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseSystemJumpsRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseSystemJumpsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseSystemJumpsRequest) XTenant(xTenant string) ApiGetUniverseSystemJumpsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseSystemJumpsRequest) Execute() ([]UniverseSystemJumpsGetInner, *http.Response, error) {
	return r.ApiService.GetUniverseSystemJumpsExecute(r)
}

/*
GetUniverseSystemJumps Get system jumps

Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUniverseSystemJumpsRequest
*/
func (a *UniverseAPIService) GetUniverseSystemJumps(ctx context.Context) ApiGetUniverseSystemJumpsRequest {
	return ApiGetUniverseSystemJumpsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniverseSystemJumpsGetInner
func (a *UniverseAPIService) GetUniverseSystemJumpsExecute(r ApiGetUniverseSystemJumpsRequest) ([]UniverseSystemJumpsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniverseSystemJumpsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseSystemJumps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/system_jumps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseSystemKillsRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseSystemKillsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseSystemKillsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseSystemKillsRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseSystemKillsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseSystemKillsRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseSystemKillsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseSystemKillsRequest) XTenant(xTenant string) ApiGetUniverseSystemKillsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseSystemKillsRequest) Execute() ([]UniverseSystemKillsGetInner, *http.Response, error) {
	return r.ApiService.GetUniverseSystemKillsExecute(r)
}

/*
GetUniverseSystemKills Get system kills

Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUniverseSystemKillsRequest
*/
func (a *UniverseAPIService) GetUniverseSystemKills(ctx context.Context) ApiGetUniverseSystemKillsRequest {
	return ApiGetUniverseSystemKillsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniverseSystemKillsGetInner
func (a *UniverseAPIService) GetUniverseSystemKillsExecute(r ApiGetUniverseSystemKillsRequest) ([]UniverseSystemKillsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniverseSystemKillsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseSystemKills")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/system_kills"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseSystemsRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseSystemsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseSystemsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseSystemsRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseSystemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseSystemsRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseSystemsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseSystemsRequest) XTenant(xTenant string) ApiGetUniverseSystemsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseSystemsRequest) Execute() ([]int64, *http.Response, error) {
	return r.ApiService.GetUniverseSystemsExecute(r)
}

/*
GetUniverseSystems Get solar systems

Get a list of solar systems

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUniverseSystemsRequest
*/
func (a *UniverseAPIService) GetUniverseSystems(ctx context.Context) ApiGetUniverseSystemsRequest {
	return ApiGetUniverseSystemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []int64
func (a *UniverseAPIService) GetUniverseSystemsExecute(r ApiGetUniverseSystemsRequest) ([]int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseSystems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/systems"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseSystemsSystemIdRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	systemId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseSystemsSystemIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseSystemsSystemIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseSystemsSystemIdRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseSystemsSystemIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseSystemsSystemIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseSystemsSystemIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseSystemsSystemIdRequest) XTenant(xTenant string) ApiGetUniverseSystemsSystemIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseSystemsSystemIdRequest) Execute() (*UniverseSystemsSystemIdGet, *http.Response, error) {
	return r.ApiService.GetUniverseSystemsSystemIdExecute(r)
}

/*
GetUniverseSystemsSystemId Get solar system information

Get information on a solar system.

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param systemId
 @return ApiGetUniverseSystemsSystemIdRequest
*/
func (a *UniverseAPIService) GetUniverseSystemsSystemId(ctx context.Context, systemId int64) ApiGetUniverseSystemsSystemIdRequest {
	return ApiGetUniverseSystemsSystemIdRequest{
		ApiService: a,
		ctx: ctx,
		systemId: systemId,
	}
}

// Execute executes the request
//  @return UniverseSystemsSystemIdGet
func (a *UniverseAPIService) GetUniverseSystemsSystemIdExecute(r ApiGetUniverseSystemsSystemIdRequest) (*UniverseSystemsSystemIdGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UniverseSystemsSystemIdGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseSystemsSystemId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/systems/{system_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"system_id"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseTypesRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseTypesRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseTypesRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetUniverseTypesRequest) Page(page int32) ApiGetUniverseTypesRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetUniverseTypesRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseTypesRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseTypesRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseTypesRequest) XTenant(xTenant string) ApiGetUniverseTypesRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseTypesRequest) Execute() ([]int64, *http.Response, error) {
	return r.ApiService.GetUniverseTypesExecute(r)
}

/*
GetUniverseTypes Get types

Get a list of type ids

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUniverseTypesRequest
*/
func (a *UniverseAPIService) GetUniverseTypes(ctx context.Context) ApiGetUniverseTypesRequest {
	return ApiGetUniverseTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []int64
func (a *UniverseAPIService) GetUniverseTypesExecute(r ApiGetUniverseTypesRequest) ([]int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniverseTypesTypeIdRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	typeId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetUniverseTypesTypeIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetUniverseTypesTypeIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetUniverseTypesTypeIdRequest) AcceptLanguage(acceptLanguage string) ApiGetUniverseTypesTypeIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetUniverseTypesTypeIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetUniverseTypesTypeIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetUniverseTypesTypeIdRequest) XTenant(xTenant string) ApiGetUniverseTypesTypeIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetUniverseTypesTypeIdRequest) Execute() (*UniverseTypesTypeIdGet, *http.Response, error) {
	return r.ApiService.GetUniverseTypesTypeIdExecute(r)
}

/*
GetUniverseTypesTypeId Get type information

Get information on a type

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param typeId
 @return ApiGetUniverseTypesTypeIdRequest
*/
func (a *UniverseAPIService) GetUniverseTypesTypeId(ctx context.Context, typeId int64) ApiGetUniverseTypesTypeIdRequest {
	return ApiGetUniverseTypesTypeIdRequest{
		ApiService: a,
		ctx: ctx,
		typeId: typeId,
	}
}

// Execute executes the request
//  @return UniverseTypesTypeIdGet
func (a *UniverseAPIService) GetUniverseTypesTypeIdExecute(r ApiGetUniverseTypesTypeIdRequest) (*UniverseTypesTypeIdGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UniverseTypesTypeIdGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.GetUniverseTypesTypeId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/types/{type_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"type_id"+"}", url.PathEscape(parameterValueToString(r.typeId, "typeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUniverseIdsRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	xCompatibilityDate *string
	requestBody *[]string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiPostUniverseIdsRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostUniverseIdsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiPostUniverseIdsRequest) RequestBody(requestBody []string) ApiPostUniverseIdsRequest {
	r.requestBody = &requestBody
	return r
}

// The language to use for the response.
func (r ApiPostUniverseIdsRequest) AcceptLanguage(acceptLanguage string) ApiPostUniverseIdsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostUniverseIdsRequest) IfNoneMatch(ifNoneMatch string) ApiPostUniverseIdsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiPostUniverseIdsRequest) XTenant(xTenant string) ApiPostUniverseIdsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostUniverseIdsRequest) Execute() (*UniverseIdsPost, *http.Response, error) {
	return r.ApiService.PostUniverseIdsExecute(r)
}

/*
PostUniverseIds Bulk names to IDs

Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUniverseIdsRequest
*/
func (a *UniverseAPIService) PostUniverseIds(ctx context.Context) ApiPostUniverseIdsRequest {
	return ApiPostUniverseIdsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UniverseIdsPost
func (a *UniverseAPIService) PostUniverseIdsExecute(r ApiPostUniverseIdsRequest) (*UniverseIdsPost, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UniverseIdsPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.PostUniverseIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/ids"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}
	if len(*r.requestBody) < 1 {
		return localVarReturnValue, nil, reportError("requestBody must have at least 1 elements")
	}
	if len(*r.requestBody) > 500 {
		return localVarReturnValue, nil, reportError("requestBody must have less than 500 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUniverseNamesRequest struct {
	ctx context.Context
	ApiService UniverseAPI
	xCompatibilityDate *string
	requestBody *[]int64
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiPostUniverseNamesRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostUniverseNamesRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiPostUniverseNamesRequest) RequestBody(requestBody []int64) ApiPostUniverseNamesRequest {
	r.requestBody = &requestBody
	return r
}

// The language to use for the response.
func (r ApiPostUniverseNamesRequest) AcceptLanguage(acceptLanguage string) ApiPostUniverseNamesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostUniverseNamesRequest) IfNoneMatch(ifNoneMatch string) ApiPostUniverseNamesRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiPostUniverseNamesRequest) XTenant(xTenant string) ApiPostUniverseNamesRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostUniverseNamesRequest) Execute() ([]UniverseNamesPostInner, *http.Response, error) {
	return r.ApiService.PostUniverseNamesExecute(r)
}

/*
PostUniverseNames Get names and categories for a set of IDs

Resolve a set of IDs to names and categories. Supported ID's for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types, Factions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUniverseNamesRequest
*/
func (a *UniverseAPIService) PostUniverseNames(ctx context.Context) ApiPostUniverseNamesRequest {
	return ApiPostUniverseNamesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniverseNamesPostInner
func (a *UniverseAPIService) PostUniverseNamesExecute(r ApiPostUniverseNamesRequest) ([]UniverseNamesPostInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniverseNamesPostInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniverseAPIService.PostUniverseNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/universe/names"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}
	if len(*r.requestBody) < 1 {
		return localVarReturnValue, nil, reportError("requestBody must have at least 1 elements")
	}
	if len(*r.requestBody) > 1000 {
		return localVarReturnValue, nil, reportError("requestBody must have less than 1000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
