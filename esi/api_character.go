/*
EVE Stable Infrastructure (ESI) - tranquility

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2025-09-30
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package esi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type CharacterAPI interface {

	/*
	GetCharactersCharacterId Get character's public information

	Public information about a character

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdRequest
	*/
	GetCharactersCharacterId(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdRequest

	// GetCharactersCharacterIdExecute executes the request
	//  @return CharactersCharacterIdGet
	GetCharactersCharacterIdExecute(r ApiGetCharactersCharacterIdRequest) (*CharactersCharacterIdGet, *http.Response, error)

	/*
	GetCharactersCharacterIdAgentsResearch Get agents research

	Return a list of agents research information for a character. The formula for finding the current research points with an agent is: currentPoints = remainderPoints + pointsPerDay * days(currentTime - researchStartDate)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdAgentsResearchRequest
	*/
	GetCharactersCharacterIdAgentsResearch(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdAgentsResearchRequest

	// GetCharactersCharacterIdAgentsResearchExecute executes the request
	//  @return []CharactersCharacterIdAgentsResearchGetInner
	GetCharactersCharacterIdAgentsResearchExecute(r ApiGetCharactersCharacterIdAgentsResearchRequest) ([]CharactersCharacterIdAgentsResearchGetInner, *http.Response, error)

	/*
	GetCharactersCharacterIdBlueprints Get blueprints

	Return a list of blueprints the character owns

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdBlueprintsRequest
	*/
	GetCharactersCharacterIdBlueprints(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdBlueprintsRequest

	// GetCharactersCharacterIdBlueprintsExecute executes the request
	//  @return []CharactersCharacterIdBlueprintsGetInner
	GetCharactersCharacterIdBlueprintsExecute(r ApiGetCharactersCharacterIdBlueprintsRequest) ([]CharactersCharacterIdBlueprintsGetInner, *http.Response, error)

	/*
	GetCharactersCharacterIdCorporationhistory Get corporation history

	Get a list of all the corporations a character has been a member of

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdCorporationhistoryRequest
	*/
	GetCharactersCharacterIdCorporationhistory(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdCorporationhistoryRequest

	// GetCharactersCharacterIdCorporationhistoryExecute executes the request
	//  @return []CharactersCharacterIdCorporationhistoryGetInner
	GetCharactersCharacterIdCorporationhistoryExecute(r ApiGetCharactersCharacterIdCorporationhistoryRequest) ([]CharactersCharacterIdCorporationhistoryGetInner, *http.Response, error)

	/*
	GetCharactersCharacterIdFatigue Get jump fatigue

	Return a character's jump activation and fatigue information

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdFatigueRequest
	*/
	GetCharactersCharacterIdFatigue(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdFatigueRequest

	// GetCharactersCharacterIdFatigueExecute executes the request
	//  @return CharactersCharacterIdFatigueGet
	GetCharactersCharacterIdFatigueExecute(r ApiGetCharactersCharacterIdFatigueRequest) (*CharactersCharacterIdFatigueGet, *http.Response, error)

	/*
	GetCharactersCharacterIdMedals Get medals

	Return a list of medals the character has

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdMedalsRequest
	*/
	GetCharactersCharacterIdMedals(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdMedalsRequest

	// GetCharactersCharacterIdMedalsExecute executes the request
	//  @return []CharactersCharacterIdMedalsGetInner
	GetCharactersCharacterIdMedalsExecute(r ApiGetCharactersCharacterIdMedalsRequest) ([]CharactersCharacterIdMedalsGetInner, *http.Response, error)

	/*
	GetCharactersCharacterIdNotifications Get character notifications

	Return character notifications

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdNotificationsRequest
	*/
	GetCharactersCharacterIdNotifications(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdNotificationsRequest

	// GetCharactersCharacterIdNotificationsExecute executes the request
	//  @return []CharactersCharacterIdNotificationsGetInner
	GetCharactersCharacterIdNotificationsExecute(r ApiGetCharactersCharacterIdNotificationsRequest) ([]CharactersCharacterIdNotificationsGetInner, *http.Response, error)

	/*
	GetCharactersCharacterIdNotificationsContacts Get new contact notifications

	Return notifications about having been added to someone's contact list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdNotificationsContactsRequest
	*/
	GetCharactersCharacterIdNotificationsContacts(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdNotificationsContactsRequest

	// GetCharactersCharacterIdNotificationsContactsExecute executes the request
	//  @return []CharactersCharacterIdNotificationsContactsGetInner
	GetCharactersCharacterIdNotificationsContactsExecute(r ApiGetCharactersCharacterIdNotificationsContactsRequest) ([]CharactersCharacterIdNotificationsContactsGetInner, *http.Response, error)

	/*
	GetCharactersCharacterIdPortrait Get character portraits

	Get portrait urls for a character

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdPortraitRequest
	*/
	GetCharactersCharacterIdPortrait(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdPortraitRequest

	// GetCharactersCharacterIdPortraitExecute executes the request
	//  @return CharactersCharacterIdPortraitGet
	GetCharactersCharacterIdPortraitExecute(r ApiGetCharactersCharacterIdPortraitRequest) (*CharactersCharacterIdPortraitGet, *http.Response, error)

	/*
	GetCharactersCharacterIdRoles Get character corporation roles

	Returns a character's corporation roles

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdRolesRequest
	*/
	GetCharactersCharacterIdRoles(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdRolesRequest

	// GetCharactersCharacterIdRolesExecute executes the request
	//  @return CharactersCharacterIdRolesGet
	GetCharactersCharacterIdRolesExecute(r ApiGetCharactersCharacterIdRolesRequest) (*CharactersCharacterIdRolesGet, *http.Response, error)

	/*
	GetCharactersCharacterIdStandings Get standings

	Return character standings from agents, NPC corporations, and factions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdStandingsRequest
	*/
	GetCharactersCharacterIdStandings(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdStandingsRequest

	// GetCharactersCharacterIdStandingsExecute executes the request
	//  @return []CharactersCharacterIdStandingsGetInner
	GetCharactersCharacterIdStandingsExecute(r ApiGetCharactersCharacterIdStandingsRequest) ([]CharactersCharacterIdStandingsGetInner, *http.Response, error)

	/*
	GetCharactersCharacterIdTitles Get character corporation titles

	Returns a character's titles

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdTitlesRequest
	*/
	GetCharactersCharacterIdTitles(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdTitlesRequest

	// GetCharactersCharacterIdTitlesExecute executes the request
	//  @return []CharactersCharacterIdTitlesGetInner
	GetCharactersCharacterIdTitlesExecute(r ApiGetCharactersCharacterIdTitlesRequest) ([]CharactersCharacterIdTitlesGetInner, *http.Response, error)

	/*
	PostCharactersAffiliation Character affiliation

	Bulk lookup of character IDs to corporation, alliance and faction

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostCharactersAffiliationRequest
	*/
	PostCharactersAffiliation(ctx context.Context) ApiPostCharactersAffiliationRequest

	// PostCharactersAffiliationExecute executes the request
	//  @return []CharactersAffiliationPostInner
	PostCharactersAffiliationExecute(r ApiPostCharactersAffiliationRequest) ([]CharactersAffiliationPostInner, *http.Response, error)

	/*
	PostCharactersCharacterIdCspa Calculate a CSPA charge cost

	Takes a source character ID in the url and a set of target character ID's in the body, returns a CSPA charge cost

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiPostCharactersCharacterIdCspaRequest
	*/
	PostCharactersCharacterIdCspa(ctx context.Context, characterId int64) ApiPostCharactersCharacterIdCspaRequest

	// PostCharactersCharacterIdCspaExecute executes the request
	//  @return float64
	PostCharactersCharacterIdCspaExecute(r ApiPostCharactersCharacterIdCspaRequest) (float64, *http.Response, error)
}

// CharacterAPIService CharacterAPI service
type CharacterAPIService service

type ApiGetCharactersCharacterIdRequest struct {
	ctx context.Context
	ApiService CharacterAPI
	characterId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdRequest) Execute() (*CharactersCharacterIdGet, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdExecute(r)
}

/*
GetCharactersCharacterId Get character's public information

Public information about a character

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdRequest
*/
func (a *CharacterAPIService) GetCharactersCharacterId(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdRequest {
	return ApiGetCharactersCharacterIdRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return CharactersCharacterIdGet
func (a *CharacterAPIService) GetCharactersCharacterIdExecute(r ApiGetCharactersCharacterIdRequest) (*CharactersCharacterIdGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CharactersCharacterIdGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CharacterAPIService.GetCharactersCharacterId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCharactersCharacterIdAgentsResearchRequest struct {
	ctx context.Context
	ApiService CharacterAPI
	characterId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdAgentsResearchRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdAgentsResearchRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdAgentsResearchRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdAgentsResearchRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdAgentsResearchRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdAgentsResearchRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdAgentsResearchRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdAgentsResearchRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdAgentsResearchRequest) Execute() ([]CharactersCharacterIdAgentsResearchGetInner, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdAgentsResearchExecute(r)
}

/*
GetCharactersCharacterIdAgentsResearch Get agents research

Return a list of agents research information for a character. The formula for finding the current research points with an agent is: currentPoints = remainderPoints + pointsPerDay * days(currentTime - researchStartDate)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdAgentsResearchRequest
*/
func (a *CharacterAPIService) GetCharactersCharacterIdAgentsResearch(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdAgentsResearchRequest {
	return ApiGetCharactersCharacterIdAgentsResearchRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return []CharactersCharacterIdAgentsResearchGetInner
func (a *CharacterAPIService) GetCharactersCharacterIdAgentsResearchExecute(r ApiGetCharactersCharacterIdAgentsResearchRequest) ([]CharactersCharacterIdAgentsResearchGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharactersCharacterIdAgentsResearchGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CharacterAPIService.GetCharactersCharacterIdAgentsResearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/agents_research"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCharactersCharacterIdBlueprintsRequest struct {
	ctx context.Context
	ApiService CharacterAPI
	characterId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdBlueprintsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdBlueprintsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCharactersCharacterIdBlueprintsRequest) Page(page int32) ApiGetCharactersCharacterIdBlueprintsRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdBlueprintsRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdBlueprintsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdBlueprintsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdBlueprintsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdBlueprintsRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdBlueprintsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdBlueprintsRequest) Execute() ([]CharactersCharacterIdBlueprintsGetInner, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdBlueprintsExecute(r)
}

/*
GetCharactersCharacterIdBlueprints Get blueprints

Return a list of blueprints the character owns

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdBlueprintsRequest
*/
func (a *CharacterAPIService) GetCharactersCharacterIdBlueprints(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdBlueprintsRequest {
	return ApiGetCharactersCharacterIdBlueprintsRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return []CharactersCharacterIdBlueprintsGetInner
func (a *CharacterAPIService) GetCharactersCharacterIdBlueprintsExecute(r ApiGetCharactersCharacterIdBlueprintsRequest) ([]CharactersCharacterIdBlueprintsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharactersCharacterIdBlueprintsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CharacterAPIService.GetCharactersCharacterIdBlueprints")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/blueprints"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCharactersCharacterIdCorporationhistoryRequest struct {
	ctx context.Context
	ApiService CharacterAPI
	characterId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdCorporationhistoryRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdCorporationhistoryRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdCorporationhistoryRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdCorporationhistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdCorporationhistoryRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdCorporationhistoryRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdCorporationhistoryRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdCorporationhistoryRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdCorporationhistoryRequest) Execute() ([]CharactersCharacterIdCorporationhistoryGetInner, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdCorporationhistoryExecute(r)
}

/*
GetCharactersCharacterIdCorporationhistory Get corporation history

Get a list of all the corporations a character has been a member of

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdCorporationhistoryRequest
*/
func (a *CharacterAPIService) GetCharactersCharacterIdCorporationhistory(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdCorporationhistoryRequest {
	return ApiGetCharactersCharacterIdCorporationhistoryRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return []CharactersCharacterIdCorporationhistoryGetInner
func (a *CharacterAPIService) GetCharactersCharacterIdCorporationhistoryExecute(r ApiGetCharactersCharacterIdCorporationhistoryRequest) ([]CharactersCharacterIdCorporationhistoryGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharactersCharacterIdCorporationhistoryGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CharacterAPIService.GetCharactersCharacterIdCorporationhistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/corporationhistory"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCharactersCharacterIdFatigueRequest struct {
	ctx context.Context
	ApiService CharacterAPI
	characterId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdFatigueRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdFatigueRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdFatigueRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdFatigueRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdFatigueRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdFatigueRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdFatigueRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdFatigueRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdFatigueRequest) Execute() (*CharactersCharacterIdFatigueGet, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdFatigueExecute(r)
}

/*
GetCharactersCharacterIdFatigue Get jump fatigue

Return a character's jump activation and fatigue information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdFatigueRequest
*/
func (a *CharacterAPIService) GetCharactersCharacterIdFatigue(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdFatigueRequest {
	return ApiGetCharactersCharacterIdFatigueRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return CharactersCharacterIdFatigueGet
func (a *CharacterAPIService) GetCharactersCharacterIdFatigueExecute(r ApiGetCharactersCharacterIdFatigueRequest) (*CharactersCharacterIdFatigueGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CharactersCharacterIdFatigueGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CharacterAPIService.GetCharactersCharacterIdFatigue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/fatigue"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCharactersCharacterIdMedalsRequest struct {
	ctx context.Context
	ApiService CharacterAPI
	characterId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdMedalsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdMedalsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdMedalsRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdMedalsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdMedalsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdMedalsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdMedalsRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdMedalsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdMedalsRequest) Execute() ([]CharactersCharacterIdMedalsGetInner, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdMedalsExecute(r)
}

/*
GetCharactersCharacterIdMedals Get medals

Return a list of medals the character has

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdMedalsRequest
*/
func (a *CharacterAPIService) GetCharactersCharacterIdMedals(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdMedalsRequest {
	return ApiGetCharactersCharacterIdMedalsRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return []CharactersCharacterIdMedalsGetInner
func (a *CharacterAPIService) GetCharactersCharacterIdMedalsExecute(r ApiGetCharactersCharacterIdMedalsRequest) ([]CharactersCharacterIdMedalsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharactersCharacterIdMedalsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CharacterAPIService.GetCharactersCharacterIdMedals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/medals"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCharactersCharacterIdNotificationsRequest struct {
	ctx context.Context
	ApiService CharacterAPI
	characterId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdNotificationsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdNotificationsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdNotificationsRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdNotificationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdNotificationsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdNotificationsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdNotificationsRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdNotificationsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdNotificationsRequest) Execute() ([]CharactersCharacterIdNotificationsGetInner, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdNotificationsExecute(r)
}

/*
GetCharactersCharacterIdNotifications Get character notifications

Return character notifications

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdNotificationsRequest
*/
func (a *CharacterAPIService) GetCharactersCharacterIdNotifications(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdNotificationsRequest {
	return ApiGetCharactersCharacterIdNotificationsRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return []CharactersCharacterIdNotificationsGetInner
func (a *CharacterAPIService) GetCharactersCharacterIdNotificationsExecute(r ApiGetCharactersCharacterIdNotificationsRequest) ([]CharactersCharacterIdNotificationsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharactersCharacterIdNotificationsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CharacterAPIService.GetCharactersCharacterIdNotifications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/notifications"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCharactersCharacterIdNotificationsContactsRequest struct {
	ctx context.Context
	ApiService CharacterAPI
	characterId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdNotificationsContactsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdNotificationsContactsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdNotificationsContactsRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdNotificationsContactsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdNotificationsContactsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdNotificationsContactsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdNotificationsContactsRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdNotificationsContactsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdNotificationsContactsRequest) Execute() ([]CharactersCharacterIdNotificationsContactsGetInner, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdNotificationsContactsExecute(r)
}

/*
GetCharactersCharacterIdNotificationsContacts Get new contact notifications

Return notifications about having been added to someone's contact list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdNotificationsContactsRequest
*/
func (a *CharacterAPIService) GetCharactersCharacterIdNotificationsContacts(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdNotificationsContactsRequest {
	return ApiGetCharactersCharacterIdNotificationsContactsRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return []CharactersCharacterIdNotificationsContactsGetInner
func (a *CharacterAPIService) GetCharactersCharacterIdNotificationsContactsExecute(r ApiGetCharactersCharacterIdNotificationsContactsRequest) ([]CharactersCharacterIdNotificationsContactsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharactersCharacterIdNotificationsContactsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CharacterAPIService.GetCharactersCharacterIdNotificationsContacts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/notifications/contacts"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCharactersCharacterIdPortraitRequest struct {
	ctx context.Context
	ApiService CharacterAPI
	characterId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdPortraitRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdPortraitRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdPortraitRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdPortraitRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdPortraitRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdPortraitRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdPortraitRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdPortraitRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdPortraitRequest) Execute() (*CharactersCharacterIdPortraitGet, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdPortraitExecute(r)
}

/*
GetCharactersCharacterIdPortrait Get character portraits

Get portrait urls for a character

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdPortraitRequest
*/
func (a *CharacterAPIService) GetCharactersCharacterIdPortrait(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdPortraitRequest {
	return ApiGetCharactersCharacterIdPortraitRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return CharactersCharacterIdPortraitGet
func (a *CharacterAPIService) GetCharactersCharacterIdPortraitExecute(r ApiGetCharactersCharacterIdPortraitRequest) (*CharactersCharacterIdPortraitGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CharactersCharacterIdPortraitGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CharacterAPIService.GetCharactersCharacterIdPortrait")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/portrait"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCharactersCharacterIdRolesRequest struct {
	ctx context.Context
	ApiService CharacterAPI
	characterId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdRolesRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdRolesRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdRolesRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdRolesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdRolesRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdRolesRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdRolesRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdRolesRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdRolesRequest) Execute() (*CharactersCharacterIdRolesGet, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdRolesExecute(r)
}

/*
GetCharactersCharacterIdRoles Get character corporation roles

Returns a character's corporation roles

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdRolesRequest
*/
func (a *CharacterAPIService) GetCharactersCharacterIdRoles(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdRolesRequest {
	return ApiGetCharactersCharacterIdRolesRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return CharactersCharacterIdRolesGet
func (a *CharacterAPIService) GetCharactersCharacterIdRolesExecute(r ApiGetCharactersCharacterIdRolesRequest) (*CharactersCharacterIdRolesGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CharactersCharacterIdRolesGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CharacterAPIService.GetCharactersCharacterIdRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCharactersCharacterIdStandingsRequest struct {
	ctx context.Context
	ApiService CharacterAPI
	characterId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdStandingsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdStandingsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdStandingsRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdStandingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdStandingsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdStandingsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdStandingsRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdStandingsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdStandingsRequest) Execute() ([]CharactersCharacterIdStandingsGetInner, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdStandingsExecute(r)
}

/*
GetCharactersCharacterIdStandings Get standings

Return character standings from agents, NPC corporations, and factions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdStandingsRequest
*/
func (a *CharacterAPIService) GetCharactersCharacterIdStandings(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdStandingsRequest {
	return ApiGetCharactersCharacterIdStandingsRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return []CharactersCharacterIdStandingsGetInner
func (a *CharacterAPIService) GetCharactersCharacterIdStandingsExecute(r ApiGetCharactersCharacterIdStandingsRequest) ([]CharactersCharacterIdStandingsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharactersCharacterIdStandingsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CharacterAPIService.GetCharactersCharacterIdStandings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/standings"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCharactersCharacterIdTitlesRequest struct {
	ctx context.Context
	ApiService CharacterAPI
	characterId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdTitlesRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdTitlesRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdTitlesRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdTitlesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdTitlesRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdTitlesRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdTitlesRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdTitlesRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdTitlesRequest) Execute() ([]CharactersCharacterIdTitlesGetInner, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdTitlesExecute(r)
}

/*
GetCharactersCharacterIdTitles Get character corporation titles

Returns a character's titles

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdTitlesRequest
*/
func (a *CharacterAPIService) GetCharactersCharacterIdTitles(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdTitlesRequest {
	return ApiGetCharactersCharacterIdTitlesRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return []CharactersCharacterIdTitlesGetInner
func (a *CharacterAPIService) GetCharactersCharacterIdTitlesExecute(r ApiGetCharactersCharacterIdTitlesRequest) ([]CharactersCharacterIdTitlesGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharactersCharacterIdTitlesGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CharacterAPIService.GetCharactersCharacterIdTitles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/titles"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCharactersAffiliationRequest struct {
	ctx context.Context
	ApiService CharacterAPI
	xCompatibilityDate *string
	requestBody *[]int64
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiPostCharactersAffiliationRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostCharactersAffiliationRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiPostCharactersAffiliationRequest) RequestBody(requestBody []int64) ApiPostCharactersAffiliationRequest {
	r.requestBody = &requestBody
	return r
}

// The language to use for the response.
func (r ApiPostCharactersAffiliationRequest) AcceptLanguage(acceptLanguage string) ApiPostCharactersAffiliationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostCharactersAffiliationRequest) IfNoneMatch(ifNoneMatch string) ApiPostCharactersAffiliationRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiPostCharactersAffiliationRequest) XTenant(xTenant string) ApiPostCharactersAffiliationRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostCharactersAffiliationRequest) Execute() ([]CharactersAffiliationPostInner, *http.Response, error) {
	return r.ApiService.PostCharactersAffiliationExecute(r)
}

/*
PostCharactersAffiliation Character affiliation

Bulk lookup of character IDs to corporation, alliance and faction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCharactersAffiliationRequest
*/
func (a *CharacterAPIService) PostCharactersAffiliation(ctx context.Context) ApiPostCharactersAffiliationRequest {
	return ApiPostCharactersAffiliationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CharactersAffiliationPostInner
func (a *CharacterAPIService) PostCharactersAffiliationExecute(r ApiPostCharactersAffiliationRequest) ([]CharactersAffiliationPostInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharactersAffiliationPostInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CharacterAPIService.PostCharactersAffiliation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/affiliation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}
	if len(*r.requestBody) < 1 {
		return localVarReturnValue, nil, reportError("requestBody must have at least 1 elements")
	}
	if len(*r.requestBody) > 1000 {
		return localVarReturnValue, nil, reportError("requestBody must have less than 1000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCharactersCharacterIdCspaRequest struct {
	ctx context.Context
	ApiService CharacterAPI
	characterId int64
	xCompatibilityDate *string
	requestBody *[]int64
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiPostCharactersCharacterIdCspaRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostCharactersCharacterIdCspaRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiPostCharactersCharacterIdCspaRequest) RequestBody(requestBody []int64) ApiPostCharactersCharacterIdCspaRequest {
	r.requestBody = &requestBody
	return r
}

// The language to use for the response.
func (r ApiPostCharactersCharacterIdCspaRequest) AcceptLanguage(acceptLanguage string) ApiPostCharactersCharacterIdCspaRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostCharactersCharacterIdCspaRequest) IfNoneMatch(ifNoneMatch string) ApiPostCharactersCharacterIdCspaRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiPostCharactersCharacterIdCspaRequest) XTenant(xTenant string) ApiPostCharactersCharacterIdCspaRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostCharactersCharacterIdCspaRequest) Execute() (float64, *http.Response, error) {
	return r.ApiService.PostCharactersCharacterIdCspaExecute(r)
}

/*
PostCharactersCharacterIdCspa Calculate a CSPA charge cost

Takes a source character ID in the url and a set of target character ID's in the body, returns a CSPA charge cost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiPostCharactersCharacterIdCspaRequest
*/
func (a *CharacterAPIService) PostCharactersCharacterIdCspa(ctx context.Context, characterId int64) ApiPostCharactersCharacterIdCspaRequest {
	return ApiPostCharactersCharacterIdCspaRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return float64
func (a *CharacterAPIService) PostCharactersCharacterIdCspaExecute(r ApiPostCharactersCharacterIdCspaRequest) (float64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  float64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CharacterAPIService.PostCharactersCharacterIdCspa")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/cspa"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}
	if len(*r.requestBody) < 1 {
		return localVarReturnValue, nil, reportError("requestBody must have at least 1 elements")
	}
	if len(*r.requestBody) > 100 {
		return localVarReturnValue, nil, reportError("requestBody must have less than 100 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
