/*
EVE Stable Infrastructure (ESI) - tranquility

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2020-01-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package esi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type FactionWarfareAPI interface {

	/*
	GetCharactersCharacterIdFwStats Overview of a character involved in faction warfare

	Statistical overview of a character involved in faction warfare

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdFwStatsRequest
	*/
	GetCharactersCharacterIdFwStats(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdFwStatsRequest

	// GetCharactersCharacterIdFwStatsExecute executes the request
	//  @return CharactersCharacterIdFwStatsGet
	GetCharactersCharacterIdFwStatsExecute(r ApiGetCharactersCharacterIdFwStatsRequest) (*CharactersCharacterIdFwStatsGet, *http.Response, error)

	/*
	GetCorporationsCorporationIdFwStats Overview of a corporation involved in faction warfare

	Statistics about a corporation involved in faction warfare

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdFwStatsRequest
	*/
	GetCorporationsCorporationIdFwStats(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdFwStatsRequest

	// GetCorporationsCorporationIdFwStatsExecute executes the request
	//  @return CorporationsCorporationIdFwStatsGet
	GetCorporationsCorporationIdFwStatsExecute(r ApiGetCorporationsCorporationIdFwStatsRequest) (*CorporationsCorporationIdFwStatsGet, *http.Response, error)

	/*
	GetFwLeaderboards List of the top factions in faction warfare

	Top 4 leaderboard of factions for kills and victory points separated by total, last week and yesterday

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetFwLeaderboardsRequest
	*/
	GetFwLeaderboards(ctx context.Context) ApiGetFwLeaderboardsRequest

	// GetFwLeaderboardsExecute executes the request
	//  @return FwLeaderboardsGet
	GetFwLeaderboardsExecute(r ApiGetFwLeaderboardsRequest) (*FwLeaderboardsGet, *http.Response, error)

	/*
	GetFwLeaderboardsCharacters List of the top pilots in faction warfare

	Top 100 leaderboard of pilots for kills and victory points separated by total, last week and yesterday

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetFwLeaderboardsCharactersRequest
	*/
	GetFwLeaderboardsCharacters(ctx context.Context) ApiGetFwLeaderboardsCharactersRequest

	// GetFwLeaderboardsCharactersExecute executes the request
	//  @return FwLeaderboardsCharactersGet
	GetFwLeaderboardsCharactersExecute(r ApiGetFwLeaderboardsCharactersRequest) (*FwLeaderboardsCharactersGet, *http.Response, error)

	/*
	GetFwLeaderboardsCorporations List of the top corporations in faction warfare

	Top 10 leaderboard of corporations for kills and victory points separated by total, last week and yesterday

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetFwLeaderboardsCorporationsRequest
	*/
	GetFwLeaderboardsCorporations(ctx context.Context) ApiGetFwLeaderboardsCorporationsRequest

	// GetFwLeaderboardsCorporationsExecute executes the request
	//  @return FwLeaderboardsCorporationsGet
	GetFwLeaderboardsCorporationsExecute(r ApiGetFwLeaderboardsCorporationsRequest) (*FwLeaderboardsCorporationsGet, *http.Response, error)

	/*
	GetFwStats An overview of statistics about factions involved in faction warfare

	Statistical overviews of factions involved in faction warfare

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetFwStatsRequest
	*/
	GetFwStats(ctx context.Context) ApiGetFwStatsRequest

	// GetFwStatsExecute executes the request
	//  @return []FwStatsGetInner
	GetFwStatsExecute(r ApiGetFwStatsRequest) ([]FwStatsGetInner, *http.Response, error)

	/*
	GetFwSystems Ownership of faction warfare systems

	An overview of the current ownership of faction warfare solar systems

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetFwSystemsRequest
	*/
	GetFwSystems(ctx context.Context) ApiGetFwSystemsRequest

	// GetFwSystemsExecute executes the request
	//  @return []FwSystemsGetInner
	GetFwSystemsExecute(r ApiGetFwSystemsRequest) ([]FwSystemsGetInner, *http.Response, error)

	/*
	GetFwWars Data about which NPC factions are at war

	Data about which NPC factions are at war

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetFwWarsRequest
	*/
	GetFwWars(ctx context.Context) ApiGetFwWarsRequest

	// GetFwWarsExecute executes the request
	//  @return []FwWarsGetInner
	GetFwWarsExecute(r ApiGetFwWarsRequest) ([]FwWarsGetInner, *http.Response, error)
}

// FactionWarfareAPIService FactionWarfareAPI service
type FactionWarfareAPIService service

type ApiGetCharactersCharacterIdFwStatsRequest struct {
	ctx context.Context
	ApiService FactionWarfareAPI
	characterId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdFwStatsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdFwStatsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdFwStatsRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdFwStatsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdFwStatsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdFwStatsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdFwStatsRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdFwStatsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdFwStatsRequest) Execute() (*CharactersCharacterIdFwStatsGet, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdFwStatsExecute(r)
}

/*
GetCharactersCharacterIdFwStats Overview of a character involved in faction warfare

Statistical overview of a character involved in faction warfare

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdFwStatsRequest
*/
func (a *FactionWarfareAPIService) GetCharactersCharacterIdFwStats(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdFwStatsRequest {
	return ApiGetCharactersCharacterIdFwStatsRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return CharactersCharacterIdFwStatsGet
func (a *FactionWarfareAPIService) GetCharactersCharacterIdFwStatsExecute(r ApiGetCharactersCharacterIdFwStatsRequest) (*CharactersCharacterIdFwStatsGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CharactersCharacterIdFwStatsGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FactionWarfareAPIService.GetCharactersCharacterIdFwStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/fw/stats"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdFwStatsRequest struct {
	ctx context.Context
	ApiService FactionWarfareAPI
	corporationId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdFwStatsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdFwStatsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdFwStatsRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdFwStatsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdFwStatsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdFwStatsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdFwStatsRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdFwStatsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdFwStatsRequest) Execute() (*CorporationsCorporationIdFwStatsGet, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdFwStatsExecute(r)
}

/*
GetCorporationsCorporationIdFwStats Overview of a corporation involved in faction warfare

Statistics about a corporation involved in faction warfare

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdFwStatsRequest
*/
func (a *FactionWarfareAPIService) GetCorporationsCorporationIdFwStats(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdFwStatsRequest {
	return ApiGetCorporationsCorporationIdFwStatsRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return CorporationsCorporationIdFwStatsGet
func (a *FactionWarfareAPIService) GetCorporationsCorporationIdFwStatsExecute(r ApiGetCorporationsCorporationIdFwStatsRequest) (*CorporationsCorporationIdFwStatsGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CorporationsCorporationIdFwStatsGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FactionWarfareAPIService.GetCorporationsCorporationIdFwStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/fw/stats"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFwLeaderboardsRequest struct {
	ctx context.Context
	ApiService FactionWarfareAPI
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetFwLeaderboardsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetFwLeaderboardsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetFwLeaderboardsRequest) AcceptLanguage(acceptLanguage string) ApiGetFwLeaderboardsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetFwLeaderboardsRequest) IfNoneMatch(ifNoneMatch string) ApiGetFwLeaderboardsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetFwLeaderboardsRequest) XTenant(xTenant string) ApiGetFwLeaderboardsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetFwLeaderboardsRequest) Execute() (*FwLeaderboardsGet, *http.Response, error) {
	return r.ApiService.GetFwLeaderboardsExecute(r)
}

/*
GetFwLeaderboards List of the top factions in faction warfare

Top 4 leaderboard of factions for kills and victory points separated by total, last week and yesterday

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFwLeaderboardsRequest
*/
func (a *FactionWarfareAPIService) GetFwLeaderboards(ctx context.Context) ApiGetFwLeaderboardsRequest {
	return ApiGetFwLeaderboardsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FwLeaderboardsGet
func (a *FactionWarfareAPIService) GetFwLeaderboardsExecute(r ApiGetFwLeaderboardsRequest) (*FwLeaderboardsGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FwLeaderboardsGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FactionWarfareAPIService.GetFwLeaderboards")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fw/leaderboards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFwLeaderboardsCharactersRequest struct {
	ctx context.Context
	ApiService FactionWarfareAPI
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetFwLeaderboardsCharactersRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetFwLeaderboardsCharactersRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetFwLeaderboardsCharactersRequest) AcceptLanguage(acceptLanguage string) ApiGetFwLeaderboardsCharactersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetFwLeaderboardsCharactersRequest) IfNoneMatch(ifNoneMatch string) ApiGetFwLeaderboardsCharactersRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetFwLeaderboardsCharactersRequest) XTenant(xTenant string) ApiGetFwLeaderboardsCharactersRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetFwLeaderboardsCharactersRequest) Execute() (*FwLeaderboardsCharactersGet, *http.Response, error) {
	return r.ApiService.GetFwLeaderboardsCharactersExecute(r)
}

/*
GetFwLeaderboardsCharacters List of the top pilots in faction warfare

Top 100 leaderboard of pilots for kills and victory points separated by total, last week and yesterday

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFwLeaderboardsCharactersRequest
*/
func (a *FactionWarfareAPIService) GetFwLeaderboardsCharacters(ctx context.Context) ApiGetFwLeaderboardsCharactersRequest {
	return ApiGetFwLeaderboardsCharactersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FwLeaderboardsCharactersGet
func (a *FactionWarfareAPIService) GetFwLeaderboardsCharactersExecute(r ApiGetFwLeaderboardsCharactersRequest) (*FwLeaderboardsCharactersGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FwLeaderboardsCharactersGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FactionWarfareAPIService.GetFwLeaderboardsCharacters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fw/leaderboards/characters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFwLeaderboardsCorporationsRequest struct {
	ctx context.Context
	ApiService FactionWarfareAPI
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetFwLeaderboardsCorporationsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetFwLeaderboardsCorporationsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetFwLeaderboardsCorporationsRequest) AcceptLanguage(acceptLanguage string) ApiGetFwLeaderboardsCorporationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetFwLeaderboardsCorporationsRequest) IfNoneMatch(ifNoneMatch string) ApiGetFwLeaderboardsCorporationsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetFwLeaderboardsCorporationsRequest) XTenant(xTenant string) ApiGetFwLeaderboardsCorporationsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetFwLeaderboardsCorporationsRequest) Execute() (*FwLeaderboardsCorporationsGet, *http.Response, error) {
	return r.ApiService.GetFwLeaderboardsCorporationsExecute(r)
}

/*
GetFwLeaderboardsCorporations List of the top corporations in faction warfare

Top 10 leaderboard of corporations for kills and victory points separated by total, last week and yesterday

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFwLeaderboardsCorporationsRequest
*/
func (a *FactionWarfareAPIService) GetFwLeaderboardsCorporations(ctx context.Context) ApiGetFwLeaderboardsCorporationsRequest {
	return ApiGetFwLeaderboardsCorporationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FwLeaderboardsCorporationsGet
func (a *FactionWarfareAPIService) GetFwLeaderboardsCorporationsExecute(r ApiGetFwLeaderboardsCorporationsRequest) (*FwLeaderboardsCorporationsGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FwLeaderboardsCorporationsGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FactionWarfareAPIService.GetFwLeaderboardsCorporations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fw/leaderboards/corporations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFwStatsRequest struct {
	ctx context.Context
	ApiService FactionWarfareAPI
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetFwStatsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetFwStatsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetFwStatsRequest) AcceptLanguage(acceptLanguage string) ApiGetFwStatsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetFwStatsRequest) IfNoneMatch(ifNoneMatch string) ApiGetFwStatsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetFwStatsRequest) XTenant(xTenant string) ApiGetFwStatsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetFwStatsRequest) Execute() ([]FwStatsGetInner, *http.Response, error) {
	return r.ApiService.GetFwStatsExecute(r)
}

/*
GetFwStats An overview of statistics about factions involved in faction warfare

Statistical overviews of factions involved in faction warfare

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFwStatsRequest
*/
func (a *FactionWarfareAPIService) GetFwStats(ctx context.Context) ApiGetFwStatsRequest {
	return ApiGetFwStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []FwStatsGetInner
func (a *FactionWarfareAPIService) GetFwStatsExecute(r ApiGetFwStatsRequest) ([]FwStatsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FwStatsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FactionWarfareAPIService.GetFwStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fw/stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFwSystemsRequest struct {
	ctx context.Context
	ApiService FactionWarfareAPI
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetFwSystemsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetFwSystemsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetFwSystemsRequest) AcceptLanguage(acceptLanguage string) ApiGetFwSystemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetFwSystemsRequest) IfNoneMatch(ifNoneMatch string) ApiGetFwSystemsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetFwSystemsRequest) XTenant(xTenant string) ApiGetFwSystemsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetFwSystemsRequest) Execute() ([]FwSystemsGetInner, *http.Response, error) {
	return r.ApiService.GetFwSystemsExecute(r)
}

/*
GetFwSystems Ownership of faction warfare systems

An overview of the current ownership of faction warfare solar systems

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFwSystemsRequest
*/
func (a *FactionWarfareAPIService) GetFwSystems(ctx context.Context) ApiGetFwSystemsRequest {
	return ApiGetFwSystemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []FwSystemsGetInner
func (a *FactionWarfareAPIService) GetFwSystemsExecute(r ApiGetFwSystemsRequest) ([]FwSystemsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FwSystemsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FactionWarfareAPIService.GetFwSystems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fw/systems"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFwWarsRequest struct {
	ctx context.Context
	ApiService FactionWarfareAPI
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetFwWarsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetFwWarsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetFwWarsRequest) AcceptLanguage(acceptLanguage string) ApiGetFwWarsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetFwWarsRequest) IfNoneMatch(ifNoneMatch string) ApiGetFwWarsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetFwWarsRequest) XTenant(xTenant string) ApiGetFwWarsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetFwWarsRequest) Execute() ([]FwWarsGetInner, *http.Response, error) {
	return r.ApiService.GetFwWarsExecute(r)
}

/*
GetFwWars Data about which NPC factions are at war

Data about which NPC factions are at war

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFwWarsRequest
*/
func (a *FactionWarfareAPIService) GetFwWars(ctx context.Context) ApiGetFwWarsRequest {
	return ApiGetFwWarsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []FwWarsGetInner
func (a *FactionWarfareAPIService) GetFwWarsExecute(r ApiGetFwWarsRequest) ([]FwWarsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FwWarsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FactionWarfareAPIService.GetFwWars")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fw/wars"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
