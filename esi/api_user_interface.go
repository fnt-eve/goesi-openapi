/*
EVE Stable Infrastructure (ESI) - tranquility

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2020-01-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package esi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


type UserInterfaceAPI interface {

	/*
	PostUiAutopilotWaypoint Set Autopilot Waypoint

	Set a solar system as autopilot waypoint

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUiAutopilotWaypointRequest
	*/
	PostUiAutopilotWaypoint(ctx context.Context) ApiPostUiAutopilotWaypointRequest

	// PostUiAutopilotWaypointExecute executes the request
	PostUiAutopilotWaypointExecute(r ApiPostUiAutopilotWaypointRequest) (*http.Response, error)

	/*
	PostUiOpenwindowContract Open Contract Window

	Open the contract window inside the client

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUiOpenwindowContractRequest
	*/
	PostUiOpenwindowContract(ctx context.Context) ApiPostUiOpenwindowContractRequest

	// PostUiOpenwindowContractExecute executes the request
	PostUiOpenwindowContractExecute(r ApiPostUiOpenwindowContractRequest) (*http.Response, error)

	/*
	PostUiOpenwindowInformation Open Information Window

	Open the information window for a character, corporation or alliance inside the client

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUiOpenwindowInformationRequest
	*/
	PostUiOpenwindowInformation(ctx context.Context) ApiPostUiOpenwindowInformationRequest

	// PostUiOpenwindowInformationExecute executes the request
	PostUiOpenwindowInformationExecute(r ApiPostUiOpenwindowInformationRequest) (*http.Response, error)

	/*
	PostUiOpenwindowMarketdetails Open Market Details

	Open the market details window for a specific typeID inside the client

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUiOpenwindowMarketdetailsRequest
	*/
	PostUiOpenwindowMarketdetails(ctx context.Context) ApiPostUiOpenwindowMarketdetailsRequest

	// PostUiOpenwindowMarketdetailsExecute executes the request
	PostUiOpenwindowMarketdetailsExecute(r ApiPostUiOpenwindowMarketdetailsRequest) (*http.Response, error)

	/*
	PostUiOpenwindowNewmail Open New Mail Window

	Open the New Mail window, according to settings from the request if applicable

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUiOpenwindowNewmailRequest
	*/
	PostUiOpenwindowNewmail(ctx context.Context) ApiPostUiOpenwindowNewmailRequest

	// PostUiOpenwindowNewmailExecute executes the request
	PostUiOpenwindowNewmailExecute(r ApiPostUiOpenwindowNewmailRequest) (*http.Response, error)
}

// UserInterfaceAPIService UserInterfaceAPI service
type UserInterfaceAPIService service

type ApiPostUiAutopilotWaypointRequest struct {
	ctx context.Context
	ApiService UserInterfaceAPI
	addToBeginning *bool
	clearOtherWaypoints *bool
	destinationId *int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

func (r ApiPostUiAutopilotWaypointRequest) AddToBeginning(addToBeginning bool) ApiPostUiAutopilotWaypointRequest {
	r.addToBeginning = &addToBeginning
	return r
}

func (r ApiPostUiAutopilotWaypointRequest) ClearOtherWaypoints(clearOtherWaypoints bool) ApiPostUiAutopilotWaypointRequest {
	r.clearOtherWaypoints = &clearOtherWaypoints
	return r
}

func (r ApiPostUiAutopilotWaypointRequest) DestinationId(destinationId int64) ApiPostUiAutopilotWaypointRequest {
	r.destinationId = &destinationId
	return r
}

// The compatibility date for the request.
func (r ApiPostUiAutopilotWaypointRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostUiAutopilotWaypointRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiPostUiAutopilotWaypointRequest) AcceptLanguage(acceptLanguage string) ApiPostUiAutopilotWaypointRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostUiAutopilotWaypointRequest) IfNoneMatch(ifNoneMatch string) ApiPostUiAutopilotWaypointRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiPostUiAutopilotWaypointRequest) XTenant(xTenant string) ApiPostUiAutopilotWaypointRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostUiAutopilotWaypointRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUiAutopilotWaypointExecute(r)
}

/*
PostUiAutopilotWaypoint Set Autopilot Waypoint

Set a solar system as autopilot waypoint

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUiAutopilotWaypointRequest
*/
func (a *UserInterfaceAPIService) PostUiAutopilotWaypoint(ctx context.Context) ApiPostUiAutopilotWaypointRequest {
	return ApiPostUiAutopilotWaypointRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UserInterfaceAPIService) PostUiAutopilotWaypointExecute(r ApiPostUiAutopilotWaypointRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserInterfaceAPIService.PostUiAutopilotWaypoint")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ui/autopilot/waypoint"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addToBeginning == nil {
		return nil, reportError("addToBeginning is required and must be specified")
	}
	if r.clearOtherWaypoints == nil {
		return nil, reportError("clearOtherWaypoints is required and must be specified")
	}
	if r.destinationId == nil {
		return nil, reportError("destinationId is required and must be specified")
	}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return nil, reportError("xCompatibilityDate is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "add_to_beginning", r.addToBeginning, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "clear_other_waypoints", r.clearOtherWaypoints, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "destination_id", r.destinationId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostUiOpenwindowContractRequest struct {
	ctx context.Context
	ApiService UserInterfaceAPI
	contractId *int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

func (r ApiPostUiOpenwindowContractRequest) ContractId(contractId int64) ApiPostUiOpenwindowContractRequest {
	r.contractId = &contractId
	return r
}

// The compatibility date for the request.
func (r ApiPostUiOpenwindowContractRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostUiOpenwindowContractRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiPostUiOpenwindowContractRequest) AcceptLanguage(acceptLanguage string) ApiPostUiOpenwindowContractRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostUiOpenwindowContractRequest) IfNoneMatch(ifNoneMatch string) ApiPostUiOpenwindowContractRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiPostUiOpenwindowContractRequest) XTenant(xTenant string) ApiPostUiOpenwindowContractRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostUiOpenwindowContractRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUiOpenwindowContractExecute(r)
}

/*
PostUiOpenwindowContract Open Contract Window

Open the contract window inside the client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUiOpenwindowContractRequest
*/
func (a *UserInterfaceAPIService) PostUiOpenwindowContract(ctx context.Context) ApiPostUiOpenwindowContractRequest {
	return ApiPostUiOpenwindowContractRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UserInterfaceAPIService) PostUiOpenwindowContractExecute(r ApiPostUiOpenwindowContractRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserInterfaceAPIService.PostUiOpenwindowContract")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ui/openwindow/contract"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contractId == nil {
		return nil, reportError("contractId is required and must be specified")
	}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return nil, reportError("xCompatibilityDate is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "contract_id", r.contractId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostUiOpenwindowInformationRequest struct {
	ctx context.Context
	ApiService UserInterfaceAPI
	targetId *int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

func (r ApiPostUiOpenwindowInformationRequest) TargetId(targetId int64) ApiPostUiOpenwindowInformationRequest {
	r.targetId = &targetId
	return r
}

// The compatibility date for the request.
func (r ApiPostUiOpenwindowInformationRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostUiOpenwindowInformationRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiPostUiOpenwindowInformationRequest) AcceptLanguage(acceptLanguage string) ApiPostUiOpenwindowInformationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostUiOpenwindowInformationRequest) IfNoneMatch(ifNoneMatch string) ApiPostUiOpenwindowInformationRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiPostUiOpenwindowInformationRequest) XTenant(xTenant string) ApiPostUiOpenwindowInformationRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostUiOpenwindowInformationRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUiOpenwindowInformationExecute(r)
}

/*
PostUiOpenwindowInformation Open Information Window

Open the information window for a character, corporation or alliance inside the client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUiOpenwindowInformationRequest
*/
func (a *UserInterfaceAPIService) PostUiOpenwindowInformation(ctx context.Context) ApiPostUiOpenwindowInformationRequest {
	return ApiPostUiOpenwindowInformationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UserInterfaceAPIService) PostUiOpenwindowInformationExecute(r ApiPostUiOpenwindowInformationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserInterfaceAPIService.PostUiOpenwindowInformation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ui/openwindow/information"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.targetId == nil {
		return nil, reportError("targetId is required and must be specified")
	}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return nil, reportError("xCompatibilityDate is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "target_id", r.targetId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostUiOpenwindowMarketdetailsRequest struct {
	ctx context.Context
	ApiService UserInterfaceAPI
	typeId *int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

func (r ApiPostUiOpenwindowMarketdetailsRequest) TypeId(typeId int64) ApiPostUiOpenwindowMarketdetailsRequest {
	r.typeId = &typeId
	return r
}

// The compatibility date for the request.
func (r ApiPostUiOpenwindowMarketdetailsRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostUiOpenwindowMarketdetailsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiPostUiOpenwindowMarketdetailsRequest) AcceptLanguage(acceptLanguage string) ApiPostUiOpenwindowMarketdetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostUiOpenwindowMarketdetailsRequest) IfNoneMatch(ifNoneMatch string) ApiPostUiOpenwindowMarketdetailsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiPostUiOpenwindowMarketdetailsRequest) XTenant(xTenant string) ApiPostUiOpenwindowMarketdetailsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostUiOpenwindowMarketdetailsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUiOpenwindowMarketdetailsExecute(r)
}

/*
PostUiOpenwindowMarketdetails Open Market Details

Open the market details window for a specific typeID inside the client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUiOpenwindowMarketdetailsRequest
*/
func (a *UserInterfaceAPIService) PostUiOpenwindowMarketdetails(ctx context.Context) ApiPostUiOpenwindowMarketdetailsRequest {
	return ApiPostUiOpenwindowMarketdetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UserInterfaceAPIService) PostUiOpenwindowMarketdetailsExecute(r ApiPostUiOpenwindowMarketdetailsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserInterfaceAPIService.PostUiOpenwindowMarketdetails")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ui/openwindow/marketdetails"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.typeId == nil {
		return nil, reportError("typeId is required and must be specified")
	}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return nil, reportError("xCompatibilityDate is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type_id", r.typeId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostUiOpenwindowNewmailRequest struct {
	ctx context.Context
	ApiService UserInterfaceAPI
	xCompatibilityDate *string
	postUiOpenwindowNewmailRequest *PostUiOpenwindowNewmailRequest
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiPostUiOpenwindowNewmailRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostUiOpenwindowNewmailRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiPostUiOpenwindowNewmailRequest) PostUiOpenwindowNewmailRequest(postUiOpenwindowNewmailRequest PostUiOpenwindowNewmailRequest) ApiPostUiOpenwindowNewmailRequest {
	r.postUiOpenwindowNewmailRequest = &postUiOpenwindowNewmailRequest
	return r
}

// The language to use for the response.
func (r ApiPostUiOpenwindowNewmailRequest) AcceptLanguage(acceptLanguage string) ApiPostUiOpenwindowNewmailRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostUiOpenwindowNewmailRequest) IfNoneMatch(ifNoneMatch string) ApiPostUiOpenwindowNewmailRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiPostUiOpenwindowNewmailRequest) XTenant(xTenant string) ApiPostUiOpenwindowNewmailRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostUiOpenwindowNewmailRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUiOpenwindowNewmailExecute(r)
}

/*
PostUiOpenwindowNewmail Open New Mail Window

Open the New Mail window, according to settings from the request if applicable

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUiOpenwindowNewmailRequest
*/
func (a *UserInterfaceAPIService) PostUiOpenwindowNewmail(ctx context.Context) ApiPostUiOpenwindowNewmailRequest {
	return ApiPostUiOpenwindowNewmailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UserInterfaceAPIService) PostUiOpenwindowNewmailExecute(r ApiPostUiOpenwindowNewmailRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserInterfaceAPIService.PostUiOpenwindowNewmail")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ui/openwindow/newmail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return nil, reportError("xCompatibilityDate is required and must be specified")
	}
	if r.postUiOpenwindowNewmailRequest == nil {
		return nil, reportError("postUiOpenwindowNewmailRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	// body params
	localVarPostBody = r.postUiOpenwindowNewmailRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
