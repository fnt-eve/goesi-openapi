/*
EVE Stable Infrastructure (ESI) - tranquility

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2020-01-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package esi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type MarketAPI interface {

	/*
	GetCharactersCharacterIdOrders List open orders from a character

	List open market orders placed by a character

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdOrdersRequest
	*/
	GetCharactersCharacterIdOrders(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdOrdersRequest

	// GetCharactersCharacterIdOrdersExecute executes the request
	//  @return []CharactersCharacterIdOrdersGetInner
	GetCharactersCharacterIdOrdersExecute(r ApiGetCharactersCharacterIdOrdersRequest) ([]CharactersCharacterIdOrdersGetInner, *http.Response, error)

	/*
	GetCharactersCharacterIdOrdersHistory List historical orders by a character

	List cancelled and expired market orders placed by a character up to 90 days in the past.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdOrdersHistoryRequest
	*/
	GetCharactersCharacterIdOrdersHistory(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdOrdersHistoryRequest

	// GetCharactersCharacterIdOrdersHistoryExecute executes the request
	//  @return []CharactersCharacterIdOrdersHistoryGetInner
	GetCharactersCharacterIdOrdersHistoryExecute(r ApiGetCharactersCharacterIdOrdersHistoryRequest) ([]CharactersCharacterIdOrdersHistoryGetInner, *http.Response, error)

	/*
	GetCorporationsCorporationIdOrders List open orders from a corporation

	List open market orders placed on behalf of a corporation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdOrdersRequest
	*/
	GetCorporationsCorporationIdOrders(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdOrdersRequest

	// GetCorporationsCorporationIdOrdersExecute executes the request
	//  @return []CorporationsCorporationIdOrdersGetInner
	GetCorporationsCorporationIdOrdersExecute(r ApiGetCorporationsCorporationIdOrdersRequest) ([]CorporationsCorporationIdOrdersGetInner, *http.Response, error)

	/*
	GetCorporationsCorporationIdOrdersHistory List historical orders from a corporation

	List cancelled and expired market orders placed on behalf of a corporation up to 90 days in the past.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdOrdersHistoryRequest
	*/
	GetCorporationsCorporationIdOrdersHistory(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdOrdersHistoryRequest

	// GetCorporationsCorporationIdOrdersHistoryExecute executes the request
	//  @return []CorporationsCorporationIdOrdersHistoryGetInner
	GetCorporationsCorporationIdOrdersHistoryExecute(r ApiGetCorporationsCorporationIdOrdersHistoryRequest) ([]CorporationsCorporationIdOrdersHistoryGetInner, *http.Response, error)

	/*
	GetMarketsGroups Get item groups

	Get a list of item groups

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetMarketsGroupsRequest
	*/
	GetMarketsGroups(ctx context.Context) ApiGetMarketsGroupsRequest

	// GetMarketsGroupsExecute executes the request
	//  @return []int64
	GetMarketsGroupsExecute(r ApiGetMarketsGroupsRequest) ([]int64, *http.Response, error)

	/*
	GetMarketsGroupsMarketGroupId Get item group information

	Get information on an item group

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param marketGroupId
	@return ApiGetMarketsGroupsMarketGroupIdRequest
	*/
	GetMarketsGroupsMarketGroupId(ctx context.Context, marketGroupId int64) ApiGetMarketsGroupsMarketGroupIdRequest

	// GetMarketsGroupsMarketGroupIdExecute executes the request
	//  @return MarketsGroupsMarketGroupIdGet
	GetMarketsGroupsMarketGroupIdExecute(r ApiGetMarketsGroupsMarketGroupIdRequest) (*MarketsGroupsMarketGroupIdGet, *http.Response, error)

	/*
	GetMarketsPrices List market prices

	Return a list of prices

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetMarketsPricesRequest
	*/
	GetMarketsPrices(ctx context.Context) ApiGetMarketsPricesRequest

	// GetMarketsPricesExecute executes the request
	//  @return []MarketsPricesGetInner
	GetMarketsPricesExecute(r ApiGetMarketsPricesRequest) ([]MarketsPricesGetInner, *http.Response, error)

	/*
	GetMarketsRegionIdHistory List historical market statistics in a region

	Return a list of historical market statistics for the specified type in a region

This route expires daily at 11:05

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param regionId
	@return ApiGetMarketsRegionIdHistoryRequest
	*/
	GetMarketsRegionIdHistory(ctx context.Context, regionId int64) ApiGetMarketsRegionIdHistoryRequest

	// GetMarketsRegionIdHistoryExecute executes the request
	//  @return []MarketsRegionIdHistoryGetInner
	GetMarketsRegionIdHistoryExecute(r ApiGetMarketsRegionIdHistoryRequest) ([]MarketsRegionIdHistoryGetInner, *http.Response, error)

	/*
	GetMarketsRegionIdOrders List orders in a region

	Return a list of orders in a region

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param regionId
	@return ApiGetMarketsRegionIdOrdersRequest
	*/
	GetMarketsRegionIdOrders(ctx context.Context, regionId int64) ApiGetMarketsRegionIdOrdersRequest

	// GetMarketsRegionIdOrdersExecute executes the request
	//  @return []MarketsRegionIdOrdersGetInner
	GetMarketsRegionIdOrdersExecute(r ApiGetMarketsRegionIdOrdersRequest) ([]MarketsRegionIdOrdersGetInner, *http.Response, error)

	/*
	GetMarketsRegionIdTypes List type IDs relevant to a market

	Return a list of type IDs that have active orders in the region, for efficient market indexing.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param regionId
	@return ApiGetMarketsRegionIdTypesRequest
	*/
	GetMarketsRegionIdTypes(ctx context.Context, regionId int64) ApiGetMarketsRegionIdTypesRequest

	// GetMarketsRegionIdTypesExecute executes the request
	//  @return []int64
	GetMarketsRegionIdTypesExecute(r ApiGetMarketsRegionIdTypesRequest) ([]int64, *http.Response, error)

	/*
	GetMarketsStructuresStructureId List orders in a structure

	Return all orders in a structure

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param structureId
	@return ApiGetMarketsStructuresStructureIdRequest
	*/
	GetMarketsStructuresStructureId(ctx context.Context, structureId int64) ApiGetMarketsStructuresStructureIdRequest

	// GetMarketsStructuresStructureIdExecute executes the request
	//  @return []MarketsStructuresStructureIdGetInner
	GetMarketsStructuresStructureIdExecute(r ApiGetMarketsStructuresStructureIdRequest) ([]MarketsStructuresStructureIdGetInner, *http.Response, error)
}

// MarketAPIService MarketAPI service
type MarketAPIService service

type ApiGetCharactersCharacterIdOrdersRequest struct {
	ctx context.Context
	ApiService MarketAPI
	characterId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdOrdersRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdOrdersRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdOrdersRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdOrdersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdOrdersRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdOrdersRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdOrdersRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdOrdersRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdOrdersRequest) Execute() ([]CharactersCharacterIdOrdersGetInner, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdOrdersExecute(r)
}

/*
GetCharactersCharacterIdOrders List open orders from a character

List open market orders placed by a character

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdOrdersRequest
*/
func (a *MarketAPIService) GetCharactersCharacterIdOrders(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdOrdersRequest {
	return ApiGetCharactersCharacterIdOrdersRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return []CharactersCharacterIdOrdersGetInner
func (a *MarketAPIService) GetCharactersCharacterIdOrdersExecute(r ApiGetCharactersCharacterIdOrdersRequest) ([]CharactersCharacterIdOrdersGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharactersCharacterIdOrdersGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketAPIService.GetCharactersCharacterIdOrders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/orders"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCharactersCharacterIdOrdersHistoryRequest struct {
	ctx context.Context
	ApiService MarketAPI
	characterId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdOrdersHistoryRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdOrdersHistoryRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCharactersCharacterIdOrdersHistoryRequest) Page(page int32) ApiGetCharactersCharacterIdOrdersHistoryRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdOrdersHistoryRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdOrdersHistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdOrdersHistoryRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdOrdersHistoryRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdOrdersHistoryRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdOrdersHistoryRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdOrdersHistoryRequest) Execute() ([]CharactersCharacterIdOrdersHistoryGetInner, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdOrdersHistoryExecute(r)
}

/*
GetCharactersCharacterIdOrdersHistory List historical orders by a character

List cancelled and expired market orders placed by a character up to 90 days in the past.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdOrdersHistoryRequest
*/
func (a *MarketAPIService) GetCharactersCharacterIdOrdersHistory(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdOrdersHistoryRequest {
	return ApiGetCharactersCharacterIdOrdersHistoryRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return []CharactersCharacterIdOrdersHistoryGetInner
func (a *MarketAPIService) GetCharactersCharacterIdOrdersHistoryExecute(r ApiGetCharactersCharacterIdOrdersHistoryRequest) ([]CharactersCharacterIdOrdersHistoryGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharactersCharacterIdOrdersHistoryGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketAPIService.GetCharactersCharacterIdOrdersHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/orders/history"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdOrdersRequest struct {
	ctx context.Context
	ApiService MarketAPI
	corporationId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdOrdersRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdOrdersRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCorporationsCorporationIdOrdersRequest) Page(page int32) ApiGetCorporationsCorporationIdOrdersRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdOrdersRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdOrdersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdOrdersRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdOrdersRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdOrdersRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdOrdersRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdOrdersRequest) Execute() ([]CorporationsCorporationIdOrdersGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdOrdersExecute(r)
}

/*
GetCorporationsCorporationIdOrders List open orders from a corporation

List open market orders placed on behalf of a corporation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdOrdersRequest
*/
func (a *MarketAPIService) GetCorporationsCorporationIdOrders(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdOrdersRequest {
	return ApiGetCorporationsCorporationIdOrdersRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CorporationsCorporationIdOrdersGetInner
func (a *MarketAPIService) GetCorporationsCorporationIdOrdersExecute(r ApiGetCorporationsCorporationIdOrdersRequest) ([]CorporationsCorporationIdOrdersGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CorporationsCorporationIdOrdersGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketAPIService.GetCorporationsCorporationIdOrders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/orders"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdOrdersHistoryRequest struct {
	ctx context.Context
	ApiService MarketAPI
	corporationId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdOrdersHistoryRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdOrdersHistoryRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCorporationsCorporationIdOrdersHistoryRequest) Page(page int32) ApiGetCorporationsCorporationIdOrdersHistoryRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdOrdersHistoryRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdOrdersHistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdOrdersHistoryRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdOrdersHistoryRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdOrdersHistoryRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdOrdersHistoryRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdOrdersHistoryRequest) Execute() ([]CorporationsCorporationIdOrdersHistoryGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdOrdersHistoryExecute(r)
}

/*
GetCorporationsCorporationIdOrdersHistory List historical orders from a corporation

List cancelled and expired market orders placed on behalf of a corporation up to 90 days in the past.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdOrdersHistoryRequest
*/
func (a *MarketAPIService) GetCorporationsCorporationIdOrdersHistory(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdOrdersHistoryRequest {
	return ApiGetCorporationsCorporationIdOrdersHistoryRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CorporationsCorporationIdOrdersHistoryGetInner
func (a *MarketAPIService) GetCorporationsCorporationIdOrdersHistoryExecute(r ApiGetCorporationsCorporationIdOrdersHistoryRequest) ([]CorporationsCorporationIdOrdersHistoryGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CorporationsCorporationIdOrdersHistoryGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketAPIService.GetCorporationsCorporationIdOrdersHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/orders/history"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketsGroupsRequest struct {
	ctx context.Context
	ApiService MarketAPI
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetMarketsGroupsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetMarketsGroupsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetMarketsGroupsRequest) AcceptLanguage(acceptLanguage string) ApiGetMarketsGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetMarketsGroupsRequest) IfNoneMatch(ifNoneMatch string) ApiGetMarketsGroupsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetMarketsGroupsRequest) XTenant(xTenant string) ApiGetMarketsGroupsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetMarketsGroupsRequest) Execute() ([]int64, *http.Response, error) {
	return r.ApiService.GetMarketsGroupsExecute(r)
}

/*
GetMarketsGroups Get item groups

Get a list of item groups

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketsGroupsRequest
*/
func (a *MarketAPIService) GetMarketsGroups(ctx context.Context) ApiGetMarketsGroupsRequest {
	return ApiGetMarketsGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []int64
func (a *MarketAPIService) GetMarketsGroupsExecute(r ApiGetMarketsGroupsRequest) ([]int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketAPIService.GetMarketsGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/markets/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketsGroupsMarketGroupIdRequest struct {
	ctx context.Context
	ApiService MarketAPI
	marketGroupId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetMarketsGroupsMarketGroupIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetMarketsGroupsMarketGroupIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetMarketsGroupsMarketGroupIdRequest) AcceptLanguage(acceptLanguage string) ApiGetMarketsGroupsMarketGroupIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetMarketsGroupsMarketGroupIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetMarketsGroupsMarketGroupIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetMarketsGroupsMarketGroupIdRequest) XTenant(xTenant string) ApiGetMarketsGroupsMarketGroupIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetMarketsGroupsMarketGroupIdRequest) Execute() (*MarketsGroupsMarketGroupIdGet, *http.Response, error) {
	return r.ApiService.GetMarketsGroupsMarketGroupIdExecute(r)
}

/*
GetMarketsGroupsMarketGroupId Get item group information

Get information on an item group

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param marketGroupId
 @return ApiGetMarketsGroupsMarketGroupIdRequest
*/
func (a *MarketAPIService) GetMarketsGroupsMarketGroupId(ctx context.Context, marketGroupId int64) ApiGetMarketsGroupsMarketGroupIdRequest {
	return ApiGetMarketsGroupsMarketGroupIdRequest{
		ApiService: a,
		ctx: ctx,
		marketGroupId: marketGroupId,
	}
}

// Execute executes the request
//  @return MarketsGroupsMarketGroupIdGet
func (a *MarketAPIService) GetMarketsGroupsMarketGroupIdExecute(r ApiGetMarketsGroupsMarketGroupIdRequest) (*MarketsGroupsMarketGroupIdGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarketsGroupsMarketGroupIdGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketAPIService.GetMarketsGroupsMarketGroupId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/markets/groups/{market_group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"market_group_id"+"}", url.PathEscape(parameterValueToString(r.marketGroupId, "marketGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketsPricesRequest struct {
	ctx context.Context
	ApiService MarketAPI
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetMarketsPricesRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetMarketsPricesRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetMarketsPricesRequest) AcceptLanguage(acceptLanguage string) ApiGetMarketsPricesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetMarketsPricesRequest) IfNoneMatch(ifNoneMatch string) ApiGetMarketsPricesRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetMarketsPricesRequest) XTenant(xTenant string) ApiGetMarketsPricesRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetMarketsPricesRequest) Execute() ([]MarketsPricesGetInner, *http.Response, error) {
	return r.ApiService.GetMarketsPricesExecute(r)
}

/*
GetMarketsPrices List market prices

Return a list of prices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketsPricesRequest
*/
func (a *MarketAPIService) GetMarketsPrices(ctx context.Context) ApiGetMarketsPricesRequest {
	return ApiGetMarketsPricesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MarketsPricesGetInner
func (a *MarketAPIService) GetMarketsPricesExecute(r ApiGetMarketsPricesRequest) ([]MarketsPricesGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MarketsPricesGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketAPIService.GetMarketsPrices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/markets/prices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketsRegionIdHistoryRequest struct {
	ctx context.Context
	ApiService MarketAPI
	regionId int64
	typeId *int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

func (r ApiGetMarketsRegionIdHistoryRequest) TypeId(typeId int64) ApiGetMarketsRegionIdHistoryRequest {
	r.typeId = &typeId
	return r
}

// The compatibility date for the request.
func (r ApiGetMarketsRegionIdHistoryRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetMarketsRegionIdHistoryRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetMarketsRegionIdHistoryRequest) AcceptLanguage(acceptLanguage string) ApiGetMarketsRegionIdHistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetMarketsRegionIdHistoryRequest) IfNoneMatch(ifNoneMatch string) ApiGetMarketsRegionIdHistoryRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetMarketsRegionIdHistoryRequest) XTenant(xTenant string) ApiGetMarketsRegionIdHistoryRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetMarketsRegionIdHistoryRequest) Execute() ([]MarketsRegionIdHistoryGetInner, *http.Response, error) {
	return r.ApiService.GetMarketsRegionIdHistoryExecute(r)
}

/*
GetMarketsRegionIdHistory List historical market statistics in a region

Return a list of historical market statistics for the specified type in a region

This route expires daily at 11:05

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param regionId
 @return ApiGetMarketsRegionIdHistoryRequest
*/
func (a *MarketAPIService) GetMarketsRegionIdHistory(ctx context.Context, regionId int64) ApiGetMarketsRegionIdHistoryRequest {
	return ApiGetMarketsRegionIdHistoryRequest{
		ApiService: a,
		ctx: ctx,
		regionId: regionId,
	}
}

// Execute executes the request
//  @return []MarketsRegionIdHistoryGetInner
func (a *MarketAPIService) GetMarketsRegionIdHistoryExecute(r ApiGetMarketsRegionIdHistoryRequest) ([]MarketsRegionIdHistoryGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MarketsRegionIdHistoryGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketAPIService.GetMarketsRegionIdHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/markets/{region_id}/history"
	localVarPath = strings.Replace(localVarPath, "{"+"region_id"+"}", url.PathEscape(parameterValueToString(r.regionId, "regionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.typeId == nil {
		return localVarReturnValue, nil, reportError("typeId is required and must be specified")
	}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type_id", r.typeId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketsRegionIdOrdersRequest struct {
	ctx context.Context
	ApiService MarketAPI
	orderType *string
	regionId int64
	xCompatibilityDate *string
	page *int32
	typeId *int64
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

func (r ApiGetMarketsRegionIdOrdersRequest) OrderType(orderType string) ApiGetMarketsRegionIdOrdersRequest {
	r.orderType = &orderType
	return r
}

// The compatibility date for the request.
func (r ApiGetMarketsRegionIdOrdersRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetMarketsRegionIdOrdersRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetMarketsRegionIdOrdersRequest) Page(page int32) ApiGetMarketsRegionIdOrdersRequest {
	r.page = &page
	return r
}

func (r ApiGetMarketsRegionIdOrdersRequest) TypeId(typeId int64) ApiGetMarketsRegionIdOrdersRequest {
	r.typeId = &typeId
	return r
}

// The language to use for the response.
func (r ApiGetMarketsRegionIdOrdersRequest) AcceptLanguage(acceptLanguage string) ApiGetMarketsRegionIdOrdersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetMarketsRegionIdOrdersRequest) IfNoneMatch(ifNoneMatch string) ApiGetMarketsRegionIdOrdersRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetMarketsRegionIdOrdersRequest) XTenant(xTenant string) ApiGetMarketsRegionIdOrdersRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetMarketsRegionIdOrdersRequest) Execute() ([]MarketsRegionIdOrdersGetInner, *http.Response, error) {
	return r.ApiService.GetMarketsRegionIdOrdersExecute(r)
}

/*
GetMarketsRegionIdOrders List orders in a region

Return a list of orders in a region

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param regionId
 @return ApiGetMarketsRegionIdOrdersRequest
*/
func (a *MarketAPIService) GetMarketsRegionIdOrders(ctx context.Context, regionId int64) ApiGetMarketsRegionIdOrdersRequest {
	return ApiGetMarketsRegionIdOrdersRequest{
		ApiService: a,
		ctx: ctx,
		regionId: regionId,
	}
}

// Execute executes the request
//  @return []MarketsRegionIdOrdersGetInner
func (a *MarketAPIService) GetMarketsRegionIdOrdersExecute(r ApiGetMarketsRegionIdOrdersRequest) ([]MarketsRegionIdOrdersGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MarketsRegionIdOrdersGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketAPIService.GetMarketsRegionIdOrders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/markets/{region_id}/orders"
	localVarPath = strings.Replace(localVarPath, "{"+"region_id"+"}", url.PathEscape(parameterValueToString(r.regionId, "regionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orderType == nil {
		return localVarReturnValue, nil, reportError("orderType is required and must be specified")
	}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "order_type", r.orderType, "form", "")
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.typeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type_id", r.typeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketsRegionIdTypesRequest struct {
	ctx context.Context
	ApiService MarketAPI
	regionId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetMarketsRegionIdTypesRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetMarketsRegionIdTypesRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetMarketsRegionIdTypesRequest) Page(page int32) ApiGetMarketsRegionIdTypesRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetMarketsRegionIdTypesRequest) AcceptLanguage(acceptLanguage string) ApiGetMarketsRegionIdTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetMarketsRegionIdTypesRequest) IfNoneMatch(ifNoneMatch string) ApiGetMarketsRegionIdTypesRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetMarketsRegionIdTypesRequest) XTenant(xTenant string) ApiGetMarketsRegionIdTypesRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetMarketsRegionIdTypesRequest) Execute() ([]int64, *http.Response, error) {
	return r.ApiService.GetMarketsRegionIdTypesExecute(r)
}

/*
GetMarketsRegionIdTypes List type IDs relevant to a market

Return a list of type IDs that have active orders in the region, for efficient market indexing.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param regionId
 @return ApiGetMarketsRegionIdTypesRequest
*/
func (a *MarketAPIService) GetMarketsRegionIdTypes(ctx context.Context, regionId int64) ApiGetMarketsRegionIdTypesRequest {
	return ApiGetMarketsRegionIdTypesRequest{
		ApiService: a,
		ctx: ctx,
		regionId: regionId,
	}
}

// Execute executes the request
//  @return []int64
func (a *MarketAPIService) GetMarketsRegionIdTypesExecute(r ApiGetMarketsRegionIdTypesRequest) ([]int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketAPIService.GetMarketsRegionIdTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/markets/{region_id}/types"
	localVarPath = strings.Replace(localVarPath, "{"+"region_id"+"}", url.PathEscape(parameterValueToString(r.regionId, "regionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketsStructuresStructureIdRequest struct {
	ctx context.Context
	ApiService MarketAPI
	structureId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetMarketsStructuresStructureIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetMarketsStructuresStructureIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetMarketsStructuresStructureIdRequest) Page(page int32) ApiGetMarketsStructuresStructureIdRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetMarketsStructuresStructureIdRequest) AcceptLanguage(acceptLanguage string) ApiGetMarketsStructuresStructureIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetMarketsStructuresStructureIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetMarketsStructuresStructureIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetMarketsStructuresStructureIdRequest) XTenant(xTenant string) ApiGetMarketsStructuresStructureIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetMarketsStructuresStructureIdRequest) Execute() ([]MarketsStructuresStructureIdGetInner, *http.Response, error) {
	return r.ApiService.GetMarketsStructuresStructureIdExecute(r)
}

/*
GetMarketsStructuresStructureId List orders in a structure

Return all orders in a structure

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param structureId
 @return ApiGetMarketsStructuresStructureIdRequest
*/
func (a *MarketAPIService) GetMarketsStructuresStructureId(ctx context.Context, structureId int64) ApiGetMarketsStructuresStructureIdRequest {
	return ApiGetMarketsStructuresStructureIdRequest{
		ApiService: a,
		ctx: ctx,
		structureId: structureId,
	}
}

// Execute executes the request
//  @return []MarketsStructuresStructureIdGetInner
func (a *MarketAPIService) GetMarketsStructuresStructureIdExecute(r ApiGetMarketsStructuresStructureIdRequest) ([]MarketsStructuresStructureIdGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MarketsStructuresStructureIdGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketAPIService.GetMarketsStructuresStructureId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/markets/structures/{structure_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"structure_id"+"}", url.PathEscape(parameterValueToString(r.structureId, "structureId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
