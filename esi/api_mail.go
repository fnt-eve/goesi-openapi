/*
EVE Stable Infrastructure (ESI) - tranquility

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2020-01-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package esi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


type MailAPI interface {

	/*
	DeleteCharactersCharacterIdMailLabelsLabelId Delete a mail label

	Delete a mail label

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@param labelId
	@return ApiDeleteCharactersCharacterIdMailLabelsLabelIdRequest
	*/
	DeleteCharactersCharacterIdMailLabelsLabelId(ctx context.Context, characterId int64, labelId int64) ApiDeleteCharactersCharacterIdMailLabelsLabelIdRequest

	// DeleteCharactersCharacterIdMailLabelsLabelIdExecute executes the request
	DeleteCharactersCharacterIdMailLabelsLabelIdExecute(r ApiDeleteCharactersCharacterIdMailLabelsLabelIdRequest) (*http.Response, error)

	/*
	DeleteCharactersCharacterIdMailMailId Delete a mail

	Delete a mail

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@param mailId
	@return ApiDeleteCharactersCharacterIdMailMailIdRequest
	*/
	DeleteCharactersCharacterIdMailMailId(ctx context.Context, characterId int64, mailId int64) ApiDeleteCharactersCharacterIdMailMailIdRequest

	// DeleteCharactersCharacterIdMailMailIdExecute executes the request
	DeleteCharactersCharacterIdMailMailIdExecute(r ApiDeleteCharactersCharacterIdMailMailIdRequest) (*http.Response, error)

	/*
	GetCharactersCharacterIdMail Return mail headers

	Return the 50 most recent mail headers belonging to the character that match the query criteria. Queries can be filtered by label, and last_mail_id can be used to paginate backwards

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdMailRequest
	*/
	GetCharactersCharacterIdMail(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdMailRequest

	// GetCharactersCharacterIdMailExecute executes the request
	//  @return []CharactersCharacterIdMailGetInner
	GetCharactersCharacterIdMailExecute(r ApiGetCharactersCharacterIdMailRequest) ([]CharactersCharacterIdMailGetInner, *http.Response, error)

	/*
	GetCharactersCharacterIdMailLabels Get mail labels and unread counts

	Return a list of the users mail labels, unread counts for each label and a total unread count.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdMailLabelsRequest
	*/
	GetCharactersCharacterIdMailLabels(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdMailLabelsRequest

	// GetCharactersCharacterIdMailLabelsExecute executes the request
	//  @return CharactersCharacterIdMailLabelsGet
	GetCharactersCharacterIdMailLabelsExecute(r ApiGetCharactersCharacterIdMailLabelsRequest) (*CharactersCharacterIdMailLabelsGet, *http.Response, error)

	/*
	GetCharactersCharacterIdMailLists Return mailing list subscriptions

	Return all mailing lists that the character is subscribed to

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdMailListsRequest
	*/
	GetCharactersCharacterIdMailLists(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdMailListsRequest

	// GetCharactersCharacterIdMailListsExecute executes the request
	//  @return []CharactersCharacterIdMailListsGetInner
	GetCharactersCharacterIdMailListsExecute(r ApiGetCharactersCharacterIdMailListsRequest) ([]CharactersCharacterIdMailListsGetInner, *http.Response, error)

	/*
	GetCharactersCharacterIdMailMailId Return a mail

	Return the contents of an EVE mail

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@param mailId
	@return ApiGetCharactersCharacterIdMailMailIdRequest
	*/
	GetCharactersCharacterIdMailMailId(ctx context.Context, characterId int64, mailId int64) ApiGetCharactersCharacterIdMailMailIdRequest

	// GetCharactersCharacterIdMailMailIdExecute executes the request
	//  @return CharactersCharacterIdMailMailIdGet
	GetCharactersCharacterIdMailMailIdExecute(r ApiGetCharactersCharacterIdMailMailIdRequest) (*CharactersCharacterIdMailMailIdGet, *http.Response, error)

	/*
	PostCharactersCharacterIdMail Send a new mail

	Create and send a new mail

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiPostCharactersCharacterIdMailRequest
	*/
	PostCharactersCharacterIdMail(ctx context.Context, characterId int64) ApiPostCharactersCharacterIdMailRequest

	// PostCharactersCharacterIdMailExecute executes the request
	//  @return int64
	PostCharactersCharacterIdMailExecute(r ApiPostCharactersCharacterIdMailRequest) (int64, *http.Response, error)

	/*
	PostCharactersCharacterIdMailLabels Create a mail label

	Create a mail label

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiPostCharactersCharacterIdMailLabelsRequest
	*/
	PostCharactersCharacterIdMailLabels(ctx context.Context, characterId int64) ApiPostCharactersCharacterIdMailLabelsRequest

	// PostCharactersCharacterIdMailLabelsExecute executes the request
	//  @return int64
	PostCharactersCharacterIdMailLabelsExecute(r ApiPostCharactersCharacterIdMailLabelsRequest) (int64, *http.Response, error)

	/*
	PutCharactersCharacterIdMailMailId Update metadata about a mail

	Update metadata about a mail

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@param mailId
	@return ApiPutCharactersCharacterIdMailMailIdRequest
	*/
	PutCharactersCharacterIdMailMailId(ctx context.Context, characterId int64, mailId int64) ApiPutCharactersCharacterIdMailMailIdRequest

	// PutCharactersCharacterIdMailMailIdExecute executes the request
	PutCharactersCharacterIdMailMailIdExecute(r ApiPutCharactersCharacterIdMailMailIdRequest) (*http.Response, error)
}

// MailAPIService MailAPI service
type MailAPIService service

type ApiDeleteCharactersCharacterIdMailLabelsLabelIdRequest struct {
	ctx context.Context
	ApiService MailAPI
	characterId int64
	labelId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiDeleteCharactersCharacterIdMailLabelsLabelIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiDeleteCharactersCharacterIdMailLabelsLabelIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiDeleteCharactersCharacterIdMailLabelsLabelIdRequest) AcceptLanguage(acceptLanguage string) ApiDeleteCharactersCharacterIdMailLabelsLabelIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiDeleteCharactersCharacterIdMailLabelsLabelIdRequest) IfNoneMatch(ifNoneMatch string) ApiDeleteCharactersCharacterIdMailLabelsLabelIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiDeleteCharactersCharacterIdMailLabelsLabelIdRequest) XTenant(xTenant string) ApiDeleteCharactersCharacterIdMailLabelsLabelIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiDeleteCharactersCharacterIdMailLabelsLabelIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCharactersCharacterIdMailLabelsLabelIdExecute(r)
}

/*
DeleteCharactersCharacterIdMailLabelsLabelId Delete a mail label

Delete a mail label

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @param labelId
 @return ApiDeleteCharactersCharacterIdMailLabelsLabelIdRequest
*/
func (a *MailAPIService) DeleteCharactersCharacterIdMailLabelsLabelId(ctx context.Context, characterId int64, labelId int64) ApiDeleteCharactersCharacterIdMailLabelsLabelIdRequest {
	return ApiDeleteCharactersCharacterIdMailLabelsLabelIdRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
		labelId: labelId,
	}
}

// Execute executes the request
func (a *MailAPIService) DeleteCharactersCharacterIdMailLabelsLabelIdExecute(r ApiDeleteCharactersCharacterIdMailLabelsLabelIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MailAPIService.DeleteCharactersCharacterIdMailLabelsLabelId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/mail/labels/{label_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"label_id"+"}", url.PathEscape(parameterValueToString(r.labelId, "labelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteCharactersCharacterIdMailMailIdRequest struct {
	ctx context.Context
	ApiService MailAPI
	characterId int64
	mailId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiDeleteCharactersCharacterIdMailMailIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiDeleteCharactersCharacterIdMailMailIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiDeleteCharactersCharacterIdMailMailIdRequest) AcceptLanguage(acceptLanguage string) ApiDeleteCharactersCharacterIdMailMailIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiDeleteCharactersCharacterIdMailMailIdRequest) IfNoneMatch(ifNoneMatch string) ApiDeleteCharactersCharacterIdMailMailIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiDeleteCharactersCharacterIdMailMailIdRequest) XTenant(xTenant string) ApiDeleteCharactersCharacterIdMailMailIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiDeleteCharactersCharacterIdMailMailIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCharactersCharacterIdMailMailIdExecute(r)
}

/*
DeleteCharactersCharacterIdMailMailId Delete a mail

Delete a mail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @param mailId
 @return ApiDeleteCharactersCharacterIdMailMailIdRequest
*/
func (a *MailAPIService) DeleteCharactersCharacterIdMailMailId(ctx context.Context, characterId int64, mailId int64) ApiDeleteCharactersCharacterIdMailMailIdRequest {
	return ApiDeleteCharactersCharacterIdMailMailIdRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
		mailId: mailId,
	}
}

// Execute executes the request
func (a *MailAPIService) DeleteCharactersCharacterIdMailMailIdExecute(r ApiDeleteCharactersCharacterIdMailMailIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MailAPIService.DeleteCharactersCharacterIdMailMailId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/mail/{mail_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mail_id"+"}", url.PathEscape(parameterValueToString(r.mailId, "mailId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCharactersCharacterIdMailRequest struct {
	ctx context.Context
	ApiService MailAPI
	characterId int64
	xCompatibilityDate *string
	labels *[]int64
	lastMailId *int64
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdMailRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdMailRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCharactersCharacterIdMailRequest) Labels(labels []int64) ApiGetCharactersCharacterIdMailRequest {
	r.labels = &labels
	return r
}

func (r ApiGetCharactersCharacterIdMailRequest) LastMailId(lastMailId int64) ApiGetCharactersCharacterIdMailRequest {
	r.lastMailId = &lastMailId
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdMailRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdMailRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdMailRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdMailRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdMailRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdMailRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdMailRequest) Execute() ([]CharactersCharacterIdMailGetInner, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdMailExecute(r)
}

/*
GetCharactersCharacterIdMail Return mail headers

Return the 50 most recent mail headers belonging to the character that match the query criteria. Queries can be filtered by label, and last_mail_id can be used to paginate backwards

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdMailRequest
*/
func (a *MailAPIService) GetCharactersCharacterIdMail(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdMailRequest {
	return ApiGetCharactersCharacterIdMailRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return []CharactersCharacterIdMailGetInner
func (a *MailAPIService) GetCharactersCharacterIdMailExecute(r ApiGetCharactersCharacterIdMailRequest) ([]CharactersCharacterIdMailGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharactersCharacterIdMailGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MailAPIService.GetCharactersCharacterIdMail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/mail"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.labels != nil {
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels", t, "form", "multi")
		}
	}
	if r.lastMailId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_mail_id", r.lastMailId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCharactersCharacterIdMailLabelsRequest struct {
	ctx context.Context
	ApiService MailAPI
	characterId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdMailLabelsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdMailLabelsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdMailLabelsRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdMailLabelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdMailLabelsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdMailLabelsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdMailLabelsRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdMailLabelsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdMailLabelsRequest) Execute() (*CharactersCharacterIdMailLabelsGet, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdMailLabelsExecute(r)
}

/*
GetCharactersCharacterIdMailLabels Get mail labels and unread counts

Return a list of the users mail labels, unread counts for each label and a total unread count.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdMailLabelsRequest
*/
func (a *MailAPIService) GetCharactersCharacterIdMailLabels(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdMailLabelsRequest {
	return ApiGetCharactersCharacterIdMailLabelsRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return CharactersCharacterIdMailLabelsGet
func (a *MailAPIService) GetCharactersCharacterIdMailLabelsExecute(r ApiGetCharactersCharacterIdMailLabelsRequest) (*CharactersCharacterIdMailLabelsGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CharactersCharacterIdMailLabelsGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MailAPIService.GetCharactersCharacterIdMailLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/mail/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCharactersCharacterIdMailListsRequest struct {
	ctx context.Context
	ApiService MailAPI
	characterId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdMailListsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdMailListsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdMailListsRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdMailListsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdMailListsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdMailListsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdMailListsRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdMailListsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdMailListsRequest) Execute() ([]CharactersCharacterIdMailListsGetInner, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdMailListsExecute(r)
}

/*
GetCharactersCharacterIdMailLists Return mailing list subscriptions

Return all mailing lists that the character is subscribed to

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdMailListsRequest
*/
func (a *MailAPIService) GetCharactersCharacterIdMailLists(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdMailListsRequest {
	return ApiGetCharactersCharacterIdMailListsRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return []CharactersCharacterIdMailListsGetInner
func (a *MailAPIService) GetCharactersCharacterIdMailListsExecute(r ApiGetCharactersCharacterIdMailListsRequest) ([]CharactersCharacterIdMailListsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharactersCharacterIdMailListsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MailAPIService.GetCharactersCharacterIdMailLists")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/mail/lists"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCharactersCharacterIdMailMailIdRequest struct {
	ctx context.Context
	ApiService MailAPI
	characterId int64
	mailId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdMailMailIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdMailMailIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdMailMailIdRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdMailMailIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdMailMailIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdMailMailIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdMailMailIdRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdMailMailIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdMailMailIdRequest) Execute() (*CharactersCharacterIdMailMailIdGet, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdMailMailIdExecute(r)
}

/*
GetCharactersCharacterIdMailMailId Return a mail

Return the contents of an EVE mail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @param mailId
 @return ApiGetCharactersCharacterIdMailMailIdRequest
*/
func (a *MailAPIService) GetCharactersCharacterIdMailMailId(ctx context.Context, characterId int64, mailId int64) ApiGetCharactersCharacterIdMailMailIdRequest {
	return ApiGetCharactersCharacterIdMailMailIdRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
		mailId: mailId,
	}
}

// Execute executes the request
//  @return CharactersCharacterIdMailMailIdGet
func (a *MailAPIService) GetCharactersCharacterIdMailMailIdExecute(r ApiGetCharactersCharacterIdMailMailIdRequest) (*CharactersCharacterIdMailMailIdGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CharactersCharacterIdMailMailIdGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MailAPIService.GetCharactersCharacterIdMailMailId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/mail/{mail_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mail_id"+"}", url.PathEscape(parameterValueToString(r.mailId, "mailId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCharactersCharacterIdMailRequest struct {
	ctx context.Context
	ApiService MailAPI
	characterId int64
	xCompatibilityDate *string
	postCharactersCharacterIdMailRequest *PostCharactersCharacterIdMailRequest
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiPostCharactersCharacterIdMailRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostCharactersCharacterIdMailRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiPostCharactersCharacterIdMailRequest) PostCharactersCharacterIdMailRequest(postCharactersCharacterIdMailRequest PostCharactersCharacterIdMailRequest) ApiPostCharactersCharacterIdMailRequest {
	r.postCharactersCharacterIdMailRequest = &postCharactersCharacterIdMailRequest
	return r
}

// The language to use for the response.
func (r ApiPostCharactersCharacterIdMailRequest) AcceptLanguage(acceptLanguage string) ApiPostCharactersCharacterIdMailRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostCharactersCharacterIdMailRequest) IfNoneMatch(ifNoneMatch string) ApiPostCharactersCharacterIdMailRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiPostCharactersCharacterIdMailRequest) XTenant(xTenant string) ApiPostCharactersCharacterIdMailRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostCharactersCharacterIdMailRequest) Execute() (int64, *http.Response, error) {
	return r.ApiService.PostCharactersCharacterIdMailExecute(r)
}

/*
PostCharactersCharacterIdMail Send a new mail

Create and send a new mail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiPostCharactersCharacterIdMailRequest
*/
func (a *MailAPIService) PostCharactersCharacterIdMail(ctx context.Context, characterId int64) ApiPostCharactersCharacterIdMailRequest {
	return ApiPostCharactersCharacterIdMailRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return int64
func (a *MailAPIService) PostCharactersCharacterIdMailExecute(r ApiPostCharactersCharacterIdMailRequest) (int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MailAPIService.PostCharactersCharacterIdMail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/mail"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}
	if r.postCharactersCharacterIdMailRequest == nil {
		return localVarReturnValue, nil, reportError("postCharactersCharacterIdMailRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	// body params
	localVarPostBody = r.postCharactersCharacterIdMailRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCharactersCharacterIdMailLabelsRequest struct {
	ctx context.Context
	ApiService MailAPI
	characterId int64
	xCompatibilityDate *string
	postCharactersCharacterIdMailLabelsRequest *PostCharactersCharacterIdMailLabelsRequest
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiPostCharactersCharacterIdMailLabelsRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostCharactersCharacterIdMailLabelsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiPostCharactersCharacterIdMailLabelsRequest) PostCharactersCharacterIdMailLabelsRequest(postCharactersCharacterIdMailLabelsRequest PostCharactersCharacterIdMailLabelsRequest) ApiPostCharactersCharacterIdMailLabelsRequest {
	r.postCharactersCharacterIdMailLabelsRequest = &postCharactersCharacterIdMailLabelsRequest
	return r
}

// The language to use for the response.
func (r ApiPostCharactersCharacterIdMailLabelsRequest) AcceptLanguage(acceptLanguage string) ApiPostCharactersCharacterIdMailLabelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostCharactersCharacterIdMailLabelsRequest) IfNoneMatch(ifNoneMatch string) ApiPostCharactersCharacterIdMailLabelsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiPostCharactersCharacterIdMailLabelsRequest) XTenant(xTenant string) ApiPostCharactersCharacterIdMailLabelsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostCharactersCharacterIdMailLabelsRequest) Execute() (int64, *http.Response, error) {
	return r.ApiService.PostCharactersCharacterIdMailLabelsExecute(r)
}

/*
PostCharactersCharacterIdMailLabels Create a mail label

Create a mail label

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiPostCharactersCharacterIdMailLabelsRequest
*/
func (a *MailAPIService) PostCharactersCharacterIdMailLabels(ctx context.Context, characterId int64) ApiPostCharactersCharacterIdMailLabelsRequest {
	return ApiPostCharactersCharacterIdMailLabelsRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return int64
func (a *MailAPIService) PostCharactersCharacterIdMailLabelsExecute(r ApiPostCharactersCharacterIdMailLabelsRequest) (int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MailAPIService.PostCharactersCharacterIdMailLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/mail/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}
	if r.postCharactersCharacterIdMailLabelsRequest == nil {
		return localVarReturnValue, nil, reportError("postCharactersCharacterIdMailLabelsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	// body params
	localVarPostBody = r.postCharactersCharacterIdMailLabelsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutCharactersCharacterIdMailMailIdRequest struct {
	ctx context.Context
	ApiService MailAPI
	characterId int64
	mailId int64
	xCompatibilityDate *string
	putCharactersCharacterIdMailMailIdRequest *PutCharactersCharacterIdMailMailIdRequest
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiPutCharactersCharacterIdMailMailIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiPutCharactersCharacterIdMailMailIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiPutCharactersCharacterIdMailMailIdRequest) PutCharactersCharacterIdMailMailIdRequest(putCharactersCharacterIdMailMailIdRequest PutCharactersCharacterIdMailMailIdRequest) ApiPutCharactersCharacterIdMailMailIdRequest {
	r.putCharactersCharacterIdMailMailIdRequest = &putCharactersCharacterIdMailMailIdRequest
	return r
}

// The language to use for the response.
func (r ApiPutCharactersCharacterIdMailMailIdRequest) AcceptLanguage(acceptLanguage string) ApiPutCharactersCharacterIdMailMailIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPutCharactersCharacterIdMailMailIdRequest) IfNoneMatch(ifNoneMatch string) ApiPutCharactersCharacterIdMailMailIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiPutCharactersCharacterIdMailMailIdRequest) XTenant(xTenant string) ApiPutCharactersCharacterIdMailMailIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPutCharactersCharacterIdMailMailIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutCharactersCharacterIdMailMailIdExecute(r)
}

/*
PutCharactersCharacterIdMailMailId Update metadata about a mail

Update metadata about a mail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @param mailId
 @return ApiPutCharactersCharacterIdMailMailIdRequest
*/
func (a *MailAPIService) PutCharactersCharacterIdMailMailId(ctx context.Context, characterId int64, mailId int64) ApiPutCharactersCharacterIdMailMailIdRequest {
	return ApiPutCharactersCharacterIdMailMailIdRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
		mailId: mailId,
	}
}

// Execute executes the request
func (a *MailAPIService) PutCharactersCharacterIdMailMailIdExecute(r ApiPutCharactersCharacterIdMailMailIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MailAPIService.PutCharactersCharacterIdMailMailId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/mail/{mail_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mail_id"+"}", url.PathEscape(parameterValueToString(r.mailId, "mailId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		defaultCompatibilityDate := "2020-01-01"
		r.xCompatibilityDate = &defaultCompatibilityDate
	}
	// Removed original error check - now using default value
	if false {
		return nil, reportError("xCompatibilityDate is required and must be specified")
	}
	if r.putCharactersCharacterIdMailMailIdRequest == nil {
		return nil, reportError("putCharactersCharacterIdMailMailIdRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	// body params
	localVarPostBody = r.putCharactersCharacterIdMailMailIdRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
