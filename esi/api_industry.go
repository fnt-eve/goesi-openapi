/*
EVE Stable Infrastructure (ESI) - tranquility

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2020-01-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package esi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type IndustryAPI interface {

	/*
	GetCharactersCharacterIdIndustryJobs List character industry jobs

	List industry jobs placed by a character

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdIndustryJobsRequest
	*/
	GetCharactersCharacterIdIndustryJobs(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdIndustryJobsRequest

	// GetCharactersCharacterIdIndustryJobsExecute executes the request
	//  @return []CharactersCharacterIdIndustryJobsGetInner
	GetCharactersCharacterIdIndustryJobsExecute(r ApiGetCharactersCharacterIdIndustryJobsRequest) ([]CharactersCharacterIdIndustryJobsGetInner, *http.Response, error)

	/*
	GetCharactersCharacterIdMining Character mining ledger

	Paginated record of all mining done by a character for the past 30 days

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdMiningRequest
	*/
	GetCharactersCharacterIdMining(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdMiningRequest

	// GetCharactersCharacterIdMiningExecute executes the request
	//  @return []CharactersCharacterIdMiningGetInner
	GetCharactersCharacterIdMiningExecute(r ApiGetCharactersCharacterIdMiningRequest) ([]CharactersCharacterIdMiningGetInner, *http.Response, error)

	/*
	GetCorporationCorporationIdMiningExtractions Moon extraction timers

	Extraction timers for all moon chunks being extracted by refineries belonging to a corporation.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationCorporationIdMiningExtractionsRequest
	*/
	GetCorporationCorporationIdMiningExtractions(ctx context.Context, corporationId int64) ApiGetCorporationCorporationIdMiningExtractionsRequest

	// GetCorporationCorporationIdMiningExtractionsExecute executes the request
	//  @return []CorporationCorporationIdMiningExtractionsGetInner
	GetCorporationCorporationIdMiningExtractionsExecute(r ApiGetCorporationCorporationIdMiningExtractionsRequest) ([]CorporationCorporationIdMiningExtractionsGetInner, *http.Response, error)

	/*
	GetCorporationCorporationIdMiningObservers Corporation mining observers

	Paginated list of all entities capable of observing and recording mining for a corporation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationCorporationIdMiningObserversRequest
	*/
	GetCorporationCorporationIdMiningObservers(ctx context.Context, corporationId int64) ApiGetCorporationCorporationIdMiningObserversRequest

	// GetCorporationCorporationIdMiningObserversExecute executes the request
	//  @return []CorporationCorporationIdMiningObserversGetInner
	GetCorporationCorporationIdMiningObserversExecute(r ApiGetCorporationCorporationIdMiningObserversRequest) ([]CorporationCorporationIdMiningObserversGetInner, *http.Response, error)

	/*
	GetCorporationCorporationIdMiningObserversObserverId Observed corporation mining

	Paginated record of all mining seen by an observer

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@param observerId
	@return ApiGetCorporationCorporationIdMiningObserversObserverIdRequest
	*/
	GetCorporationCorporationIdMiningObserversObserverId(ctx context.Context, corporationId int64, observerId int64) ApiGetCorporationCorporationIdMiningObserversObserverIdRequest

	// GetCorporationCorporationIdMiningObserversObserverIdExecute executes the request
	//  @return []CorporationCorporationIdMiningObserversObserverIdGetInner
	GetCorporationCorporationIdMiningObserversObserverIdExecute(r ApiGetCorporationCorporationIdMiningObserversObserverIdRequest) ([]CorporationCorporationIdMiningObserversObserverIdGetInner, *http.Response, error)

	/*
	GetCorporationsCorporationIdIndustryJobs List corporation industry jobs

	List industry jobs run by a corporation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdIndustryJobsRequest
	*/
	GetCorporationsCorporationIdIndustryJobs(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdIndustryJobsRequest

	// GetCorporationsCorporationIdIndustryJobsExecute executes the request
	//  @return []CorporationsCorporationIdIndustryJobsGetInner
	GetCorporationsCorporationIdIndustryJobsExecute(r ApiGetCorporationsCorporationIdIndustryJobsRequest) ([]CorporationsCorporationIdIndustryJobsGetInner, *http.Response, error)

	/*
	GetIndustryFacilities List industry facilities

	Return a list of industry facilities

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetIndustryFacilitiesRequest
	*/
	GetIndustryFacilities(ctx context.Context) ApiGetIndustryFacilitiesRequest

	// GetIndustryFacilitiesExecute executes the request
	//  @return []IndustryFacilitiesGetInner
	GetIndustryFacilitiesExecute(r ApiGetIndustryFacilitiesRequest) ([]IndustryFacilitiesGetInner, *http.Response, error)

	/*
	GetIndustrySystems List solar system cost indices

	Return cost indices for solar systems

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetIndustrySystemsRequest
	*/
	GetIndustrySystems(ctx context.Context) ApiGetIndustrySystemsRequest

	// GetIndustrySystemsExecute executes the request
	//  @return []IndustrySystemsGetInner
	GetIndustrySystemsExecute(r ApiGetIndustrySystemsRequest) ([]IndustrySystemsGetInner, *http.Response, error)
}

// IndustryAPIService IndustryAPI service
type IndustryAPIService service

type ApiGetCharactersCharacterIdIndustryJobsRequest struct {
	ctx context.Context
	ApiService IndustryAPI
	characterId int64
	xCompatibilityDate *string
	includeCompleted *bool
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdIndustryJobsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdIndustryJobsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCharactersCharacterIdIndustryJobsRequest) IncludeCompleted(includeCompleted bool) ApiGetCharactersCharacterIdIndustryJobsRequest {
	r.includeCompleted = &includeCompleted
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdIndustryJobsRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdIndustryJobsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdIndustryJobsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdIndustryJobsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdIndustryJobsRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdIndustryJobsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdIndustryJobsRequest) Execute() ([]CharactersCharacterIdIndustryJobsGetInner, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdIndustryJobsExecute(r)
}

/*
GetCharactersCharacterIdIndustryJobs List character industry jobs

List industry jobs placed by a character

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdIndustryJobsRequest
*/
func (a *IndustryAPIService) GetCharactersCharacterIdIndustryJobs(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdIndustryJobsRequest {
	return ApiGetCharactersCharacterIdIndustryJobsRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return []CharactersCharacterIdIndustryJobsGetInner
func (a *IndustryAPIService) GetCharactersCharacterIdIndustryJobsExecute(r ApiGetCharactersCharacterIdIndustryJobsRequest) ([]CharactersCharacterIdIndustryJobsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharactersCharacterIdIndustryJobsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndustryAPIService.GetCharactersCharacterIdIndustryJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/industry/jobs"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.includeCompleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_completed", r.includeCompleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCharactersCharacterIdMiningRequest struct {
	ctx context.Context
	ApiService IndustryAPI
	characterId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdMiningRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdMiningRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCharactersCharacterIdMiningRequest) Page(page int32) ApiGetCharactersCharacterIdMiningRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdMiningRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdMiningRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdMiningRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdMiningRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdMiningRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdMiningRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdMiningRequest) Execute() ([]CharactersCharacterIdMiningGetInner, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdMiningExecute(r)
}

/*
GetCharactersCharacterIdMining Character mining ledger

Paginated record of all mining done by a character for the past 30 days

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdMiningRequest
*/
func (a *IndustryAPIService) GetCharactersCharacterIdMining(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdMiningRequest {
	return ApiGetCharactersCharacterIdMiningRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return []CharactersCharacterIdMiningGetInner
func (a *IndustryAPIService) GetCharactersCharacterIdMiningExecute(r ApiGetCharactersCharacterIdMiningRequest) ([]CharactersCharacterIdMiningGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharactersCharacterIdMiningGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndustryAPIService.GetCharactersCharacterIdMining")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/mining"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationCorporationIdMiningExtractionsRequest struct {
	ctx context.Context
	ApiService IndustryAPI
	corporationId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationCorporationIdMiningExtractionsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationCorporationIdMiningExtractionsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCorporationCorporationIdMiningExtractionsRequest) Page(page int32) ApiGetCorporationCorporationIdMiningExtractionsRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCorporationCorporationIdMiningExtractionsRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationCorporationIdMiningExtractionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationCorporationIdMiningExtractionsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationCorporationIdMiningExtractionsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationCorporationIdMiningExtractionsRequest) XTenant(xTenant string) ApiGetCorporationCorporationIdMiningExtractionsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationCorporationIdMiningExtractionsRequest) Execute() ([]CorporationCorporationIdMiningExtractionsGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationCorporationIdMiningExtractionsExecute(r)
}

/*
GetCorporationCorporationIdMiningExtractions Moon extraction timers

Extraction timers for all moon chunks being extracted by refineries belonging to a corporation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationCorporationIdMiningExtractionsRequest
*/
func (a *IndustryAPIService) GetCorporationCorporationIdMiningExtractions(ctx context.Context, corporationId int64) ApiGetCorporationCorporationIdMiningExtractionsRequest {
	return ApiGetCorporationCorporationIdMiningExtractionsRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CorporationCorporationIdMiningExtractionsGetInner
func (a *IndustryAPIService) GetCorporationCorporationIdMiningExtractionsExecute(r ApiGetCorporationCorporationIdMiningExtractionsRequest) ([]CorporationCorporationIdMiningExtractionsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CorporationCorporationIdMiningExtractionsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndustryAPIService.GetCorporationCorporationIdMiningExtractions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporation/{corporation_id}/mining/extractions"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationCorporationIdMiningObserversRequest struct {
	ctx context.Context
	ApiService IndustryAPI
	corporationId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationCorporationIdMiningObserversRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationCorporationIdMiningObserversRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCorporationCorporationIdMiningObserversRequest) Page(page int32) ApiGetCorporationCorporationIdMiningObserversRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCorporationCorporationIdMiningObserversRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationCorporationIdMiningObserversRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationCorporationIdMiningObserversRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationCorporationIdMiningObserversRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationCorporationIdMiningObserversRequest) XTenant(xTenant string) ApiGetCorporationCorporationIdMiningObserversRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationCorporationIdMiningObserversRequest) Execute() ([]CorporationCorporationIdMiningObserversGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationCorporationIdMiningObserversExecute(r)
}

/*
GetCorporationCorporationIdMiningObservers Corporation mining observers

Paginated list of all entities capable of observing and recording mining for a corporation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationCorporationIdMiningObserversRequest
*/
func (a *IndustryAPIService) GetCorporationCorporationIdMiningObservers(ctx context.Context, corporationId int64) ApiGetCorporationCorporationIdMiningObserversRequest {
	return ApiGetCorporationCorporationIdMiningObserversRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CorporationCorporationIdMiningObserversGetInner
func (a *IndustryAPIService) GetCorporationCorporationIdMiningObserversExecute(r ApiGetCorporationCorporationIdMiningObserversRequest) ([]CorporationCorporationIdMiningObserversGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CorporationCorporationIdMiningObserversGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndustryAPIService.GetCorporationCorporationIdMiningObservers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporation/{corporation_id}/mining/observers"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationCorporationIdMiningObserversObserverIdRequest struct {
	ctx context.Context
	ApiService IndustryAPI
	corporationId int64
	observerId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationCorporationIdMiningObserversObserverIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationCorporationIdMiningObserversObserverIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCorporationCorporationIdMiningObserversObserverIdRequest) Page(page int32) ApiGetCorporationCorporationIdMiningObserversObserverIdRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCorporationCorporationIdMiningObserversObserverIdRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationCorporationIdMiningObserversObserverIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationCorporationIdMiningObserversObserverIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationCorporationIdMiningObserversObserverIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationCorporationIdMiningObserversObserverIdRequest) XTenant(xTenant string) ApiGetCorporationCorporationIdMiningObserversObserverIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationCorporationIdMiningObserversObserverIdRequest) Execute() ([]CorporationCorporationIdMiningObserversObserverIdGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationCorporationIdMiningObserversObserverIdExecute(r)
}

/*
GetCorporationCorporationIdMiningObserversObserverId Observed corporation mining

Paginated record of all mining seen by an observer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @param observerId
 @return ApiGetCorporationCorporationIdMiningObserversObserverIdRequest
*/
func (a *IndustryAPIService) GetCorporationCorporationIdMiningObserversObserverId(ctx context.Context, corporationId int64, observerId int64) ApiGetCorporationCorporationIdMiningObserversObserverIdRequest {
	return ApiGetCorporationCorporationIdMiningObserversObserverIdRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
		observerId: observerId,
	}
}

// Execute executes the request
//  @return []CorporationCorporationIdMiningObserversObserverIdGetInner
func (a *IndustryAPIService) GetCorporationCorporationIdMiningObserversObserverIdExecute(r ApiGetCorporationCorporationIdMiningObserversObserverIdRequest) ([]CorporationCorporationIdMiningObserversObserverIdGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CorporationCorporationIdMiningObserversObserverIdGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndustryAPIService.GetCorporationCorporationIdMiningObserversObserverId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporation/{corporation_id}/mining/observers/{observer_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"observer_id"+"}", url.PathEscape(parameterValueToString(r.observerId, "observerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdIndustryJobsRequest struct {
	ctx context.Context
	ApiService IndustryAPI
	corporationId int64
	xCompatibilityDate *string
	includeCompleted *bool
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdIndustryJobsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdIndustryJobsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCorporationsCorporationIdIndustryJobsRequest) IncludeCompleted(includeCompleted bool) ApiGetCorporationsCorporationIdIndustryJobsRequest {
	r.includeCompleted = &includeCompleted
	return r
}

func (r ApiGetCorporationsCorporationIdIndustryJobsRequest) Page(page int32) ApiGetCorporationsCorporationIdIndustryJobsRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdIndustryJobsRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdIndustryJobsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdIndustryJobsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdIndustryJobsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdIndustryJobsRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdIndustryJobsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdIndustryJobsRequest) Execute() ([]CorporationsCorporationIdIndustryJobsGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdIndustryJobsExecute(r)
}

/*
GetCorporationsCorporationIdIndustryJobs List corporation industry jobs

List industry jobs run by a corporation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdIndustryJobsRequest
*/
func (a *IndustryAPIService) GetCorporationsCorporationIdIndustryJobs(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdIndustryJobsRequest {
	return ApiGetCorporationsCorporationIdIndustryJobsRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CorporationsCorporationIdIndustryJobsGetInner
func (a *IndustryAPIService) GetCorporationsCorporationIdIndustryJobsExecute(r ApiGetCorporationsCorporationIdIndustryJobsRequest) ([]CorporationsCorporationIdIndustryJobsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CorporationsCorporationIdIndustryJobsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndustryAPIService.GetCorporationsCorporationIdIndustryJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/industry/jobs"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.includeCompleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_completed", r.includeCompleted, "form", "")
	} else {
		var defaultValue bool = false
		r.includeCompleted = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIndustryFacilitiesRequest struct {
	ctx context.Context
	ApiService IndustryAPI
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetIndustryFacilitiesRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetIndustryFacilitiesRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetIndustryFacilitiesRequest) AcceptLanguage(acceptLanguage string) ApiGetIndustryFacilitiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetIndustryFacilitiesRequest) IfNoneMatch(ifNoneMatch string) ApiGetIndustryFacilitiesRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetIndustryFacilitiesRequest) XTenant(xTenant string) ApiGetIndustryFacilitiesRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetIndustryFacilitiesRequest) Execute() ([]IndustryFacilitiesGetInner, *http.Response, error) {
	return r.ApiService.GetIndustryFacilitiesExecute(r)
}

/*
GetIndustryFacilities List industry facilities

Return a list of industry facilities

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIndustryFacilitiesRequest
*/
func (a *IndustryAPIService) GetIndustryFacilities(ctx context.Context) ApiGetIndustryFacilitiesRequest {
	return ApiGetIndustryFacilitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IndustryFacilitiesGetInner
func (a *IndustryAPIService) GetIndustryFacilitiesExecute(r ApiGetIndustryFacilitiesRequest) ([]IndustryFacilitiesGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IndustryFacilitiesGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndustryAPIService.GetIndustryFacilities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/industry/facilities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIndustrySystemsRequest struct {
	ctx context.Context
	ApiService IndustryAPI
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetIndustrySystemsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetIndustrySystemsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetIndustrySystemsRequest) AcceptLanguage(acceptLanguage string) ApiGetIndustrySystemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetIndustrySystemsRequest) IfNoneMatch(ifNoneMatch string) ApiGetIndustrySystemsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetIndustrySystemsRequest) XTenant(xTenant string) ApiGetIndustrySystemsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetIndustrySystemsRequest) Execute() ([]IndustrySystemsGetInner, *http.Response, error) {
	return r.ApiService.GetIndustrySystemsExecute(r)
}

/*
GetIndustrySystems List solar system cost indices

Return cost indices for solar systems

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIndustrySystemsRequest
*/
func (a *IndustryAPIService) GetIndustrySystems(ctx context.Context) ApiGetIndustrySystemsRequest {
	return ApiGetIndustrySystemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IndustrySystemsGetInner
func (a *IndustryAPIService) GetIndustrySystemsExecute(r ApiGetIndustrySystemsRequest) ([]IndustrySystemsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IndustrySystemsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndustryAPIService.GetIndustrySystems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/industry/systems"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
