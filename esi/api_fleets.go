/*
EVE Stable Infrastructure (ESI) - tranquility

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2020-01-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package esi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type FleetsAPI interface {

	/*
	DeleteFleetsFleetIdMembersMemberId Kick fleet member

	Kick a fleet member

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fleetId
	@param memberId
	@return ApiDeleteFleetsFleetIdMembersMemberIdRequest
	*/
	DeleteFleetsFleetIdMembersMemberId(ctx context.Context, fleetId int64, memberId int64) ApiDeleteFleetsFleetIdMembersMemberIdRequest

	// DeleteFleetsFleetIdMembersMemberIdExecute executes the request
	DeleteFleetsFleetIdMembersMemberIdExecute(r ApiDeleteFleetsFleetIdMembersMemberIdRequest) (*http.Response, error)

	/*
	DeleteFleetsFleetIdSquadsSquadId Delete fleet squad

	Delete a fleet squad, only empty squads can be deleted

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fleetId
	@param squadId
	@return ApiDeleteFleetsFleetIdSquadsSquadIdRequest
	*/
	DeleteFleetsFleetIdSquadsSquadId(ctx context.Context, fleetId int64, squadId int64) ApiDeleteFleetsFleetIdSquadsSquadIdRequest

	// DeleteFleetsFleetIdSquadsSquadIdExecute executes the request
	DeleteFleetsFleetIdSquadsSquadIdExecute(r ApiDeleteFleetsFleetIdSquadsSquadIdRequest) (*http.Response, error)

	/*
	DeleteFleetsFleetIdWingsWingId Delete fleet wing

	Delete a fleet wing, only empty wings can be deleted. The wing may contain squads, but the squads must be empty

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fleetId
	@param wingId
	@return ApiDeleteFleetsFleetIdWingsWingIdRequest
	*/
	DeleteFleetsFleetIdWingsWingId(ctx context.Context, fleetId int64, wingId int64) ApiDeleteFleetsFleetIdWingsWingIdRequest

	// DeleteFleetsFleetIdWingsWingIdExecute executes the request
	DeleteFleetsFleetIdWingsWingIdExecute(r ApiDeleteFleetsFleetIdWingsWingIdRequest) (*http.Response, error)

	/*
	GetCharactersCharacterIdFleet Get character fleet info

	Return the fleet ID the character is in, if any.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdFleetRequest
	*/
	GetCharactersCharacterIdFleet(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdFleetRequest

	// GetCharactersCharacterIdFleetExecute executes the request
	//  @return CharactersCharacterIdFleetGet
	GetCharactersCharacterIdFleetExecute(r ApiGetCharactersCharacterIdFleetRequest) (*CharactersCharacterIdFleetGet, *http.Response, error)

	/*
	GetFleetsFleetId Get fleet information

	Return details about a fleet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fleetId
	@return ApiGetFleetsFleetIdRequest
	*/
	GetFleetsFleetId(ctx context.Context, fleetId int64) ApiGetFleetsFleetIdRequest

	// GetFleetsFleetIdExecute executes the request
	//  @return FleetsFleetIdGet
	GetFleetsFleetIdExecute(r ApiGetFleetsFleetIdRequest) (*FleetsFleetIdGet, *http.Response, error)

	/*
	GetFleetsFleetIdMembers Get fleet members

	Return information about fleet members

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fleetId
	@return ApiGetFleetsFleetIdMembersRequest
	*/
	GetFleetsFleetIdMembers(ctx context.Context, fleetId int64) ApiGetFleetsFleetIdMembersRequest

	// GetFleetsFleetIdMembersExecute executes the request
	//  @return []FleetsFleetIdMembersGetInner
	GetFleetsFleetIdMembersExecute(r ApiGetFleetsFleetIdMembersRequest) ([]FleetsFleetIdMembersGetInner, *http.Response, error)

	/*
	GetFleetsFleetIdWings Get fleet wings

	Return information about wings in a fleet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fleetId
	@return ApiGetFleetsFleetIdWingsRequest
	*/
	GetFleetsFleetIdWings(ctx context.Context, fleetId int64) ApiGetFleetsFleetIdWingsRequest

	// GetFleetsFleetIdWingsExecute executes the request
	//  @return []FleetsFleetIdWingsGetInner
	GetFleetsFleetIdWingsExecute(r ApiGetFleetsFleetIdWingsRequest) ([]FleetsFleetIdWingsGetInner, *http.Response, error)

	/*
	PostFleetsFleetIdMembers Create fleet invitation

	Invite a character into the fleet. If a character has a CSPA charge set it is not possible to invite them to the fleet using ESI

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fleetId
	@return ApiPostFleetsFleetIdMembersRequest
	*/
	PostFleetsFleetIdMembers(ctx context.Context, fleetId int64) ApiPostFleetsFleetIdMembersRequest

	// PostFleetsFleetIdMembersExecute executes the request
	PostFleetsFleetIdMembersExecute(r ApiPostFleetsFleetIdMembersRequest) (*http.Response, error)

	/*
	PostFleetsFleetIdWings Create fleet wing

	Create a new wing in a fleet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fleetId
	@return ApiPostFleetsFleetIdWingsRequest
	*/
	PostFleetsFleetIdWings(ctx context.Context, fleetId int64) ApiPostFleetsFleetIdWingsRequest

	// PostFleetsFleetIdWingsExecute executes the request
	//  @return FleetsFleetIdWingsPost
	PostFleetsFleetIdWingsExecute(r ApiPostFleetsFleetIdWingsRequest) (*FleetsFleetIdWingsPost, *http.Response, error)

	/*
	PostFleetsFleetIdWingsWingIdSquads Create fleet squad

	Create a new squad in a fleet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fleetId
	@param wingId
	@return ApiPostFleetsFleetIdWingsWingIdSquadsRequest
	*/
	PostFleetsFleetIdWingsWingIdSquads(ctx context.Context, fleetId int64, wingId int64) ApiPostFleetsFleetIdWingsWingIdSquadsRequest

	// PostFleetsFleetIdWingsWingIdSquadsExecute executes the request
	//  @return FleetsFleetIdWingsWingIdSquadsPost
	PostFleetsFleetIdWingsWingIdSquadsExecute(r ApiPostFleetsFleetIdWingsWingIdSquadsRequest) (*FleetsFleetIdWingsWingIdSquadsPost, *http.Response, error)

	/*
	PutFleetsFleetId Update fleet

	Update settings about a fleet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fleetId
	@return ApiPutFleetsFleetIdRequest
	*/
	PutFleetsFleetId(ctx context.Context, fleetId int64) ApiPutFleetsFleetIdRequest

	// PutFleetsFleetIdExecute executes the request
	PutFleetsFleetIdExecute(r ApiPutFleetsFleetIdRequest) (*http.Response, error)

	/*
	PutFleetsFleetIdMembersMemberId Move fleet member

	Move a fleet member around

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fleetId
	@param memberId
	@return ApiPutFleetsFleetIdMembersMemberIdRequest
	*/
	PutFleetsFleetIdMembersMemberId(ctx context.Context, fleetId int64, memberId int64) ApiPutFleetsFleetIdMembersMemberIdRequest

	// PutFleetsFleetIdMembersMemberIdExecute executes the request
	PutFleetsFleetIdMembersMemberIdExecute(r ApiPutFleetsFleetIdMembersMemberIdRequest) (*http.Response, error)

	/*
	PutFleetsFleetIdSquadsSquadId Rename fleet squad

	Rename a fleet squad

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fleetId
	@param squadId
	@return ApiPutFleetsFleetIdSquadsSquadIdRequest
	*/
	PutFleetsFleetIdSquadsSquadId(ctx context.Context, fleetId int64, squadId int64) ApiPutFleetsFleetIdSquadsSquadIdRequest

	// PutFleetsFleetIdSquadsSquadIdExecute executes the request
	PutFleetsFleetIdSquadsSquadIdExecute(r ApiPutFleetsFleetIdSquadsSquadIdRequest) (*http.Response, error)

	/*
	PutFleetsFleetIdWingsWingId Rename fleet wing

	Rename a fleet wing

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fleetId
	@param wingId
	@return ApiPutFleetsFleetIdWingsWingIdRequest
	*/
	PutFleetsFleetIdWingsWingId(ctx context.Context, fleetId int64, wingId int64) ApiPutFleetsFleetIdWingsWingIdRequest

	// PutFleetsFleetIdWingsWingIdExecute executes the request
	PutFleetsFleetIdWingsWingIdExecute(r ApiPutFleetsFleetIdWingsWingIdRequest) (*http.Response, error)
}

// FleetsAPIService FleetsAPI service
type FleetsAPIService service

type ApiDeleteFleetsFleetIdMembersMemberIdRequest struct {
	ctx context.Context
	ApiService FleetsAPI
	fleetId int64
	memberId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiDeleteFleetsFleetIdMembersMemberIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiDeleteFleetsFleetIdMembersMemberIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiDeleteFleetsFleetIdMembersMemberIdRequest) AcceptLanguage(acceptLanguage string) ApiDeleteFleetsFleetIdMembersMemberIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiDeleteFleetsFleetIdMembersMemberIdRequest) IfNoneMatch(ifNoneMatch string) ApiDeleteFleetsFleetIdMembersMemberIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiDeleteFleetsFleetIdMembersMemberIdRequest) XTenant(xTenant string) ApiDeleteFleetsFleetIdMembersMemberIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiDeleteFleetsFleetIdMembersMemberIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFleetsFleetIdMembersMemberIdExecute(r)
}

/*
DeleteFleetsFleetIdMembersMemberId Kick fleet member

Kick a fleet member

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fleetId
 @param memberId
 @return ApiDeleteFleetsFleetIdMembersMemberIdRequest
*/
func (a *FleetsAPIService) DeleteFleetsFleetIdMembersMemberId(ctx context.Context, fleetId int64, memberId int64) ApiDeleteFleetsFleetIdMembersMemberIdRequest {
	return ApiDeleteFleetsFleetIdMembersMemberIdRequest{
		ApiService: a,
		ctx: ctx,
		fleetId: fleetId,
		memberId: memberId,
	}
}

// Execute executes the request
func (a *FleetsAPIService) DeleteFleetsFleetIdMembersMemberIdExecute(r ApiDeleteFleetsFleetIdMembersMemberIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetsAPIService.DeleteFleetsFleetIdMembersMemberId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fleets/{fleet_id}/members/{member_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"fleet_id"+"}", url.PathEscape(parameterValueToString(r.fleetId, "fleetId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"member_id"+"}", url.PathEscape(parameterValueToString(r.memberId, "memberId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteFleetsFleetIdSquadsSquadIdRequest struct {
	ctx context.Context
	ApiService FleetsAPI
	fleetId int64
	squadId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiDeleteFleetsFleetIdSquadsSquadIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiDeleteFleetsFleetIdSquadsSquadIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiDeleteFleetsFleetIdSquadsSquadIdRequest) AcceptLanguage(acceptLanguage string) ApiDeleteFleetsFleetIdSquadsSquadIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiDeleteFleetsFleetIdSquadsSquadIdRequest) IfNoneMatch(ifNoneMatch string) ApiDeleteFleetsFleetIdSquadsSquadIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiDeleteFleetsFleetIdSquadsSquadIdRequest) XTenant(xTenant string) ApiDeleteFleetsFleetIdSquadsSquadIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiDeleteFleetsFleetIdSquadsSquadIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFleetsFleetIdSquadsSquadIdExecute(r)
}

/*
DeleteFleetsFleetIdSquadsSquadId Delete fleet squad

Delete a fleet squad, only empty squads can be deleted

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fleetId
 @param squadId
 @return ApiDeleteFleetsFleetIdSquadsSquadIdRequest
*/
func (a *FleetsAPIService) DeleteFleetsFleetIdSquadsSquadId(ctx context.Context, fleetId int64, squadId int64) ApiDeleteFleetsFleetIdSquadsSquadIdRequest {
	return ApiDeleteFleetsFleetIdSquadsSquadIdRequest{
		ApiService: a,
		ctx: ctx,
		fleetId: fleetId,
		squadId: squadId,
	}
}

// Execute executes the request
func (a *FleetsAPIService) DeleteFleetsFleetIdSquadsSquadIdExecute(r ApiDeleteFleetsFleetIdSquadsSquadIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetsAPIService.DeleteFleetsFleetIdSquadsSquadId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fleets/{fleet_id}/squads/{squad_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"fleet_id"+"}", url.PathEscape(parameterValueToString(r.fleetId, "fleetId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"squad_id"+"}", url.PathEscape(parameterValueToString(r.squadId, "squadId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteFleetsFleetIdWingsWingIdRequest struct {
	ctx context.Context
	ApiService FleetsAPI
	fleetId int64
	wingId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiDeleteFleetsFleetIdWingsWingIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiDeleteFleetsFleetIdWingsWingIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiDeleteFleetsFleetIdWingsWingIdRequest) AcceptLanguage(acceptLanguage string) ApiDeleteFleetsFleetIdWingsWingIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiDeleteFleetsFleetIdWingsWingIdRequest) IfNoneMatch(ifNoneMatch string) ApiDeleteFleetsFleetIdWingsWingIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiDeleteFleetsFleetIdWingsWingIdRequest) XTenant(xTenant string) ApiDeleteFleetsFleetIdWingsWingIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiDeleteFleetsFleetIdWingsWingIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFleetsFleetIdWingsWingIdExecute(r)
}

/*
DeleteFleetsFleetIdWingsWingId Delete fleet wing

Delete a fleet wing, only empty wings can be deleted. The wing may contain squads, but the squads must be empty

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fleetId
 @param wingId
 @return ApiDeleteFleetsFleetIdWingsWingIdRequest
*/
func (a *FleetsAPIService) DeleteFleetsFleetIdWingsWingId(ctx context.Context, fleetId int64, wingId int64) ApiDeleteFleetsFleetIdWingsWingIdRequest {
	return ApiDeleteFleetsFleetIdWingsWingIdRequest{
		ApiService: a,
		ctx: ctx,
		fleetId: fleetId,
		wingId: wingId,
	}
}

// Execute executes the request
func (a *FleetsAPIService) DeleteFleetsFleetIdWingsWingIdExecute(r ApiDeleteFleetsFleetIdWingsWingIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetsAPIService.DeleteFleetsFleetIdWingsWingId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fleets/{fleet_id}/wings/{wing_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"fleet_id"+"}", url.PathEscape(parameterValueToString(r.fleetId, "fleetId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wing_id"+"}", url.PathEscape(parameterValueToString(r.wingId, "wingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCharactersCharacterIdFleetRequest struct {
	ctx context.Context
	ApiService FleetsAPI
	characterId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdFleetRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdFleetRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdFleetRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdFleetRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdFleetRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdFleetRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdFleetRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdFleetRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdFleetRequest) Execute() (*CharactersCharacterIdFleetGet, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdFleetExecute(r)
}

/*
GetCharactersCharacterIdFleet Get character fleet info

Return the fleet ID the character is in, if any.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdFleetRequest
*/
func (a *FleetsAPIService) GetCharactersCharacterIdFleet(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdFleetRequest {
	return ApiGetCharactersCharacterIdFleetRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return CharactersCharacterIdFleetGet
func (a *FleetsAPIService) GetCharactersCharacterIdFleetExecute(r ApiGetCharactersCharacterIdFleetRequest) (*CharactersCharacterIdFleetGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CharactersCharacterIdFleetGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetsAPIService.GetCharactersCharacterIdFleet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/fleet"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFleetsFleetIdRequest struct {
	ctx context.Context
	ApiService FleetsAPI
	fleetId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetFleetsFleetIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetFleetsFleetIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetFleetsFleetIdRequest) AcceptLanguage(acceptLanguage string) ApiGetFleetsFleetIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetFleetsFleetIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetFleetsFleetIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetFleetsFleetIdRequest) XTenant(xTenant string) ApiGetFleetsFleetIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetFleetsFleetIdRequest) Execute() (*FleetsFleetIdGet, *http.Response, error) {
	return r.ApiService.GetFleetsFleetIdExecute(r)
}

/*
GetFleetsFleetId Get fleet information

Return details about a fleet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fleetId
 @return ApiGetFleetsFleetIdRequest
*/
func (a *FleetsAPIService) GetFleetsFleetId(ctx context.Context, fleetId int64) ApiGetFleetsFleetIdRequest {
	return ApiGetFleetsFleetIdRequest{
		ApiService: a,
		ctx: ctx,
		fleetId: fleetId,
	}
}

// Execute executes the request
//  @return FleetsFleetIdGet
func (a *FleetsAPIService) GetFleetsFleetIdExecute(r ApiGetFleetsFleetIdRequest) (*FleetsFleetIdGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FleetsFleetIdGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetsAPIService.GetFleetsFleetId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fleets/{fleet_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"fleet_id"+"}", url.PathEscape(parameterValueToString(r.fleetId, "fleetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFleetsFleetIdMembersRequest struct {
	ctx context.Context
	ApiService FleetsAPI
	fleetId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetFleetsFleetIdMembersRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetFleetsFleetIdMembersRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetFleetsFleetIdMembersRequest) AcceptLanguage(acceptLanguage string) ApiGetFleetsFleetIdMembersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetFleetsFleetIdMembersRequest) IfNoneMatch(ifNoneMatch string) ApiGetFleetsFleetIdMembersRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetFleetsFleetIdMembersRequest) XTenant(xTenant string) ApiGetFleetsFleetIdMembersRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetFleetsFleetIdMembersRequest) Execute() ([]FleetsFleetIdMembersGetInner, *http.Response, error) {
	return r.ApiService.GetFleetsFleetIdMembersExecute(r)
}

/*
GetFleetsFleetIdMembers Get fleet members

Return information about fleet members

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fleetId
 @return ApiGetFleetsFleetIdMembersRequest
*/
func (a *FleetsAPIService) GetFleetsFleetIdMembers(ctx context.Context, fleetId int64) ApiGetFleetsFleetIdMembersRequest {
	return ApiGetFleetsFleetIdMembersRequest{
		ApiService: a,
		ctx: ctx,
		fleetId: fleetId,
	}
}

// Execute executes the request
//  @return []FleetsFleetIdMembersGetInner
func (a *FleetsAPIService) GetFleetsFleetIdMembersExecute(r ApiGetFleetsFleetIdMembersRequest) ([]FleetsFleetIdMembersGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FleetsFleetIdMembersGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetsAPIService.GetFleetsFleetIdMembers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fleets/{fleet_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"fleet_id"+"}", url.PathEscape(parameterValueToString(r.fleetId, "fleetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFleetsFleetIdWingsRequest struct {
	ctx context.Context
	ApiService FleetsAPI
	fleetId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetFleetsFleetIdWingsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetFleetsFleetIdWingsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetFleetsFleetIdWingsRequest) AcceptLanguage(acceptLanguage string) ApiGetFleetsFleetIdWingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetFleetsFleetIdWingsRequest) IfNoneMatch(ifNoneMatch string) ApiGetFleetsFleetIdWingsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetFleetsFleetIdWingsRequest) XTenant(xTenant string) ApiGetFleetsFleetIdWingsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetFleetsFleetIdWingsRequest) Execute() ([]FleetsFleetIdWingsGetInner, *http.Response, error) {
	return r.ApiService.GetFleetsFleetIdWingsExecute(r)
}

/*
GetFleetsFleetIdWings Get fleet wings

Return information about wings in a fleet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fleetId
 @return ApiGetFleetsFleetIdWingsRequest
*/
func (a *FleetsAPIService) GetFleetsFleetIdWings(ctx context.Context, fleetId int64) ApiGetFleetsFleetIdWingsRequest {
	return ApiGetFleetsFleetIdWingsRequest{
		ApiService: a,
		ctx: ctx,
		fleetId: fleetId,
	}
}

// Execute executes the request
//  @return []FleetsFleetIdWingsGetInner
func (a *FleetsAPIService) GetFleetsFleetIdWingsExecute(r ApiGetFleetsFleetIdWingsRequest) ([]FleetsFleetIdWingsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FleetsFleetIdWingsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetsAPIService.GetFleetsFleetIdWings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fleets/{fleet_id}/wings"
	localVarPath = strings.Replace(localVarPath, "{"+"fleet_id"+"}", url.PathEscape(parameterValueToString(r.fleetId, "fleetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostFleetsFleetIdMembersRequest struct {
	ctx context.Context
	ApiService FleetsAPI
	fleetId int64
	xCompatibilityDate *string
	postFleetsFleetIdMembersRequest *PostFleetsFleetIdMembersRequest
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiPostFleetsFleetIdMembersRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostFleetsFleetIdMembersRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiPostFleetsFleetIdMembersRequest) PostFleetsFleetIdMembersRequest(postFleetsFleetIdMembersRequest PostFleetsFleetIdMembersRequest) ApiPostFleetsFleetIdMembersRequest {
	r.postFleetsFleetIdMembersRequest = &postFleetsFleetIdMembersRequest
	return r
}

// The language to use for the response.
func (r ApiPostFleetsFleetIdMembersRequest) AcceptLanguage(acceptLanguage string) ApiPostFleetsFleetIdMembersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostFleetsFleetIdMembersRequest) IfNoneMatch(ifNoneMatch string) ApiPostFleetsFleetIdMembersRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiPostFleetsFleetIdMembersRequest) XTenant(xTenant string) ApiPostFleetsFleetIdMembersRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostFleetsFleetIdMembersRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostFleetsFleetIdMembersExecute(r)
}

/*
PostFleetsFleetIdMembers Create fleet invitation

Invite a character into the fleet. If a character has a CSPA charge set it is not possible to invite them to the fleet using ESI

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fleetId
 @return ApiPostFleetsFleetIdMembersRequest
*/
func (a *FleetsAPIService) PostFleetsFleetIdMembers(ctx context.Context, fleetId int64) ApiPostFleetsFleetIdMembersRequest {
	return ApiPostFleetsFleetIdMembersRequest{
		ApiService: a,
		ctx: ctx,
		fleetId: fleetId,
	}
}

// Execute executes the request
func (a *FleetsAPIService) PostFleetsFleetIdMembersExecute(r ApiPostFleetsFleetIdMembersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetsAPIService.PostFleetsFleetIdMembers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fleets/{fleet_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"fleet_id"+"}", url.PathEscape(parameterValueToString(r.fleetId, "fleetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return nil, reportError("xCompatibilityDate is required and must be specified")
	}
	if r.postFleetsFleetIdMembersRequest == nil {
		return nil, reportError("postFleetsFleetIdMembersRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	// body params
	localVarPostBody = r.postFleetsFleetIdMembersRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostFleetsFleetIdWingsRequest struct {
	ctx context.Context
	ApiService FleetsAPI
	fleetId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiPostFleetsFleetIdWingsRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostFleetsFleetIdWingsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiPostFleetsFleetIdWingsRequest) AcceptLanguage(acceptLanguage string) ApiPostFleetsFleetIdWingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostFleetsFleetIdWingsRequest) IfNoneMatch(ifNoneMatch string) ApiPostFleetsFleetIdWingsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiPostFleetsFleetIdWingsRequest) XTenant(xTenant string) ApiPostFleetsFleetIdWingsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostFleetsFleetIdWingsRequest) Execute() (*FleetsFleetIdWingsPost, *http.Response, error) {
	return r.ApiService.PostFleetsFleetIdWingsExecute(r)
}

/*
PostFleetsFleetIdWings Create fleet wing

Create a new wing in a fleet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fleetId
 @return ApiPostFleetsFleetIdWingsRequest
*/
func (a *FleetsAPIService) PostFleetsFleetIdWings(ctx context.Context, fleetId int64) ApiPostFleetsFleetIdWingsRequest {
	return ApiPostFleetsFleetIdWingsRequest{
		ApiService: a,
		ctx: ctx,
		fleetId: fleetId,
	}
}

// Execute executes the request
//  @return FleetsFleetIdWingsPost
func (a *FleetsAPIService) PostFleetsFleetIdWingsExecute(r ApiPostFleetsFleetIdWingsRequest) (*FleetsFleetIdWingsPost, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FleetsFleetIdWingsPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetsAPIService.PostFleetsFleetIdWings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fleets/{fleet_id}/wings"
	localVarPath = strings.Replace(localVarPath, "{"+"fleet_id"+"}", url.PathEscape(parameterValueToString(r.fleetId, "fleetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostFleetsFleetIdWingsWingIdSquadsRequest struct {
	ctx context.Context
	ApiService FleetsAPI
	fleetId int64
	wingId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiPostFleetsFleetIdWingsWingIdSquadsRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostFleetsFleetIdWingsWingIdSquadsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiPostFleetsFleetIdWingsWingIdSquadsRequest) AcceptLanguage(acceptLanguage string) ApiPostFleetsFleetIdWingsWingIdSquadsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostFleetsFleetIdWingsWingIdSquadsRequest) IfNoneMatch(ifNoneMatch string) ApiPostFleetsFleetIdWingsWingIdSquadsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiPostFleetsFleetIdWingsWingIdSquadsRequest) XTenant(xTenant string) ApiPostFleetsFleetIdWingsWingIdSquadsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostFleetsFleetIdWingsWingIdSquadsRequest) Execute() (*FleetsFleetIdWingsWingIdSquadsPost, *http.Response, error) {
	return r.ApiService.PostFleetsFleetIdWingsWingIdSquadsExecute(r)
}

/*
PostFleetsFleetIdWingsWingIdSquads Create fleet squad

Create a new squad in a fleet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fleetId
 @param wingId
 @return ApiPostFleetsFleetIdWingsWingIdSquadsRequest
*/
func (a *FleetsAPIService) PostFleetsFleetIdWingsWingIdSquads(ctx context.Context, fleetId int64, wingId int64) ApiPostFleetsFleetIdWingsWingIdSquadsRequest {
	return ApiPostFleetsFleetIdWingsWingIdSquadsRequest{
		ApiService: a,
		ctx: ctx,
		fleetId: fleetId,
		wingId: wingId,
	}
}

// Execute executes the request
//  @return FleetsFleetIdWingsWingIdSquadsPost
func (a *FleetsAPIService) PostFleetsFleetIdWingsWingIdSquadsExecute(r ApiPostFleetsFleetIdWingsWingIdSquadsRequest) (*FleetsFleetIdWingsWingIdSquadsPost, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FleetsFleetIdWingsWingIdSquadsPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetsAPIService.PostFleetsFleetIdWingsWingIdSquads")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fleets/{fleet_id}/wings/{wing_id}/squads"
	localVarPath = strings.Replace(localVarPath, "{"+"fleet_id"+"}", url.PathEscape(parameterValueToString(r.fleetId, "fleetId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wing_id"+"}", url.PathEscape(parameterValueToString(r.wingId, "wingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutFleetsFleetIdRequest struct {
	ctx context.Context
	ApiService FleetsAPI
	fleetId int64
	xCompatibilityDate *string
	putFleetsFleetIdRequest *PutFleetsFleetIdRequest
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiPutFleetsFleetIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiPutFleetsFleetIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiPutFleetsFleetIdRequest) PutFleetsFleetIdRequest(putFleetsFleetIdRequest PutFleetsFleetIdRequest) ApiPutFleetsFleetIdRequest {
	r.putFleetsFleetIdRequest = &putFleetsFleetIdRequest
	return r
}

// The language to use for the response.
func (r ApiPutFleetsFleetIdRequest) AcceptLanguage(acceptLanguage string) ApiPutFleetsFleetIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPutFleetsFleetIdRequest) IfNoneMatch(ifNoneMatch string) ApiPutFleetsFleetIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiPutFleetsFleetIdRequest) XTenant(xTenant string) ApiPutFleetsFleetIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPutFleetsFleetIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutFleetsFleetIdExecute(r)
}

/*
PutFleetsFleetId Update fleet

Update settings about a fleet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fleetId
 @return ApiPutFleetsFleetIdRequest
*/
func (a *FleetsAPIService) PutFleetsFleetId(ctx context.Context, fleetId int64) ApiPutFleetsFleetIdRequest {
	return ApiPutFleetsFleetIdRequest{
		ApiService: a,
		ctx: ctx,
		fleetId: fleetId,
	}
}

// Execute executes the request
func (a *FleetsAPIService) PutFleetsFleetIdExecute(r ApiPutFleetsFleetIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetsAPIService.PutFleetsFleetId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fleets/{fleet_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"fleet_id"+"}", url.PathEscape(parameterValueToString(r.fleetId, "fleetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return nil, reportError("xCompatibilityDate is required and must be specified")
	}
	if r.putFleetsFleetIdRequest == nil {
		return nil, reportError("putFleetsFleetIdRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	// body params
	localVarPostBody = r.putFleetsFleetIdRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutFleetsFleetIdMembersMemberIdRequest struct {
	ctx context.Context
	ApiService FleetsAPI
	fleetId int64
	memberId int64
	xCompatibilityDate *string
	putFleetsFleetIdMembersMemberIdRequest *PutFleetsFleetIdMembersMemberIdRequest
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiPutFleetsFleetIdMembersMemberIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiPutFleetsFleetIdMembersMemberIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiPutFleetsFleetIdMembersMemberIdRequest) PutFleetsFleetIdMembersMemberIdRequest(putFleetsFleetIdMembersMemberIdRequest PutFleetsFleetIdMembersMemberIdRequest) ApiPutFleetsFleetIdMembersMemberIdRequest {
	r.putFleetsFleetIdMembersMemberIdRequest = &putFleetsFleetIdMembersMemberIdRequest
	return r
}

// The language to use for the response.
func (r ApiPutFleetsFleetIdMembersMemberIdRequest) AcceptLanguage(acceptLanguage string) ApiPutFleetsFleetIdMembersMemberIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPutFleetsFleetIdMembersMemberIdRequest) IfNoneMatch(ifNoneMatch string) ApiPutFleetsFleetIdMembersMemberIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiPutFleetsFleetIdMembersMemberIdRequest) XTenant(xTenant string) ApiPutFleetsFleetIdMembersMemberIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPutFleetsFleetIdMembersMemberIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutFleetsFleetIdMembersMemberIdExecute(r)
}

/*
PutFleetsFleetIdMembersMemberId Move fleet member

Move a fleet member around

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fleetId
 @param memberId
 @return ApiPutFleetsFleetIdMembersMemberIdRequest
*/
func (a *FleetsAPIService) PutFleetsFleetIdMembersMemberId(ctx context.Context, fleetId int64, memberId int64) ApiPutFleetsFleetIdMembersMemberIdRequest {
	return ApiPutFleetsFleetIdMembersMemberIdRequest{
		ApiService: a,
		ctx: ctx,
		fleetId: fleetId,
		memberId: memberId,
	}
}

// Execute executes the request
func (a *FleetsAPIService) PutFleetsFleetIdMembersMemberIdExecute(r ApiPutFleetsFleetIdMembersMemberIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetsAPIService.PutFleetsFleetIdMembersMemberId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fleets/{fleet_id}/members/{member_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"fleet_id"+"}", url.PathEscape(parameterValueToString(r.fleetId, "fleetId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"member_id"+"}", url.PathEscape(parameterValueToString(r.memberId, "memberId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return nil, reportError("xCompatibilityDate is required and must be specified")
	}
	if r.putFleetsFleetIdMembersMemberIdRequest == nil {
		return nil, reportError("putFleetsFleetIdMembersMemberIdRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	// body params
	localVarPostBody = r.putFleetsFleetIdMembersMemberIdRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutFleetsFleetIdSquadsSquadIdRequest struct {
	ctx context.Context
	ApiService FleetsAPI
	fleetId int64
	squadId int64
	xCompatibilityDate *string
	putFleetsFleetIdSquadsSquadIdRequest *PutFleetsFleetIdSquadsSquadIdRequest
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiPutFleetsFleetIdSquadsSquadIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiPutFleetsFleetIdSquadsSquadIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiPutFleetsFleetIdSquadsSquadIdRequest) PutFleetsFleetIdSquadsSquadIdRequest(putFleetsFleetIdSquadsSquadIdRequest PutFleetsFleetIdSquadsSquadIdRequest) ApiPutFleetsFleetIdSquadsSquadIdRequest {
	r.putFleetsFleetIdSquadsSquadIdRequest = &putFleetsFleetIdSquadsSquadIdRequest
	return r
}

// The language to use for the response.
func (r ApiPutFleetsFleetIdSquadsSquadIdRequest) AcceptLanguage(acceptLanguage string) ApiPutFleetsFleetIdSquadsSquadIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPutFleetsFleetIdSquadsSquadIdRequest) IfNoneMatch(ifNoneMatch string) ApiPutFleetsFleetIdSquadsSquadIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiPutFleetsFleetIdSquadsSquadIdRequest) XTenant(xTenant string) ApiPutFleetsFleetIdSquadsSquadIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPutFleetsFleetIdSquadsSquadIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutFleetsFleetIdSquadsSquadIdExecute(r)
}

/*
PutFleetsFleetIdSquadsSquadId Rename fleet squad

Rename a fleet squad

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fleetId
 @param squadId
 @return ApiPutFleetsFleetIdSquadsSquadIdRequest
*/
func (a *FleetsAPIService) PutFleetsFleetIdSquadsSquadId(ctx context.Context, fleetId int64, squadId int64) ApiPutFleetsFleetIdSquadsSquadIdRequest {
	return ApiPutFleetsFleetIdSquadsSquadIdRequest{
		ApiService: a,
		ctx: ctx,
		fleetId: fleetId,
		squadId: squadId,
	}
}

// Execute executes the request
func (a *FleetsAPIService) PutFleetsFleetIdSquadsSquadIdExecute(r ApiPutFleetsFleetIdSquadsSquadIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetsAPIService.PutFleetsFleetIdSquadsSquadId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fleets/{fleet_id}/squads/{squad_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"fleet_id"+"}", url.PathEscape(parameterValueToString(r.fleetId, "fleetId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"squad_id"+"}", url.PathEscape(parameterValueToString(r.squadId, "squadId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return nil, reportError("xCompatibilityDate is required and must be specified")
	}
	if r.putFleetsFleetIdSquadsSquadIdRequest == nil {
		return nil, reportError("putFleetsFleetIdSquadsSquadIdRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	// body params
	localVarPostBody = r.putFleetsFleetIdSquadsSquadIdRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutFleetsFleetIdWingsWingIdRequest struct {
	ctx context.Context
	ApiService FleetsAPI
	fleetId int64
	wingId int64
	xCompatibilityDate *string
	putFleetsFleetIdSquadsSquadIdRequest *PutFleetsFleetIdSquadsSquadIdRequest
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiPutFleetsFleetIdWingsWingIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiPutFleetsFleetIdWingsWingIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiPutFleetsFleetIdWingsWingIdRequest) PutFleetsFleetIdSquadsSquadIdRequest(putFleetsFleetIdSquadsSquadIdRequest PutFleetsFleetIdSquadsSquadIdRequest) ApiPutFleetsFleetIdWingsWingIdRequest {
	r.putFleetsFleetIdSquadsSquadIdRequest = &putFleetsFleetIdSquadsSquadIdRequest
	return r
}

// The language to use for the response.
func (r ApiPutFleetsFleetIdWingsWingIdRequest) AcceptLanguage(acceptLanguage string) ApiPutFleetsFleetIdWingsWingIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPutFleetsFleetIdWingsWingIdRequest) IfNoneMatch(ifNoneMatch string) ApiPutFleetsFleetIdWingsWingIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiPutFleetsFleetIdWingsWingIdRequest) XTenant(xTenant string) ApiPutFleetsFleetIdWingsWingIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPutFleetsFleetIdWingsWingIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutFleetsFleetIdWingsWingIdExecute(r)
}

/*
PutFleetsFleetIdWingsWingId Rename fleet wing

Rename a fleet wing

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fleetId
 @param wingId
 @return ApiPutFleetsFleetIdWingsWingIdRequest
*/
func (a *FleetsAPIService) PutFleetsFleetIdWingsWingId(ctx context.Context, fleetId int64, wingId int64) ApiPutFleetsFleetIdWingsWingIdRequest {
	return ApiPutFleetsFleetIdWingsWingIdRequest{
		ApiService: a,
		ctx: ctx,
		fleetId: fleetId,
		wingId: wingId,
	}
}

// Execute executes the request
func (a *FleetsAPIService) PutFleetsFleetIdWingsWingIdExecute(r ApiPutFleetsFleetIdWingsWingIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetsAPIService.PutFleetsFleetIdWingsWingId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fleets/{fleet_id}/wings/{wing_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"fleet_id"+"}", url.PathEscape(parameterValueToString(r.fleetId, "fleetId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wing_id"+"}", url.PathEscape(parameterValueToString(r.wingId, "wingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return nil, reportError("xCompatibilityDate is required and must be specified")
	}
	if r.putFleetsFleetIdSquadsSquadIdRequest == nil {
		return nil, reportError("putFleetsFleetIdSquadsSquadIdRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	// body params
	localVarPostBody = r.putFleetsFleetIdSquadsSquadIdRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
