/*
EVE Stable Infrastructure (ESI) - tranquility

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2020-01-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package esi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


type ContactsAPI interface {

	/*
	DeleteCharactersCharacterIdContacts Delete contacts

	Bulk delete contacts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiDeleteCharactersCharacterIdContactsRequest
	*/
	DeleteCharactersCharacterIdContacts(ctx context.Context, characterId int64) ApiDeleteCharactersCharacterIdContactsRequest

	// DeleteCharactersCharacterIdContactsExecute executes the request
	DeleteCharactersCharacterIdContactsExecute(r ApiDeleteCharactersCharacterIdContactsRequest) (*http.Response, error)

	/*
	GetAlliancesAllianceIdContacts Get alliance contacts

	Return contacts of an alliance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param allianceId The ID of the alliance
	@return ApiGetAlliancesAllianceIdContactsRequest
	*/
	GetAlliancesAllianceIdContacts(ctx context.Context, allianceId int64) ApiGetAlliancesAllianceIdContactsRequest

	// GetAlliancesAllianceIdContactsExecute executes the request
	//  @return []AlliancesAllianceIdContactsGetInner
	GetAlliancesAllianceIdContactsExecute(r ApiGetAlliancesAllianceIdContactsRequest) ([]AlliancesAllianceIdContactsGetInner, *http.Response, error)

	/*
	GetAlliancesAllianceIdContactsLabels Get alliance contact labels

	Return custom labels for an alliance's contacts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param allianceId The ID of the alliance
	@return ApiGetAlliancesAllianceIdContactsLabelsRequest
	*/
	GetAlliancesAllianceIdContactsLabels(ctx context.Context, allianceId int64) ApiGetAlliancesAllianceIdContactsLabelsRequest

	// GetAlliancesAllianceIdContactsLabelsExecute executes the request
	//  @return []AlliancesAllianceIdContactsLabelsGetInner
	GetAlliancesAllianceIdContactsLabelsExecute(r ApiGetAlliancesAllianceIdContactsLabelsRequest) ([]AlliancesAllianceIdContactsLabelsGetInner, *http.Response, error)

	/*
	GetCharactersCharacterIdContacts Get contacts

	Return contacts of a character

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdContactsRequest
	*/
	GetCharactersCharacterIdContacts(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdContactsRequest

	// GetCharactersCharacterIdContactsExecute executes the request
	//  @return []CharactersCharacterIdContactsGetInner
	GetCharactersCharacterIdContactsExecute(r ApiGetCharactersCharacterIdContactsRequest) ([]CharactersCharacterIdContactsGetInner, *http.Response, error)

	/*
	GetCharactersCharacterIdContactsLabels Get contact labels

	Return custom labels for a character's contacts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdContactsLabelsRequest
	*/
	GetCharactersCharacterIdContactsLabels(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdContactsLabelsRequest

	// GetCharactersCharacterIdContactsLabelsExecute executes the request
	//  @return []AlliancesAllianceIdContactsLabelsGetInner
	GetCharactersCharacterIdContactsLabelsExecute(r ApiGetCharactersCharacterIdContactsLabelsRequest) ([]AlliancesAllianceIdContactsLabelsGetInner, *http.Response, error)

	/*
	GetCorporationsCorporationIdContacts Get corporation contacts

	Return contacts of a corporation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdContactsRequest
	*/
	GetCorporationsCorporationIdContacts(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdContactsRequest

	// GetCorporationsCorporationIdContactsExecute executes the request
	//  @return []CorporationsCorporationIdContactsGetInner
	GetCorporationsCorporationIdContactsExecute(r ApiGetCorporationsCorporationIdContactsRequest) ([]CorporationsCorporationIdContactsGetInner, *http.Response, error)

	/*
	GetCorporationsCorporationIdContactsLabels Get corporation contact labels

	Return custom labels for a corporation's contacts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdContactsLabelsRequest
	*/
	GetCorporationsCorporationIdContactsLabels(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdContactsLabelsRequest

	// GetCorporationsCorporationIdContactsLabelsExecute executes the request
	//  @return []AlliancesAllianceIdContactsLabelsGetInner
	GetCorporationsCorporationIdContactsLabelsExecute(r ApiGetCorporationsCorporationIdContactsLabelsRequest) ([]AlliancesAllianceIdContactsLabelsGetInner, *http.Response, error)

	/*
	PostCharactersCharacterIdContacts Add contacts

	Bulk add contacts with same settings

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiPostCharactersCharacterIdContactsRequest
	*/
	PostCharactersCharacterIdContacts(ctx context.Context, characterId int64) ApiPostCharactersCharacterIdContactsRequest

	// PostCharactersCharacterIdContactsExecute executes the request
	//  @return []int64
	PostCharactersCharacterIdContactsExecute(r ApiPostCharactersCharacterIdContactsRequest) ([]int64, *http.Response, error)

	/*
	PutCharactersCharacterIdContacts Edit contacts

	Bulk edit contacts with same settings

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiPutCharactersCharacterIdContactsRequest
	*/
	PutCharactersCharacterIdContacts(ctx context.Context, characterId int64) ApiPutCharactersCharacterIdContactsRequest

	// PutCharactersCharacterIdContactsExecute executes the request
	PutCharactersCharacterIdContactsExecute(r ApiPutCharactersCharacterIdContactsRequest) (*http.Response, error)
}

// ContactsAPIService ContactsAPI service
type ContactsAPIService service

type ApiDeleteCharactersCharacterIdContactsRequest struct {
	ctx context.Context
	ApiService ContactsAPI
	characterId int64
	contactIds *[]int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

func (r ApiDeleteCharactersCharacterIdContactsRequest) ContactIds(contactIds []int64) ApiDeleteCharactersCharacterIdContactsRequest {
	r.contactIds = &contactIds
	return r
}

// The compatibility date for the request.
func (r ApiDeleteCharactersCharacterIdContactsRequest) XCompatibilityDate(xCompatibilityDate string) ApiDeleteCharactersCharacterIdContactsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiDeleteCharactersCharacterIdContactsRequest) AcceptLanguage(acceptLanguage string) ApiDeleteCharactersCharacterIdContactsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiDeleteCharactersCharacterIdContactsRequest) IfNoneMatch(ifNoneMatch string) ApiDeleteCharactersCharacterIdContactsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiDeleteCharactersCharacterIdContactsRequest) XTenant(xTenant string) ApiDeleteCharactersCharacterIdContactsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiDeleteCharactersCharacterIdContactsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCharactersCharacterIdContactsExecute(r)
}

/*
DeleteCharactersCharacterIdContacts Delete contacts

Bulk delete contacts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiDeleteCharactersCharacterIdContactsRequest
*/
func (a *ContactsAPIService) DeleteCharactersCharacterIdContacts(ctx context.Context, characterId int64) ApiDeleteCharactersCharacterIdContactsRequest {
	return ApiDeleteCharactersCharacterIdContactsRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
func (a *ContactsAPIService) DeleteCharactersCharacterIdContactsExecute(r ApiDeleteCharactersCharacterIdContactsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContactsAPIService.DeleteCharactersCharacterIdContacts")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/contacts"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contactIds == nil {
		return nil, reportError("contactIds is required and must be specified")
	}
	if len(*r.contactIds) < 1 {
		return nil, reportError("contactIds must have at least 1 elements")
	}
	if len(*r.contactIds) > 20 {
		return nil, reportError("contactIds must have less than 20 elements")
	}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return nil, reportError("xCompatibilityDate is required and must be specified")
	}

	{
		t := *r.contactIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contact_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contact_ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAlliancesAllianceIdContactsRequest struct {
	ctx context.Context
	ApiService ContactsAPI
	allianceId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetAlliancesAllianceIdContactsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetAlliancesAllianceIdContactsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetAlliancesAllianceIdContactsRequest) Page(page int32) ApiGetAlliancesAllianceIdContactsRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetAlliancesAllianceIdContactsRequest) AcceptLanguage(acceptLanguage string) ApiGetAlliancesAllianceIdContactsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetAlliancesAllianceIdContactsRequest) IfNoneMatch(ifNoneMatch string) ApiGetAlliancesAllianceIdContactsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetAlliancesAllianceIdContactsRequest) XTenant(xTenant string) ApiGetAlliancesAllianceIdContactsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetAlliancesAllianceIdContactsRequest) Execute() ([]AlliancesAllianceIdContactsGetInner, *http.Response, error) {
	return r.ApiService.GetAlliancesAllianceIdContactsExecute(r)
}

/*
GetAlliancesAllianceIdContacts Get alliance contacts

Return contacts of an alliance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param allianceId The ID of the alliance
 @return ApiGetAlliancesAllianceIdContactsRequest
*/
func (a *ContactsAPIService) GetAlliancesAllianceIdContacts(ctx context.Context, allianceId int64) ApiGetAlliancesAllianceIdContactsRequest {
	return ApiGetAlliancesAllianceIdContactsRequest{
		ApiService: a,
		ctx: ctx,
		allianceId: allianceId,
	}
}

// Execute executes the request
//  @return []AlliancesAllianceIdContactsGetInner
func (a *ContactsAPIService) GetAlliancesAllianceIdContactsExecute(r ApiGetAlliancesAllianceIdContactsRequest) ([]AlliancesAllianceIdContactsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AlliancesAllianceIdContactsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContactsAPIService.GetAlliancesAllianceIdContacts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alliances/{alliance_id}/contacts"
	localVarPath = strings.Replace(localVarPath, "{"+"alliance_id"+"}", url.PathEscape(parameterValueToString(r.allianceId, "allianceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAlliancesAllianceIdContactsLabelsRequest struct {
	ctx context.Context
	ApiService ContactsAPI
	allianceId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetAlliancesAllianceIdContactsLabelsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetAlliancesAllianceIdContactsLabelsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetAlliancesAllianceIdContactsLabelsRequest) AcceptLanguage(acceptLanguage string) ApiGetAlliancesAllianceIdContactsLabelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetAlliancesAllianceIdContactsLabelsRequest) IfNoneMatch(ifNoneMatch string) ApiGetAlliancesAllianceIdContactsLabelsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetAlliancesAllianceIdContactsLabelsRequest) XTenant(xTenant string) ApiGetAlliancesAllianceIdContactsLabelsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetAlliancesAllianceIdContactsLabelsRequest) Execute() ([]AlliancesAllianceIdContactsLabelsGetInner, *http.Response, error) {
	return r.ApiService.GetAlliancesAllianceIdContactsLabelsExecute(r)
}

/*
GetAlliancesAllianceIdContactsLabels Get alliance contact labels

Return custom labels for an alliance's contacts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param allianceId The ID of the alliance
 @return ApiGetAlliancesAllianceIdContactsLabelsRequest
*/
func (a *ContactsAPIService) GetAlliancesAllianceIdContactsLabels(ctx context.Context, allianceId int64) ApiGetAlliancesAllianceIdContactsLabelsRequest {
	return ApiGetAlliancesAllianceIdContactsLabelsRequest{
		ApiService: a,
		ctx: ctx,
		allianceId: allianceId,
	}
}

// Execute executes the request
//  @return []AlliancesAllianceIdContactsLabelsGetInner
func (a *ContactsAPIService) GetAlliancesAllianceIdContactsLabelsExecute(r ApiGetAlliancesAllianceIdContactsLabelsRequest) ([]AlliancesAllianceIdContactsLabelsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AlliancesAllianceIdContactsLabelsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContactsAPIService.GetAlliancesAllianceIdContactsLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alliances/{alliance_id}/contacts/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"alliance_id"+"}", url.PathEscape(parameterValueToString(r.allianceId, "allianceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCharactersCharacterIdContactsRequest struct {
	ctx context.Context
	ApiService ContactsAPI
	characterId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdContactsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdContactsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCharactersCharacterIdContactsRequest) Page(page int32) ApiGetCharactersCharacterIdContactsRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdContactsRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdContactsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdContactsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdContactsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdContactsRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdContactsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdContactsRequest) Execute() ([]CharactersCharacterIdContactsGetInner, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdContactsExecute(r)
}

/*
GetCharactersCharacterIdContacts Get contacts

Return contacts of a character

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdContactsRequest
*/
func (a *ContactsAPIService) GetCharactersCharacterIdContacts(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdContactsRequest {
	return ApiGetCharactersCharacterIdContactsRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return []CharactersCharacterIdContactsGetInner
func (a *ContactsAPIService) GetCharactersCharacterIdContactsExecute(r ApiGetCharactersCharacterIdContactsRequest) ([]CharactersCharacterIdContactsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharactersCharacterIdContactsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContactsAPIService.GetCharactersCharacterIdContacts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/contacts"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCharactersCharacterIdContactsLabelsRequest struct {
	ctx context.Context
	ApiService ContactsAPI
	characterId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdContactsLabelsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdContactsLabelsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdContactsLabelsRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdContactsLabelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdContactsLabelsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdContactsLabelsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdContactsLabelsRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdContactsLabelsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdContactsLabelsRequest) Execute() ([]AlliancesAllianceIdContactsLabelsGetInner, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdContactsLabelsExecute(r)
}

/*
GetCharactersCharacterIdContactsLabels Get contact labels

Return custom labels for a character's contacts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdContactsLabelsRequest
*/
func (a *ContactsAPIService) GetCharactersCharacterIdContactsLabels(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdContactsLabelsRequest {
	return ApiGetCharactersCharacterIdContactsLabelsRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return []AlliancesAllianceIdContactsLabelsGetInner
func (a *ContactsAPIService) GetCharactersCharacterIdContactsLabelsExecute(r ApiGetCharactersCharacterIdContactsLabelsRequest) ([]AlliancesAllianceIdContactsLabelsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AlliancesAllianceIdContactsLabelsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContactsAPIService.GetCharactersCharacterIdContactsLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/contacts/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdContactsRequest struct {
	ctx context.Context
	ApiService ContactsAPI
	corporationId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdContactsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdContactsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCorporationsCorporationIdContactsRequest) Page(page int32) ApiGetCorporationsCorporationIdContactsRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdContactsRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdContactsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdContactsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdContactsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdContactsRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdContactsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdContactsRequest) Execute() ([]CorporationsCorporationIdContactsGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdContactsExecute(r)
}

/*
GetCorporationsCorporationIdContacts Get corporation contacts

Return contacts of a corporation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdContactsRequest
*/
func (a *ContactsAPIService) GetCorporationsCorporationIdContacts(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdContactsRequest {
	return ApiGetCorporationsCorporationIdContactsRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CorporationsCorporationIdContactsGetInner
func (a *ContactsAPIService) GetCorporationsCorporationIdContactsExecute(r ApiGetCorporationsCorporationIdContactsRequest) ([]CorporationsCorporationIdContactsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CorporationsCorporationIdContactsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContactsAPIService.GetCorporationsCorporationIdContacts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/contacts"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdContactsLabelsRequest struct {
	ctx context.Context
	ApiService ContactsAPI
	corporationId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdContactsLabelsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdContactsLabelsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdContactsLabelsRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdContactsLabelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdContactsLabelsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdContactsLabelsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdContactsLabelsRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdContactsLabelsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdContactsLabelsRequest) Execute() ([]AlliancesAllianceIdContactsLabelsGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdContactsLabelsExecute(r)
}

/*
GetCorporationsCorporationIdContactsLabels Get corporation contact labels

Return custom labels for a corporation's contacts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdContactsLabelsRequest
*/
func (a *ContactsAPIService) GetCorporationsCorporationIdContactsLabels(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdContactsLabelsRequest {
	return ApiGetCorporationsCorporationIdContactsLabelsRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []AlliancesAllianceIdContactsLabelsGetInner
func (a *ContactsAPIService) GetCorporationsCorporationIdContactsLabelsExecute(r ApiGetCorporationsCorporationIdContactsLabelsRequest) ([]AlliancesAllianceIdContactsLabelsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AlliancesAllianceIdContactsLabelsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContactsAPIService.GetCorporationsCorporationIdContactsLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/contacts/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCharactersCharacterIdContactsRequest struct {
	ctx context.Context
	ApiService ContactsAPI
	characterId int64
	standing *float64
	xCompatibilityDate *string
	requestBody *[]int64
	labelIds *[]int64
	watched *bool
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

func (r ApiPostCharactersCharacterIdContactsRequest) Standing(standing float64) ApiPostCharactersCharacterIdContactsRequest {
	r.standing = &standing
	return r
}

// The compatibility date for the request.
func (r ApiPostCharactersCharacterIdContactsRequest) XCompatibilityDate(xCompatibilityDate string) ApiPostCharactersCharacterIdContactsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiPostCharactersCharacterIdContactsRequest) RequestBody(requestBody []int64) ApiPostCharactersCharacterIdContactsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiPostCharactersCharacterIdContactsRequest) LabelIds(labelIds []int64) ApiPostCharactersCharacterIdContactsRequest {
	r.labelIds = &labelIds
	return r
}

func (r ApiPostCharactersCharacterIdContactsRequest) Watched(watched bool) ApiPostCharactersCharacterIdContactsRequest {
	r.watched = &watched
	return r
}

// The language to use for the response.
func (r ApiPostCharactersCharacterIdContactsRequest) AcceptLanguage(acceptLanguage string) ApiPostCharactersCharacterIdContactsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPostCharactersCharacterIdContactsRequest) IfNoneMatch(ifNoneMatch string) ApiPostCharactersCharacterIdContactsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiPostCharactersCharacterIdContactsRequest) XTenant(xTenant string) ApiPostCharactersCharacterIdContactsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPostCharactersCharacterIdContactsRequest) Execute() ([]int64, *http.Response, error) {
	return r.ApiService.PostCharactersCharacterIdContactsExecute(r)
}

/*
PostCharactersCharacterIdContacts Add contacts

Bulk add contacts with same settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiPostCharactersCharacterIdContactsRequest
*/
func (a *ContactsAPIService) PostCharactersCharacterIdContacts(ctx context.Context, characterId int64) ApiPostCharactersCharacterIdContactsRequest {
	return ApiPostCharactersCharacterIdContactsRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return []int64
func (a *ContactsAPIService) PostCharactersCharacterIdContactsExecute(r ApiPostCharactersCharacterIdContactsRequest) ([]int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContactsAPIService.PostCharactersCharacterIdContacts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/contacts"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.standing == nil {
		return localVarReturnValue, nil, reportError("standing is required and must be specified")
	}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}
	if len(*r.requestBody) < 1 {
		return localVarReturnValue, nil, reportError("requestBody must have at least 1 elements")
	}
	if len(*r.requestBody) > 100 {
		return localVarReturnValue, nil, reportError("requestBody must have less than 100 elements")
	}

	if r.labelIds != nil {
		t := *r.labelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label_ids", t, "form", "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "standing", r.standing, "form", "")
	if r.watched != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "watched", r.watched, "form", "")
	} else {
		var defaultValue bool = false
		r.watched = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutCharactersCharacterIdContactsRequest struct {
	ctx context.Context
	ApiService ContactsAPI
	characterId int64
	standing *float64
	xCompatibilityDate *string
	requestBody *[]int64
	labelIds *[]int64
	watched *bool
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

func (r ApiPutCharactersCharacterIdContactsRequest) Standing(standing float64) ApiPutCharactersCharacterIdContactsRequest {
	r.standing = &standing
	return r
}

// The compatibility date for the request.
func (r ApiPutCharactersCharacterIdContactsRequest) XCompatibilityDate(xCompatibilityDate string) ApiPutCharactersCharacterIdContactsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiPutCharactersCharacterIdContactsRequest) RequestBody(requestBody []int64) ApiPutCharactersCharacterIdContactsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiPutCharactersCharacterIdContactsRequest) LabelIds(labelIds []int64) ApiPutCharactersCharacterIdContactsRequest {
	r.labelIds = &labelIds
	return r
}

func (r ApiPutCharactersCharacterIdContactsRequest) Watched(watched bool) ApiPutCharactersCharacterIdContactsRequest {
	r.watched = &watched
	return r
}

// The language to use for the response.
func (r ApiPutCharactersCharacterIdContactsRequest) AcceptLanguage(acceptLanguage string) ApiPutCharactersCharacterIdContactsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiPutCharactersCharacterIdContactsRequest) IfNoneMatch(ifNoneMatch string) ApiPutCharactersCharacterIdContactsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiPutCharactersCharacterIdContactsRequest) XTenant(xTenant string) ApiPutCharactersCharacterIdContactsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiPutCharactersCharacterIdContactsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutCharactersCharacterIdContactsExecute(r)
}

/*
PutCharactersCharacterIdContacts Edit contacts

Bulk edit contacts with same settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiPutCharactersCharacterIdContactsRequest
*/
func (a *ContactsAPIService) PutCharactersCharacterIdContacts(ctx context.Context, characterId int64) ApiPutCharactersCharacterIdContactsRequest {
	return ApiPutCharactersCharacterIdContactsRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
func (a *ContactsAPIService) PutCharactersCharacterIdContactsExecute(r ApiPutCharactersCharacterIdContactsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContactsAPIService.PutCharactersCharacterIdContacts")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/contacts"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.standing == nil {
		return nil, reportError("standing is required and must be specified")
	}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return nil, reportError("xCompatibilityDate is required and must be specified")
	}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}
	if len(*r.requestBody) < 1 {
		return nil, reportError("requestBody must have at least 1 elements")
	}
	if len(*r.requestBody) > 100 {
		return nil, reportError("requestBody must have less than 100 elements")
	}

	if r.labelIds != nil {
		t := *r.labelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label_ids", t, "form", "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "standing", r.standing, "form", "")
	if r.watched != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "watched", r.watched, "form", "")
	} else {
		var defaultValue bool = false
		r.watched = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
