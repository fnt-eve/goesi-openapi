/*
EVE Stable Infrastructure (ESI) - tranquility

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2025-09-30
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package esi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type CorporationProjectsAPI interface {

	/*
	GetCorporationsProjectsContribution Get your project contribution

	Show your contribution to a corporation project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@param projectId The ID of the project
	@param characterId The ID of the character
	@return ApiGetCorporationsProjectsContributionRequest
	*/
	GetCorporationsProjectsContribution(ctx context.Context, corporationId int64, projectId string, characterId int64) ApiGetCorporationsProjectsContributionRequest

	// GetCorporationsProjectsContributionExecute executes the request
	//  @return CorporationsProjectsContribution
	GetCorporationsProjectsContributionExecute(r ApiGetCorporationsProjectsContributionRequest) (*CorporationsProjectsContribution, *http.Response, error)

	/*
	GetCorporationsProjectsContributors List project contributors

	Listing of all contributors to a corporation project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@param projectId The ID of the project
	@return ApiGetCorporationsProjectsContributorsRequest
	*/
	GetCorporationsProjectsContributors(ctx context.Context, corporationId int64, projectId string) ApiGetCorporationsProjectsContributorsRequest

	// GetCorporationsProjectsContributorsExecute executes the request
	//  @return CorporationsProjectsContributors
	GetCorporationsProjectsContributorsExecute(r ApiGetCorporationsProjectsContributorsRequest) (*CorporationsProjectsContributors, *http.Response, error)

	/*
	GetCorporationsProjectsDetail Get project details

	Get the details of a corporation project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@param projectId The ID of the project
	@return ApiGetCorporationsProjectsDetailRequest
	*/
	GetCorporationsProjectsDetail(ctx context.Context, corporationId int64, projectId string) ApiGetCorporationsProjectsDetailRequest

	// GetCorporationsProjectsDetailExecute executes the request
	//  @return CorporationsProjectsDetail
	GetCorporationsProjectsDetailExecute(r ApiGetCorporationsProjectsDetailRequest) (*CorporationsProjectsDetail, *http.Response, error)

	/*
	GetCorporationsProjectsListing List corporation projects

	Listing of all (active) corporation projects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsProjectsListingRequest
	*/
	GetCorporationsProjectsListing(ctx context.Context, corporationId int64) ApiGetCorporationsProjectsListingRequest

	// GetCorporationsProjectsListingExecute executes the request
	//  @return CorporationsProjectsListing
	GetCorporationsProjectsListingExecute(r ApiGetCorporationsProjectsListingRequest) (*CorporationsProjectsListing, *http.Response, error)
}

// CorporationProjectsAPIService CorporationProjectsAPI service
type CorporationProjectsAPIService service

type ApiGetCorporationsProjectsContributionRequest struct {
	ctx context.Context
	ApiService CorporationProjectsAPI
	corporationId int64
	projectId string
	characterId int64
	xCompatibilityDate *string
	ifModifiedSince *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsProjectsContributionRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsProjectsContributionRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The date the resource was last modified. A 304 will be returned if the resource has not been modified since this date.
func (r ApiGetCorporationsProjectsContributionRequest) IfModifiedSince(ifModifiedSince string) ApiGetCorporationsProjectsContributionRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsProjectsContributionRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsProjectsContributionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsProjectsContributionRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsProjectsContributionRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsProjectsContributionRequest) XTenant(xTenant string) ApiGetCorporationsProjectsContributionRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsProjectsContributionRequest) Execute() (*CorporationsProjectsContribution, *http.Response, error) {
	return r.ApiService.GetCorporationsProjectsContributionExecute(r)
}

/*
GetCorporationsProjectsContribution Get your project contribution

Show your contribution to a corporation project.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @param projectId The ID of the project
 @param characterId The ID of the character
 @return ApiGetCorporationsProjectsContributionRequest
*/
func (a *CorporationProjectsAPIService) GetCorporationsProjectsContribution(ctx context.Context, corporationId int64, projectId string, characterId int64) ApiGetCorporationsProjectsContributionRequest {
	return ApiGetCorporationsProjectsContributionRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
		projectId: projectId,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return CorporationsProjectsContribution
func (a *CorporationProjectsAPIService) GetCorporationsProjectsContributionExecute(r ApiGetCorporationsProjectsContributionRequest) (*CorporationsProjectsContribution, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CorporationsProjectsContribution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationProjectsAPIService.GetCorporationsProjectsContribution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/projects/{project_id}/contribution/{character_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "simple", "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsProjectsContributorsRequest struct {
	ctx context.Context
	ApiService CorporationProjectsAPI
	corporationId int64
	projectId string
	xCompatibilityDate *string
	after *string
	before *string
	limit *int64
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsProjectsContributorsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsProjectsContributorsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// Return records from after this cursor (mutual exclusive with &#39;before&#39;). &#39;0&#39; to start from the beginning.
func (r ApiGetCorporationsProjectsContributorsRequest) After(after string) ApiGetCorporationsProjectsContributorsRequest {
	r.after = &after
	return r
}

// Return records from before this cursor (mutual exclusive with &#39;after&#39;). &#39;0&#39; to start from the end.
func (r ApiGetCorporationsProjectsContributorsRequest) Before(before string) ApiGetCorporationsProjectsContributorsRequest {
	r.before = &before
	return r
}

// The amount of records to retrieve per request.
func (r ApiGetCorporationsProjectsContributorsRequest) Limit(limit int64) ApiGetCorporationsProjectsContributorsRequest {
	r.limit = &limit
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsProjectsContributorsRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsProjectsContributorsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsProjectsContributorsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsProjectsContributorsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsProjectsContributorsRequest) XTenant(xTenant string) ApiGetCorporationsProjectsContributorsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsProjectsContributorsRequest) Execute() (*CorporationsProjectsContributors, *http.Response, error) {
	return r.ApiService.GetCorporationsProjectsContributorsExecute(r)
}

/*
GetCorporationsProjectsContributors List project contributors

Listing of all contributors to a corporation project.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @param projectId The ID of the project
 @return ApiGetCorporationsProjectsContributorsRequest
*/
func (a *CorporationProjectsAPIService) GetCorporationsProjectsContributors(ctx context.Context, corporationId int64, projectId string) ApiGetCorporationsProjectsContributorsRequest {
	return ApiGetCorporationsProjectsContributorsRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return CorporationsProjectsContributors
func (a *CorporationProjectsAPIService) GetCorporationsProjectsContributorsExecute(r ApiGetCorporationsProjectsContributorsRequest) (*CorporationsProjectsContributors, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CorporationsProjectsContributors
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationProjectsAPIService.GetCorporationsProjectsContributors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/projects/{project_id}/contributors"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int64 = 10
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsProjectsDetailRequest struct {
	ctx context.Context
	ApiService CorporationProjectsAPI
	corporationId int64
	projectId string
	xCompatibilityDate *string
	ifModifiedSince *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsProjectsDetailRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsProjectsDetailRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The date the resource was last modified. A 304 will be returned if the resource has not been modified since this date.
func (r ApiGetCorporationsProjectsDetailRequest) IfModifiedSince(ifModifiedSince string) ApiGetCorporationsProjectsDetailRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsProjectsDetailRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsProjectsDetailRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsProjectsDetailRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsProjectsDetailRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsProjectsDetailRequest) XTenant(xTenant string) ApiGetCorporationsProjectsDetailRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsProjectsDetailRequest) Execute() (*CorporationsProjectsDetail, *http.Response, error) {
	return r.ApiService.GetCorporationsProjectsDetailExecute(r)
}

/*
GetCorporationsProjectsDetail Get project details

Get the details of a corporation project.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @param projectId The ID of the project
 @return ApiGetCorporationsProjectsDetailRequest
*/
func (a *CorporationProjectsAPIService) GetCorporationsProjectsDetail(ctx context.Context, corporationId int64, projectId string) ApiGetCorporationsProjectsDetailRequest {
	return ApiGetCorporationsProjectsDetailRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return CorporationsProjectsDetail
func (a *CorporationProjectsAPIService) GetCorporationsProjectsDetailExecute(r ApiGetCorporationsProjectsDetailRequest) (*CorporationsProjectsDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CorporationsProjectsDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationProjectsAPIService.GetCorporationsProjectsDetail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/projects/{project_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "simple", "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsProjectsListingRequest struct {
	ctx context.Context
	ApiService CorporationProjectsAPI
	corporationId int64
	xCompatibilityDate *string
	after *string
	before *string
	limit *int64
	state *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsProjectsListingRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsProjectsListingRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// Return records from after this cursor (mutual exclusive with &#39;before&#39;). &#39;0&#39; to start from the beginning.
func (r ApiGetCorporationsProjectsListingRequest) After(after string) ApiGetCorporationsProjectsListingRequest {
	r.after = &after
	return r
}

// Return records from before this cursor (mutual exclusive with &#39;after&#39;). &#39;0&#39; to start from the end.
func (r ApiGetCorporationsProjectsListingRequest) Before(before string) ApiGetCorporationsProjectsListingRequest {
	r.before = &before
	return r
}

// The amount of records to retrieve per request.
func (r ApiGetCorporationsProjectsListingRequest) Limit(limit int64) ApiGetCorporationsProjectsListingRequest {
	r.limit = &limit
	return r
}

// Filter by state
func (r ApiGetCorporationsProjectsListingRequest) State(state string) ApiGetCorporationsProjectsListingRequest {
	r.state = &state
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsProjectsListingRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsProjectsListingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsProjectsListingRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsProjectsListingRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsProjectsListingRequest) XTenant(xTenant string) ApiGetCorporationsProjectsListingRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsProjectsListingRequest) Execute() (*CorporationsProjectsListing, *http.Response, error) {
	return r.ApiService.GetCorporationsProjectsListingExecute(r)
}

/*
GetCorporationsProjectsListing List corporation projects

Listing of all (active) corporation projects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsProjectsListingRequest
*/
func (a *CorporationProjectsAPIService) GetCorporationsProjectsListing(ctx context.Context, corporationId int64) ApiGetCorporationsProjectsListingRequest {
	return ApiGetCorporationsProjectsListingRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return CorporationsProjectsListing
func (a *CorporationProjectsAPIService) GetCorporationsProjectsListingExecute(r ApiGetCorporationsProjectsListingRequest) (*CorporationsProjectsListing, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CorporationsProjectsListing
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CorporationProjectsAPIService.GetCorporationsProjectsListing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/projects"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int64 = 10
		r.limit = &defaultValue
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	} else {
		var defaultValue string = "Active"
		r.state = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
