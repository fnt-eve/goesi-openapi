/*
EVE Stable Infrastructure (ESI) - tranquility

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2025-09-30
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package esi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type ContractsAPI interface {

	/*
	GetCharactersCharacterIdContracts Get contracts

	Returns contracts available to a character, only if the character is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is "in_progress".

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@return ApiGetCharactersCharacterIdContractsRequest
	*/
	GetCharactersCharacterIdContracts(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdContractsRequest

	// GetCharactersCharacterIdContractsExecute executes the request
	//  @return []CharactersCharacterIdContractsGetInner
	GetCharactersCharacterIdContractsExecute(r ApiGetCharactersCharacterIdContractsRequest) ([]CharactersCharacterIdContractsGetInner, *http.Response, error)

	/*
	GetCharactersCharacterIdContractsContractIdBids Get contract bids

	Lists bids on a particular auction contract

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@param contractId
	@return ApiGetCharactersCharacterIdContractsContractIdBidsRequest
	*/
	GetCharactersCharacterIdContractsContractIdBids(ctx context.Context, characterId int64, contractId int64) ApiGetCharactersCharacterIdContractsContractIdBidsRequest

	// GetCharactersCharacterIdContractsContractIdBidsExecute executes the request
	//  @return []CharactersCharacterIdContractsContractIdBidsGetInner
	GetCharactersCharacterIdContractsContractIdBidsExecute(r ApiGetCharactersCharacterIdContractsContractIdBidsRequest) ([]CharactersCharacterIdContractsContractIdBidsGetInner, *http.Response, error)

	/*
	GetCharactersCharacterIdContractsContractIdItems Get contract items

	Lists items of a particular contract

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param characterId The ID of the character
	@param contractId
	@return ApiGetCharactersCharacterIdContractsContractIdItemsRequest
	*/
	GetCharactersCharacterIdContractsContractIdItems(ctx context.Context, characterId int64, contractId int64) ApiGetCharactersCharacterIdContractsContractIdItemsRequest

	// GetCharactersCharacterIdContractsContractIdItemsExecute executes the request
	//  @return []CharactersCharacterIdContractsContractIdItemsGetInner
	GetCharactersCharacterIdContractsContractIdItemsExecute(r ApiGetCharactersCharacterIdContractsContractIdItemsRequest) ([]CharactersCharacterIdContractsContractIdItemsGetInner, *http.Response, error)

	/*
	GetContractsPublicBidsContractId Get public contract bids

	Lists bids on a public auction contract

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractId
	@return ApiGetContractsPublicBidsContractIdRequest
	*/
	GetContractsPublicBidsContractId(ctx context.Context, contractId int64) ApiGetContractsPublicBidsContractIdRequest

	// GetContractsPublicBidsContractIdExecute executes the request
	//  @return []ContractsPublicBidsContractIdGetInner
	GetContractsPublicBidsContractIdExecute(r ApiGetContractsPublicBidsContractIdRequest) ([]ContractsPublicBidsContractIdGetInner, *http.Response, error)

	/*
	GetContractsPublicItemsContractId Get public contract items

	Lists items of a public contract

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractId
	@return ApiGetContractsPublicItemsContractIdRequest
	*/
	GetContractsPublicItemsContractId(ctx context.Context, contractId int64) ApiGetContractsPublicItemsContractIdRequest

	// GetContractsPublicItemsContractIdExecute executes the request
	//  @return []ContractsPublicItemsContractIdGetInner
	GetContractsPublicItemsContractIdExecute(r ApiGetContractsPublicItemsContractIdRequest) ([]ContractsPublicItemsContractIdGetInner, *http.Response, error)

	/*
	GetContractsPublicRegionId Get public contracts

	Returns a paginated list of all public contracts in the given region

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param regionId
	@return ApiGetContractsPublicRegionIdRequest
	*/
	GetContractsPublicRegionId(ctx context.Context, regionId int64) ApiGetContractsPublicRegionIdRequest

	// GetContractsPublicRegionIdExecute executes the request
	//  @return []ContractsPublicRegionIdGetInner
	GetContractsPublicRegionIdExecute(r ApiGetContractsPublicRegionIdRequest) ([]ContractsPublicRegionIdGetInner, *http.Response, error)

	/*
	GetCorporationsCorporationIdContracts Get corporation contracts

	Returns contracts available to a corporation, only if the corporation is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is "in_progress".

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdContractsRequest
	*/
	GetCorporationsCorporationIdContracts(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdContractsRequest

	// GetCorporationsCorporationIdContractsExecute executes the request
	//  @return []CorporationsCorporationIdContractsGetInner
	GetCorporationsCorporationIdContractsExecute(r ApiGetCorporationsCorporationIdContractsRequest) ([]CorporationsCorporationIdContractsGetInner, *http.Response, error)

	/*
	GetCorporationsCorporationIdContractsContractIdBids Get corporation contract bids

	Lists bids on a particular auction contract

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractId
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdContractsContractIdBidsRequest
	*/
	GetCorporationsCorporationIdContractsContractIdBids(ctx context.Context, contractId int64, corporationId int64) ApiGetCorporationsCorporationIdContractsContractIdBidsRequest

	// GetCorporationsCorporationIdContractsContractIdBidsExecute executes the request
	//  @return []CharactersCharacterIdContractsContractIdBidsGetInner
	GetCorporationsCorporationIdContractsContractIdBidsExecute(r ApiGetCorporationsCorporationIdContractsContractIdBidsRequest) ([]CharactersCharacterIdContractsContractIdBidsGetInner, *http.Response, error)

	/*
	GetCorporationsCorporationIdContractsContractIdItems Get corporation contract items

	Lists items of a particular contract

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractId
	@param corporationId The ID of the corporation
	@return ApiGetCorporationsCorporationIdContractsContractIdItemsRequest
	*/
	GetCorporationsCorporationIdContractsContractIdItems(ctx context.Context, contractId int64, corporationId int64) ApiGetCorporationsCorporationIdContractsContractIdItemsRequest

	// GetCorporationsCorporationIdContractsContractIdItemsExecute executes the request
	//  @return []CharactersCharacterIdContractsContractIdItemsGetInner
	GetCorporationsCorporationIdContractsContractIdItemsExecute(r ApiGetCorporationsCorporationIdContractsContractIdItemsRequest) ([]CharactersCharacterIdContractsContractIdItemsGetInner, *http.Response, error)
}

// ContractsAPIService ContractsAPI service
type ContractsAPIService service

type ApiGetCharactersCharacterIdContractsRequest struct {
	ctx context.Context
	ApiService ContractsAPI
	characterId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdContractsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdContractsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCharactersCharacterIdContractsRequest) Page(page int32) ApiGetCharactersCharacterIdContractsRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdContractsRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdContractsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdContractsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdContractsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdContractsRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdContractsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdContractsRequest) Execute() ([]CharactersCharacterIdContractsGetInner, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdContractsExecute(r)
}

/*
GetCharactersCharacterIdContracts Get contracts

Returns contracts available to a character, only if the character is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is "in_progress".

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @return ApiGetCharactersCharacterIdContractsRequest
*/
func (a *ContractsAPIService) GetCharactersCharacterIdContracts(ctx context.Context, characterId int64) ApiGetCharactersCharacterIdContractsRequest {
	return ApiGetCharactersCharacterIdContractsRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
	}
}

// Execute executes the request
//  @return []CharactersCharacterIdContractsGetInner
func (a *ContractsAPIService) GetCharactersCharacterIdContractsExecute(r ApiGetCharactersCharacterIdContractsRequest) ([]CharactersCharacterIdContractsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharactersCharacterIdContractsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.GetCharactersCharacterIdContracts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/contracts"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCharactersCharacterIdContractsContractIdBidsRequest struct {
	ctx context.Context
	ApiService ContractsAPI
	characterId int64
	contractId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdContractsContractIdBidsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdContractsContractIdBidsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdContractsContractIdBidsRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdContractsContractIdBidsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdContractsContractIdBidsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdContractsContractIdBidsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdContractsContractIdBidsRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdContractsContractIdBidsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdContractsContractIdBidsRequest) Execute() ([]CharactersCharacterIdContractsContractIdBidsGetInner, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdContractsContractIdBidsExecute(r)
}

/*
GetCharactersCharacterIdContractsContractIdBids Get contract bids

Lists bids on a particular auction contract

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @param contractId
 @return ApiGetCharactersCharacterIdContractsContractIdBidsRequest
*/
func (a *ContractsAPIService) GetCharactersCharacterIdContractsContractIdBids(ctx context.Context, characterId int64, contractId int64) ApiGetCharactersCharacterIdContractsContractIdBidsRequest {
	return ApiGetCharactersCharacterIdContractsContractIdBidsRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
		contractId: contractId,
	}
}

// Execute executes the request
//  @return []CharactersCharacterIdContractsContractIdBidsGetInner
func (a *ContractsAPIService) GetCharactersCharacterIdContractsContractIdBidsExecute(r ApiGetCharactersCharacterIdContractsContractIdBidsRequest) ([]CharactersCharacterIdContractsContractIdBidsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharactersCharacterIdContractsContractIdBidsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.GetCharactersCharacterIdContractsContractIdBids")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/contracts/{contract_id}/bids"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contract_id"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCharactersCharacterIdContractsContractIdItemsRequest struct {
	ctx context.Context
	ApiService ContractsAPI
	characterId int64
	contractId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCharactersCharacterIdContractsContractIdItemsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCharactersCharacterIdContractsContractIdItemsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCharactersCharacterIdContractsContractIdItemsRequest) AcceptLanguage(acceptLanguage string) ApiGetCharactersCharacterIdContractsContractIdItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCharactersCharacterIdContractsContractIdItemsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCharactersCharacterIdContractsContractIdItemsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCharactersCharacterIdContractsContractIdItemsRequest) XTenant(xTenant string) ApiGetCharactersCharacterIdContractsContractIdItemsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCharactersCharacterIdContractsContractIdItemsRequest) Execute() ([]CharactersCharacterIdContractsContractIdItemsGetInner, *http.Response, error) {
	return r.ApiService.GetCharactersCharacterIdContractsContractIdItemsExecute(r)
}

/*
GetCharactersCharacterIdContractsContractIdItems Get contract items

Lists items of a particular contract

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param characterId The ID of the character
 @param contractId
 @return ApiGetCharactersCharacterIdContractsContractIdItemsRequest
*/
func (a *ContractsAPIService) GetCharactersCharacterIdContractsContractIdItems(ctx context.Context, characterId int64, contractId int64) ApiGetCharactersCharacterIdContractsContractIdItemsRequest {
	return ApiGetCharactersCharacterIdContractsContractIdItemsRequest{
		ApiService: a,
		ctx: ctx,
		characterId: characterId,
		contractId: contractId,
	}
}

// Execute executes the request
//  @return []CharactersCharacterIdContractsContractIdItemsGetInner
func (a *ContractsAPIService) GetCharactersCharacterIdContractsContractIdItemsExecute(r ApiGetCharactersCharacterIdContractsContractIdItemsRequest) ([]CharactersCharacterIdContractsContractIdItemsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharactersCharacterIdContractsContractIdItemsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.GetCharactersCharacterIdContractsContractIdItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/characters/{character_id}/contracts/{contract_id}/items"
	localVarPath = strings.Replace(localVarPath, "{"+"character_id"+"}", url.PathEscape(parameterValueToString(r.characterId, "characterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contract_id"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContractsPublicBidsContractIdRequest struct {
	ctx context.Context
	ApiService ContractsAPI
	contractId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetContractsPublicBidsContractIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetContractsPublicBidsContractIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetContractsPublicBidsContractIdRequest) Page(page int32) ApiGetContractsPublicBidsContractIdRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetContractsPublicBidsContractIdRequest) AcceptLanguage(acceptLanguage string) ApiGetContractsPublicBidsContractIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetContractsPublicBidsContractIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetContractsPublicBidsContractIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetContractsPublicBidsContractIdRequest) XTenant(xTenant string) ApiGetContractsPublicBidsContractIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetContractsPublicBidsContractIdRequest) Execute() ([]ContractsPublicBidsContractIdGetInner, *http.Response, error) {
	return r.ApiService.GetContractsPublicBidsContractIdExecute(r)
}

/*
GetContractsPublicBidsContractId Get public contract bids

Lists bids on a public auction contract

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractId
 @return ApiGetContractsPublicBidsContractIdRequest
*/
func (a *ContractsAPIService) GetContractsPublicBidsContractId(ctx context.Context, contractId int64) ApiGetContractsPublicBidsContractIdRequest {
	return ApiGetContractsPublicBidsContractIdRequest{
		ApiService: a,
		ctx: ctx,
		contractId: contractId,
	}
}

// Execute executes the request
//  @return []ContractsPublicBidsContractIdGetInner
func (a *ContractsAPIService) GetContractsPublicBidsContractIdExecute(r ApiGetContractsPublicBidsContractIdRequest) ([]ContractsPublicBidsContractIdGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ContractsPublicBidsContractIdGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.GetContractsPublicBidsContractId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/public/bids/{contract_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contract_id"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContractsPublicItemsContractIdRequest struct {
	ctx context.Context
	ApiService ContractsAPI
	contractId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetContractsPublicItemsContractIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetContractsPublicItemsContractIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetContractsPublicItemsContractIdRequest) Page(page int32) ApiGetContractsPublicItemsContractIdRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetContractsPublicItemsContractIdRequest) AcceptLanguage(acceptLanguage string) ApiGetContractsPublicItemsContractIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetContractsPublicItemsContractIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetContractsPublicItemsContractIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetContractsPublicItemsContractIdRequest) XTenant(xTenant string) ApiGetContractsPublicItemsContractIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetContractsPublicItemsContractIdRequest) Execute() ([]ContractsPublicItemsContractIdGetInner, *http.Response, error) {
	return r.ApiService.GetContractsPublicItemsContractIdExecute(r)
}

/*
GetContractsPublicItemsContractId Get public contract items

Lists items of a public contract

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractId
 @return ApiGetContractsPublicItemsContractIdRequest
*/
func (a *ContractsAPIService) GetContractsPublicItemsContractId(ctx context.Context, contractId int64) ApiGetContractsPublicItemsContractIdRequest {
	return ApiGetContractsPublicItemsContractIdRequest{
		ApiService: a,
		ctx: ctx,
		contractId: contractId,
	}
}

// Execute executes the request
//  @return []ContractsPublicItemsContractIdGetInner
func (a *ContractsAPIService) GetContractsPublicItemsContractIdExecute(r ApiGetContractsPublicItemsContractIdRequest) ([]ContractsPublicItemsContractIdGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ContractsPublicItemsContractIdGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.GetContractsPublicItemsContractId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/public/items/{contract_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"contract_id"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContractsPublicRegionIdRequest struct {
	ctx context.Context
	ApiService ContractsAPI
	regionId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetContractsPublicRegionIdRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetContractsPublicRegionIdRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetContractsPublicRegionIdRequest) Page(page int32) ApiGetContractsPublicRegionIdRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetContractsPublicRegionIdRequest) AcceptLanguage(acceptLanguage string) ApiGetContractsPublicRegionIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetContractsPublicRegionIdRequest) IfNoneMatch(ifNoneMatch string) ApiGetContractsPublicRegionIdRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetContractsPublicRegionIdRequest) XTenant(xTenant string) ApiGetContractsPublicRegionIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetContractsPublicRegionIdRequest) Execute() ([]ContractsPublicRegionIdGetInner, *http.Response, error) {
	return r.ApiService.GetContractsPublicRegionIdExecute(r)
}

/*
GetContractsPublicRegionId Get public contracts

Returns a paginated list of all public contracts in the given region

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param regionId
 @return ApiGetContractsPublicRegionIdRequest
*/
func (a *ContractsAPIService) GetContractsPublicRegionId(ctx context.Context, regionId int64) ApiGetContractsPublicRegionIdRequest {
	return ApiGetContractsPublicRegionIdRequest{
		ApiService: a,
		ctx: ctx,
		regionId: regionId,
	}
}

// Execute executes the request
//  @return []ContractsPublicRegionIdGetInner
func (a *ContractsAPIService) GetContractsPublicRegionIdExecute(r ApiGetContractsPublicRegionIdRequest) ([]ContractsPublicRegionIdGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ContractsPublicRegionIdGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.GetContractsPublicRegionId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/public/{region_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"region_id"+"}", url.PathEscape(parameterValueToString(r.regionId, "regionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdContractsRequest struct {
	ctx context.Context
	ApiService ContractsAPI
	corporationId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdContractsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdContractsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCorporationsCorporationIdContractsRequest) Page(page int32) ApiGetCorporationsCorporationIdContractsRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdContractsRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdContractsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdContractsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdContractsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdContractsRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdContractsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdContractsRequest) Execute() ([]CorporationsCorporationIdContractsGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdContractsExecute(r)
}

/*
GetCorporationsCorporationIdContracts Get corporation contracts

Returns contracts available to a corporation, only if the corporation is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is "in_progress".

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdContractsRequest
*/
func (a *ContractsAPIService) GetCorporationsCorporationIdContracts(ctx context.Context, corporationId int64) ApiGetCorporationsCorporationIdContractsRequest {
	return ApiGetCorporationsCorporationIdContractsRequest{
		ApiService: a,
		ctx: ctx,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CorporationsCorporationIdContractsGetInner
func (a *ContractsAPIService) GetCorporationsCorporationIdContractsExecute(r ApiGetCorporationsCorporationIdContractsRequest) ([]CorporationsCorporationIdContractsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CorporationsCorporationIdContractsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.GetCorporationsCorporationIdContracts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/contracts"
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdContractsContractIdBidsRequest struct {
	ctx context.Context
	ApiService ContractsAPI
	contractId int64
	corporationId int64
	xCompatibilityDate *string
	page *int32
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdContractsContractIdBidsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdContractsContractIdBidsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

func (r ApiGetCorporationsCorporationIdContractsContractIdBidsRequest) Page(page int32) ApiGetCorporationsCorporationIdContractsContractIdBidsRequest {
	r.page = &page
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdContractsContractIdBidsRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdContractsContractIdBidsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdContractsContractIdBidsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdContractsContractIdBidsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdContractsContractIdBidsRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdContractsContractIdBidsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdContractsContractIdBidsRequest) Execute() ([]CharactersCharacterIdContractsContractIdBidsGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdContractsContractIdBidsExecute(r)
}

/*
GetCorporationsCorporationIdContractsContractIdBids Get corporation contract bids

Lists bids on a particular auction contract

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractId
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdContractsContractIdBidsRequest
*/
func (a *ContractsAPIService) GetCorporationsCorporationIdContractsContractIdBids(ctx context.Context, contractId int64, corporationId int64) ApiGetCorporationsCorporationIdContractsContractIdBidsRequest {
	return ApiGetCorporationsCorporationIdContractsContractIdBidsRequest{
		ApiService: a,
		ctx: ctx,
		contractId: contractId,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CharactersCharacterIdContractsContractIdBidsGetInner
func (a *ContractsAPIService) GetCorporationsCorporationIdContractsContractIdBidsExecute(r ApiGetCorporationsCorporationIdContractsContractIdBidsRequest) ([]CharactersCharacterIdContractsContractIdBidsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharactersCharacterIdContractsContractIdBidsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.GetCorporationsCorporationIdContractsContractIdBids")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/contracts/{contract_id}/bids"
	localVarPath = strings.Replace(localVarPath, "{"+"contract_id"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorporationsCorporationIdContractsContractIdItemsRequest struct {
	ctx context.Context
	ApiService ContractsAPI
	contractId int64
	corporationId int64
	xCompatibilityDate *string
	acceptLanguage *string
	ifNoneMatch *string
	xTenant *string
}

// The compatibility date for the request.
func (r ApiGetCorporationsCorporationIdContractsContractIdItemsRequest) XCompatibilityDate(xCompatibilityDate string) ApiGetCorporationsCorporationIdContractsContractIdItemsRequest {
	r.xCompatibilityDate = &xCompatibilityDate
	return r
}

// The language to use for the response.
func (r ApiGetCorporationsCorporationIdContractsContractIdItemsRequest) AcceptLanguage(acceptLanguage string) ApiGetCorporationsCorporationIdContractsContractIdItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// The ETag of the previous request. A 304 will be returned if this matches the current ETag.
func (r ApiGetCorporationsCorporationIdContractsContractIdItemsRequest) IfNoneMatch(ifNoneMatch string) ApiGetCorporationsCorporationIdContractsContractIdItemsRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The tenant ID for the request.
func (r ApiGetCorporationsCorporationIdContractsContractIdItemsRequest) XTenant(xTenant string) ApiGetCorporationsCorporationIdContractsContractIdItemsRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiGetCorporationsCorporationIdContractsContractIdItemsRequest) Execute() ([]CharactersCharacterIdContractsContractIdItemsGetInner, *http.Response, error) {
	return r.ApiService.GetCorporationsCorporationIdContractsContractIdItemsExecute(r)
}

/*
GetCorporationsCorporationIdContractsContractIdItems Get corporation contract items

Lists items of a particular contract

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractId
 @param corporationId The ID of the corporation
 @return ApiGetCorporationsCorporationIdContractsContractIdItemsRequest
*/
func (a *ContractsAPIService) GetCorporationsCorporationIdContractsContractIdItems(ctx context.Context, contractId int64, corporationId int64) ApiGetCorporationsCorporationIdContractsContractIdItemsRequest {
	return ApiGetCorporationsCorporationIdContractsContractIdItemsRequest{
		ApiService: a,
		ctx: ctx,
		contractId: contractId,
		corporationId: corporationId,
	}
}

// Execute executes the request
//  @return []CharactersCharacterIdContractsContractIdItemsGetInner
func (a *ContractsAPIService) GetCorporationsCorporationIdContractsContractIdItemsExecute(r ApiGetCorporationsCorporationIdContractsContractIdItemsRequest) ([]CharactersCharacterIdContractsContractIdItemsGetInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharactersCharacterIdContractsContractIdItemsGetInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.GetCorporationsCorporationIdContractsContractIdItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporations/{corporation_id}/contracts/{contract_id}/items"
	localVarPath = strings.Replace(localVarPath, "{"+"contract_id"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"corporation_id"+"}", url.PathEscape(parameterValueToString(r.corporationId, "corporationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCompatibilityDate == nil {
		r.xCompatibilityDate = &a.client.cfg.CompatibilityDate
	}
	// Removed original error check - now using configuration default value
	if false {
		return localVarReturnValue, nil, reportError("xCompatibilityDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "simple", "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Compatibility-Date", r.xCompatibilityDate, "simple", "")
	if r.xTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
